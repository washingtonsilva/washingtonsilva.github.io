---
title: "Introdu√ß√£o √† Linguagem R"
description: | 
  Um tutorial b√°sico sobre a linguagem R para Ci√™ncia de Dados.
lang: "pt"
date: "2024-07-07"
toc: true
number-sections: true
toc-depth: 2
toc-location: left
highlight-style: pygments
author:
  - name: Prof. Dr. Washington S. da Silva 
    affiliation: IFMG - Campus Formiga - Mestrado Profissional em Administra√ß√£o.
    affiliation-url: https://www.formiga.ifmg.edu.br/mestrado
crossref:
  fig-title: '**Fig.**'
  fig-labels: arabic
execute: 
  echo: true
  warning: false
  message: false
bibliography: referencias.bib
csl: associacao-brasileira-de-normas-tecnicas-ipea.csl
categories: [R, Reprodutibilidade]
---

```{r}
#| label: setup
#| echo: false

# carrega pacotes
library(here)
library(tidyverse)
library(gapminder)
library(kableExtra)
library(PerformanceAnalytics)
```


![](img/Rlogo.png){width=30% fig-align="center"}


# Introdu√ß√£o {#sec-introducao}


::: {.callout-note icon="false"}
## Objetivos

- Este tutorial √© destinado aos estudantes do bacharelado em Administra√ß√£o 
e aos mestrandos do Mestrado Profissional em Administra√ß√£o do 
IFMG - Campus Formiga.

- Tamb√©m √© √∫til para administradores, economistas, contabilistas, 
auditores e outros profissionais que desejam utilizar ferramentas 
modernas para criar relat√≥rios e outros produtos de forma reproduz√≠vel 
e audit√°vel.

- O objetivo principal √© proporcionar uma compreens√£o s√≥lida da linguagem 
R, desde seus fundamentos at√© aplica√ß√µes em an√°lise de dados, 
permitindo que alunos de gradua√ß√£o, mestrandos e demais profissionais 
e pesquisadores interessados desenvolvam habilidades para criar an√°lises 
reproduz√≠veis e audit√°veis. Embora o foco inicial seja a Ci√™ncia de Dados 
aplicada √† Administra√ß√£o, o conte√∫do foi elaborado para ser √∫til 
em diversas √°reas do conhecimento.
:::




::: {.callout-note icon="false"}
## Instalando a Linguagem R 4.4.1

1.  Acesse [https://cloud.r-project.org/](https://cloud.r-project.org/){target="_blank"}

2.  Selecione o sistema operacional, clicando em **Download R for Windows** 
por exemplo.

3.  Na p√°gina seguinte clique em **base**.

4.  Clique em **Download R-4.4.3 for Windows**. 

5.  Feito o download basta ir clicando em pr√≥ximo/next at√© a instala√ß√£o 
ser conclu√≠da.
:::



::: {.callout-note icon="false"}
## RStudio: Ambiente de Desenvolvimento para R

- Para uma experi√™ncia de programa√ß√£o mais produtiva com R, recomenda-se 
fortemente o uso do RStudio, um IDE (Ambiente de Desenvolvimento Integrado) 
especialmente projetado para trabalhar com a linguagem R.

- O RStudio oferece diversas funcionalidades que facilitam o aprendizado 
e uso da linguagem, como editor de c√≥digo com destaque de sintaxe, projetos 
Rstudio, integra√ß√£o com Git e suporte nativo ao sistema Quarto.

- Para instalar e configurar o RStudio, consulte nosso [Tutorial sobre RStudio](https://washingtonsilva.github.io/tutorials/rstudio/){target="_blank"}, 
onde s√£o apresentadas instru√ß√µes detalhadas para iniciantes.

- Embora seja perfeitamente poss√≠vel utilizar R com outros IDEs, a 
combina√ß√£o (R + RStudio) facilita e potencializa significativamente a 
experi√™ncia de aprendizado e desenvolvimento.
:::




::: {.callout-note icon="false"}
## O que √© R?

- R √© um ambiente ou sistema para computa√ß√£o estat√≠stica e gr√°fico. 

- Este sistema √© composto por duas partes: a pr√≥pria **linguagem** R (que √© o 
que a maioria das pessoas querem dizer quando falam sobre R) e um 
**ambiente de tempo de execu√ß√£o** (*runtime environment*).

- R √© uma linguagem **interpretada**, o que significa que os usu√°rios acessam 
suas fun√ß√µes por meio de um interpretador de linha de comando.

- Ao contr√°rio de linguagens como Python e Java, R n√£o √© uma linguagem 
de programa√ß√£o de uso geral. 

- Em vez disso, R √© considerada uma linguagem de dom√≠nio espec√≠fica (DSL), o 
que significa que suas fun√ß√µes e uso foram projetados para uma √°rea 
espec√≠fica de uso ou dom√≠nio.

- No caso de R, o dom√≠nio e a computa√ß√£o estat√≠stica. Por extens√£o, R √© 
comumente usada para todos os tipos de tarefas de ci√™ncia de dados.

- A linguagem R est√° equipada com um grande conjunto de fun√ß√µes internas 
para a manipula√ß√£o, an√°lise e visualiza√ß√£o de dados. 

- Al√©m das fun√ß√µes internas da linguagem, existem in√∫meros pacotes (como os
m√≥dulos de Python) que estendem as capacidades da linguagem.
:::




::: {.callout-note icon="false"}
## Origens da Linguagem R

**A linguagem S**

- A linguagem S foi desenvolvida em meados da d√©cada de 1970 por John Chambers 
no lend√°rio Bell Labs. O objetivo era oferecer uma abordagem interativa 
para a computa√ß√£o estat√≠stica, que fosse f√°cil de usar e tornasse as tarefas 
de an√°lise de dados mais f√°ceis e r√°pidas.

- Em uma entrevista de 2013, Chambers observou que a equipe do Bell Labs 
queria que as pessoas come√ßassem em um ambiente interativo, onde n√£o 
pensassem em si como programadores. Ent√£o, √† medida que 
suas necessidades se tornaram mais claras e sua sofistica√ß√£o aumentasse, 
eles dseriam capazes de se orientar gradualmente para a programa√ß√£o 
com a linguagem S.

- A filosofia geral de S era muito semelhante √† de R: oferecer um ambiente 
de software que facilitasse a programa√ß√£o computacional e a an√°lise 
estat√≠stica, que qualquer um possa aprender a usar.

- Como R, S tamb√©m pode ser usada para escrever programas mais longos 
centrados em tarefas estat√≠sticas. Ao contr√°rio de R, no entanto, S e 
sua itera√ß√£o posterior, *S-Plus*, eram produtos licenciados, o que 
significa que tinham que ser comprados de uma empresa.

- Portanto, √© importante notar que a linguagem R √© um dialeto da 
linguagem S.

**Sint√°xe e Sem√¢ntica**

- Os linguistas usam os termos sintaxe e sem√¢ntica para descrever elementos 
de linguagens naturais, e os cientistas da computa√ß√£o tamb√©m adotaram 
esses termos para linguagens de programa√ß√£o.

- Na programa√ß√£o de computadores, a sintaxe se refere √†s regras que ditam 
a 'ortografia' e a 'gram√°tica' de uma linguagem, enquanto a sem√¢ntica 
se refere a como os dados ou comandos de uma linguagem s√£o apresentados.

- A sintaxe de R era muito semelhante √† de S em seus primeiros anos. Isso 
tornou mais f√°cil para as pessoas que usavam *S-Plus* mudar para R, o que 
desempenhou um papel fundamental na eventual popularidade de R na academia. 

- A sem√¢ntica de R, no entanto, est√° mais pr√≥xima da linguagem Scheme, 
uma linguagem de programa√ß√£o funcional.

**R √© uma linguagem de baixo ou alto n√≠vel?**

- R √© considerada uma linguagem de programa√ß√£o de alto n√≠vel. Essa 
classifica√ß√£o √© baseada em seu n√≠vel de abstra√ß√£o da linguagem 
de m√°quina. 

- Ao contr√°rio das linguagens de baixo n√≠vel que exigem conhecimento 
aprofundado da mem√≥ria e dos processos do computador, linguagens de 
alto n√≠vel como R s√£o projetadas para serem facilmente compreendidas 
e escritas por humanos, tornando-as mais acess√≠veis para estat√≠sticos, 
analistas de dados e pesquisadores.
:::




::: {.callout-note icon="false"}
## Um Breve Hist√≥rico da Linguagem R

- **1991**: Os professores e estat√≠sticos Ross Ihaka e Robert Gentleman 
come√ßam a trabalhar em um novo dialeto da linguagem S como um projeto de 
pesquisa para o Departamento de Estat√≠stica da Universidade de Auckland 
na Nova Zel√¢ndia.

- **1993**: O primeiro an√∫ncio de R chega ao p√∫blico atrav√©s do arquivo de 
dados StatLib e da lista de discuss√£o s-news.

- **1995**: O estat√≠stico Martin M√§chler convence os criadodes de R a lan√ßar 
a linguagem sob uma licen√ßa p√∫blica geral GNU, tornando R gratuita e 
de c√≥digo aberto. Ihaka e Gentleman lan√ßam seu artigo seminal apresentando 
R ao mundo.

- **1997**: O R Core Team foi formado, este grupo √© o √∫nico com acesso ao 
c√≥digo-fonte R. No mesmo ano, foi criada a 
*Comprehensive R Archive Network* (CRAN). Este reposit√≥rio de pacotes R 
ajuda os profissionais em in√∫meras tarefas.

- **2000**: R vers√£o 1.0.0 foi lan√ßada ao p√∫blico.

- **Mar√ßo de 2024**: Estamos atualmente na vers√£o R 4.3.3
:::




::: {.callout-note icon="false"}
## Por que usar a linguagem R?

- **Gratuito e de c√≥digo aberto**: Diferentemente de softwares estat√≠sticos 
propriet√°rios, R √© completamente gratuito e seu c√≥digo-fonte √© aberto, 
permitindo total transpar√™ncia e personaliza√ß√£o.

- **Especialmente projetado para an√°lise estat√≠stica e ci√™ncia de dados**: 
Enquanto outras linguagens podem ser adaptadas para estas tarefas, R foi 
concebida especificamente para computa√ß√£o estat√≠stica e visualiza√ß√£o 
de dados.

- **Ampla comunidade acad√™mica e profissional**: R possui uma comunidade 
ativa de usu√°rios que contribuem constantemente com novos pacotes, m√©todos e 
solu√ß√µes para problemas complexos.

- **Integra√ß√£o com o sistema Quarto**: Perfeita compatibilidade com o 
sistema de publica√ß√£o Quarto, permitindo a cria√ß√£o de documentos, 
apresenta√ß√µes e websites din√¢micos e reproduz√≠veis.

- **Ecossistema Tidyverse**: O conjunto de pacotes Tidyverse fornece 
uma gram√°tica consistente para manipula√ß√£o, visualiza√ß√£o e modelagem 
de dados, especialmente √∫til para iniciantes.

- **Excel√™ncia em visualiza√ß√£o de dados**: Pacotes como ggplot2 permitem 
criar visualiza√ß√µes estat√≠sticas sofisticadas e personaliz√°veis.

- **Relev√¢ncia no mercado**: Profissionais com conhecimento em R s√£o 
valorizados em setores como finan√ßas, consultorias, pesquisa de mercado 
e an√°lise de neg√≥cios.

- **Reprodutibilidade cient√≠fica**: R facilita a implementa√ß√£o de 
pr√°ticas de ci√™ncia reproduz√≠vel, essencial para pesquisas acad√™micas 
e relat√≥rios corporativos audit√°veis.

- **Versatilidade em tipos de an√°lise**: Desde estat√≠sticas descritivas 
simples at√© modelos complexos de machine learning e econometria aplicada, 
R oferece ferramentas para diversos n√≠veis de an√°lise.

- **Documenta√ß√£o extensa**: Ampla disponibilidade de documenta√ß√£o, 
tutoriais, livros e recursos online, facilitando o aprendizado cont√≠nuo.
:::


::: {.callout-note icon="false"}
## V√≠deo sobre R

- Para finalizar esta introdu√ß√£o, assista o v√≠deo a seguir sobre a 
linguagem R disponibilizado pelo 
[R Consortium](https://r-consortium.org){target="_blank"}: 

{{< video https://www.youtube.com/watch?v=XcBLEVknqvY
    title="What is R?"
    aspect-ratio="21x9" 
>}}
:::



::: {.callout-note icon="false"}
## Pr√≥ximos Passos

Nas pr√≥ximas se√ß√µes do tutorial vamos explorar os conceitos b√°sicos 
da linguagem R, que servir√£o como alicerce para os t√≥picos posteriores. 
Compreender esses fundamentos √© essencial antes de avan√ßarmos para 
an√°lises mais complexas.
:::




# Objetos e Vari√°veis em R

Em R, os termos "vari√°vel" e "objeto" s√£o frequentemente usados de 
forma intercambi√°vel, o que pode causar confus√£o inicial, especialmente 
para quem j√° possui experi√™ncia com outras linguagens de programa√ß√£o. 
Esta se√ß√£o esclarece essa terminologia para facilitar seu aprendizado.

::: {.callout-note icon="false"}
## A Filosofia "Tudo √© um Objeto" em R

R segue uma filosofia fundamental: **tudo que existe em R √© um objeto**. 
Isso significa que todos os elementos que voc√™ manipula ‚Äî desde 
n√∫meros simples at√© fun√ß√µes complexas ‚Äî s√£o tratados como objetos. 

Esta abordagem difere de muitas outras linguagens de programa√ß√£o que 
fazem distin√ß√£o clara entre "vari√°veis primitivas" (como n√∫meros) e 
"objetos" (estruturas mais complexas).

Quando criamos algo em R usando um operador de atribui√ß√£o (`<-`), 
estamos essencialmente:

1. Criando um objeto na mem√≥ria do computador
2. Atribuindo um nome a esse objeto para referenci√°-lo posteriormente

Por exemplo, em `idade <- 25`, criamos um objeto do tipo num√©rico 
com valor 25 e o nomeamos como "idade". Este nome funciona como uma 
etiqueta que nos permite acessar e manipular o objeto.
:::

::: {.callout-tip}
## Por que usarei "vari√°vel" e "objeto" de forma intercambi√°vel?

Por quest√µes de clareza e para facilitar seu aprendizado:

- Utilizarei o termo **vari√°vel** principalmente quando falarmos de 
valores simples que "variam", como n√∫meros, textos ou valores l√≥gicos. 
Este termo √© mais intuitivo para iniciantes e comum em estat√≠stica 
e an√°lise de dados.

- Utilizarei o termo **objeto** quando precisarmos enfatizar a 
natureza mais complexa de algumas estruturas em R, como data frames, 
listas, fun√ß√µes ou quando discutirmos conceitos mais avan√ßados.

- Em muitos contextos, usarei ambos os termos de forma intercambi√°vel, 
refletindo a pr√°tica comum na comunidade R.

Esta flexibilidade terminol√≥gica espelha a documenta√ß√£o oficial da 
linguagem R e a literatura sobre a linguagem, preparando voc√™ 
para diferentes materiais que poder√° encontrar em sua jornada 
de aprendizado.
:::



::: {.callout-note icon="false"}
## Uma Analogia √ötil

Imagine uma biblioteca onde cada livro √© um "objeto" de dados:

- O **conte√∫do do livro** representa os dados ou valores armazenados.

- O **t√≠tulo na lateral** representa o nome da vari√°vel

- As **prateleiras e estantes** representam a mem√≥ria do computador

- O **cat√°logo da biblioteca** equivale ao ambiente R, que mant√©m 
registro de onde cada objeto est√° armazenado

Quando voc√™ cria uma vari√°vel como `receita <- 5000`, √© como se estivesse 
colocando um novo livro (com o conte√∫do "5000") na biblioteca e 
rotulando sua lateral como "receita" para poder encontr√°-lo depois.
:::


Este entendimento sobre vari√°veis e objetos em R estabelece uma base 
conceitual importante antes de mergulharmos nos tipos espec√≠ficos de 
dados e em como manipul√°-los para an√°lises eficazes.





# Vari√°veis e Atribui√ß√£o de Valores

Em R, a atribui√ß√£o de valores a vari√°veis √© fundamental para armazenar e 
manipular dados. Por exemplo, podemos criar vari√°veis para armazenar 
informa√ß√µes financeiras, como receitas, custos e lucros, que s√£o 
essenciais para an√°lises em Administra√ß√£o.

```{r}
# Exemplo: Atribui√ß√£o de valores a vari√°veis
receita_mensal <- 850000  # Receita mensal da empresa
custos_mensais <- 500000  # Custos mensais

# C√°lculo do lucro
lucro_mensal <- receita_mensal - custos_mensais  
lucro_mensal
```

Todas as instru√ß√µes R com as quais criamos vari√°veis ou objetos t√™m 
o mesmo formato:

```{r}
#| eval: false
#| echo: true

nome_do_objeto <- valor
```

Lemos esse c√≥digo como: "*valor √© atribu√≠do a nome_objeto*"

Em R, podemos atribuir informa√ß√µes √†s vari√°veis (ou objetos) utilizando 
os seguintes operadores de atribui√ß√£o:

```{r}
#| label: op-atribuicao
#| echo: true

# Diferentes formas de atribui√ß√£o em R
# Mesmo resultado, estilos diferentes

# Operador recomendado (<-) 
receita_mensal <- 850000
receita_mensal

# Alternativa (=), funciona, mas menos 
# recomendado
lucro_operacional = 320000
lucro_operacional
```

Em R, como em todas as linguagens, fazemos muitas atribui√ß√µes de 
valores a vari√°veis, e n√£o √© agrad√°vel digitar o operador manualmente. 
Assim, o RStudio oferece um atalho de teclado simples para inserir 
o operador `<-`:

- Atalho do RStudio: `Alt + -` (Windows/Linux) ou `Option + -` (Mac)

- Observe que o RStudio automaticamente envolve `<-` 
com **espa√ßos**, o que √© uma boa pr√°tica de formata√ß√£o de c√≥digo.

- C√≥digos sem espa√ßos s√£o dif√≠ceis de ler compare: 

`lucro<-receita-custos` versus 

`lucro <- receita - custos`


::: {.callout-note icon="false"}
## Boas Pr√°ticas para Escrever C√≥digos R

Nomes de vari√°veis devem come√ßar com uma letra e podem conter 
`letras`, `n√∫meros`, `_` e `.`

√â importante criar nomes de objetos **simples e descritivos** que 
representem claramente seu conte√∫do. Em Administra√ß√£o, √© comum 
trabalhar com dados financeiros, de desempenho ou de mercado, 
ent√£o use nomes que facilitem a compreens√£o do c√≥digo.

**Exemplos de boas pr√°ticas**:

```{r}
#| eval: false

# Margem bruta da empresa
margem_bruta <- 0.35  

# Fluxo de caixa operacional
fluxo_caixa_operacional <- receita - custos  
```

**Estilos de nomenclatura**:

- **snake_case**: `margem_bruta`, `fluxo_caixa_operacional`
- **CamelCase**: `MargemBruta`, `FluxoCaixaOperacional`

Escolha um estilo e mantenha a consist√™ncia em todo o c√≥digo.
:::


::: {.callout-warning}
## Pr√°ticas a evitar

Evite os seguintes erros comuns:

1. **Nomes gen√©ricos**:

- Ruim: `dados`, `resultado`, `x`
- Melhor: `receita_anual`, `lucro_liquido`


2. **Nomes muito longos**:

- Ruim: `calculo_da_margem_de_contribuicao_ajustada`
- Melhor: `margem_contribuicao`


3. **Espa√ßos nos nomes**:

- Ruim: `margem bruta <- 0.35` (causa erro)
- Melhor: `margem_bruta <- 0.35`


4. **Nomes come√ßando com n√∫meros**:

- Ruim: `1trimestre <- "Janeiro-Mar√ßo"` (inv√°lido)
- Melhor: `trimestre1 <- "Janeiro-Mar√ßo"`


5. **Sobrescrever fun√ß√µes existentes**:

- Ruim: `mean <- 10` (sobrescreve a fun√ß√£o `mean()`)
- Melhor: `media <- 10`
:::


::: {.callout-tip}
## Como Imprimir Informa√ß√µes sobre Objetos em R

Em R, existem algumas formas simples e eficazes de exibir 
informa√ß√µes sobre objetos ou vari√°veis. Esses m√©todos s√£o ideais 
para visualizar valores, depurar c√≥digo ou criar sa√≠das personalizadas. 
Abaixo est√£o as principais formas:

**1. Usando** `print()`

A fun√ß√£o `print()` √© a maneira mais b√°sica de exibir o conte√∫do de 
um objeto:

```{r}
# Exemplo: Usando print()
receita <- 850000.50
print(receita)  # Exibe o valor da vari√°vel
```

**2. Imprimindo diretamente no console**

Em R, voc√™ pode exibir o conte√∫do de um objeto simplesmente 
digitando seu nome no console. Isso chama automaticamente 
a fun√ß√£o `print()` implicitamente:

```{r}
# digitar o nome do objeto exibe seu valor
receita  
```

**3. Usando a fun√ß√£o** `cat()` 

A fun√ß√£o `cat()` permite exibir informa√ß√µes de forma mais 
personalizada, combinando texto e valores. √â √∫til para criar 
mensagens ou relat√≥rios simples.

```{r}
# a fun√ßa√£o cat() combina texto e valor
cat("A receita mensal √©:", receita)  
```

**Resumo**:

- Use `print()` para exibir valores de forma expl√≠cita.

- Digite o nome do objeto diretamente no console para exibir 
  seu valor de forma r√°pida.
  
- Use `cat()` para criar sa√≠das personalizadas, combinando 
  texto e valores.
:::





# Tipos At√¥micos de Dados

Em R, os dados s√£o armazenados em diferentes tipos at√¥micos (b√°sicos), 
cada um com caracter√≠sticas espec√≠ficas. A @tbl-1 mostra os principais 
tipos.

Tipo          | Classe      | Descri√ß√£o                          
------------- | ----------- | ----------------------------------
`double`      | `numeric`   | um vetor contendo valores reais (n√∫meros com casas decimais)
`integer`     | `numeric`   | um vetor contendo valores inteiros (n√∫meros sem casas decimais)
`character`   | `character` | um vetor contendo valores de texto (caracteres)
`logical`     | `logical`   | um vetor contendo valores l√≥gicos (`TRUE`/`FALSE`)

: Principais Tipos {#tbl-1}


A @tbl-2 exibe alguns tipos especiais que podem aparecer em an√°lises de 
dados. 

Tipo       | Descri√ß√£o    
-----------|---------------------------------------------  
`NA`       | `Not Available`: representa dados faltantes
`NaN`      | `Not a Number`: (ex: `0 / 0`)
`Inf`      | $+ \infty$ ou $- \infty$: (ex: `1 / 0`)

: Tipos Especiais {#tbl-2}


::: {.callout-tip}
## A Import√¢ncia de Conhecer Tipos e Classes de Dados

Na pr√°tica da Ci√™ncia de Dados, estima-se que analistas e cientistas 
dedicam entre 60% a 80% do tempo de um projeto √† importa√ß√£o, limpeza 
e prepara√ß√£o dos dados antes de iniciar an√°lises mais sofisticadas. 
Compreender profundamente os tipos e classes de dados em R √© fundamental 
por v√°rias raz√µes:

- **Evita erros sutis de processamento**: Opera√ß√µes matem√°ticas em 
dados textuais ou c√°lculos com valores ausentes podem produzir 
resultados inesperados.

- **Otimiza o desempenho**: Estruturas de dados apropriadas melhoram 
a efici√™ncia computacional, especialmente em conjuntos grandes.

- **Facilita transforma√ß√µes**: O conhecimento dos tipos permite 
convers√µes adequadas (como texto para n√∫mero) sem perda de informa√ß√£o.

- **Melhora a interpretabilidade**: Identificar corretamente dados 
faltantes (`NA`), indefinidos (`NaN`), ou infinitos (`Inf`) √© crucial 
para conclus√µes v√°lidas.

- **Aumenta a compatibilidade**: Diferentes fun√ß√µes e pacotes em R 
exigem tipos espec√≠ficos de dados como entrada.

O dom√≠nio dos tipos e classes de dados n√£o √© apenas uma quest√£o 
t√©cnica, mas um requisito fundamental para an√°lises confi√°veis 
em contextos administrativos e financeiros. Este conhecimento 
permite ao analista de dados concentrar-se mais nos insights e 
menos na corre√ß√£o de problemas estruturais nos dados.
:::



## Tipos `double` e `integer`

Em R, existem dois tipos principais de dados num√©ricos:

- **`double`**: Armazena n√∫meros com casas decimais (ponto flutuante), 
ideal para valores monet√°rios, √≠ndices financeiros, taxas percentuais 
e outras medidas que exigem precis√£o decimal.

- **`integer`**: Armazena n√∫meros inteiros sem casas decimais, √∫til 
para contagens, quantidades discretas e √≠ndices em s√©ries temporais.

Na pr√°tica de Administra√ß√£o e Finan√ßas, o tipo `double` √© frequentemente 
utilizado para representar valores monet√°rios, taxas de juros ou 
indicadores financeiros, enquanto `integer` √© mais comum para 
representar quantidades como n√∫mero de funcion√°rios, produtos 
vendidos ou per√≠odos de an√°lise.

O sufixo `L` ap√≥s um n√∫mero (como em `50L`) indica explicitamente 
que se trata de um valor inteiro. Na maioria das opera√ß√µes, R utiliza 
automaticamente o tipo mais apropriado, o que simplifica a 
programa√ß√£o para an√°lises financeiras e administrativas.

```{r}
# double (n√∫meros com casas decimais)
receita <- 850000.50  

# integer (n√∫meros inteiros)
total_funcionarios <- 50L   

# verifica os tipos
typeof(receita)
typeof(total_funcionarios)
```


::: {.callout-tip}
## classe `numeric`

Apesar dos tipos `double` e `integer` representarem n√∫meros decimais e 
inteiros de forma diferente, ambos pertencem √† classe `numeric`, assim, 
na maioria das situa√ß√µes, voc√™ n√£o precisa se preocupar com a poss√≠vel 
diferen√ßa.

```{r}
class(receita)
class(total_funcionarios)
```

**Diferen√ßa entre** `typeof` e `class`

Em R, as fun√ß√µes `typeof` e `class` fornecem informa√ß√µes diferentes 
sobre um objeto:

- **`typeof`**: Retorna o **tipo interno** do objeto, ou seja, 
como R armazena o objeto na mem√≥ria. Por exemplo:

```{r}
#| eval: false
typeof(receita)  # Retorna "double"
typeof(total_funcionarios)  # Retorna "integer"
```

- **`class`**: Retorna a **classe** do objeto, que define como R 
trata o objeto em opera√ß√µes e fun√ß√µes. Por exemplo:

```{r}
#| eval: false
class(receita)  # Retorna "numeric"
class(total_funcionarios)  # Retorna "numeric"
```

Em resumo:

- Use `typeof` para entender como R armazena o objeto internamente.
- Use `class` para entender como R trata o objeto em opera√ß√µes e fun√ß√µes.
:::



## Tipo `character`

O tipo `character` √© essencial para armazenar e manipular informa√ß√µes 
textuais. Este tipo de dado armazena sequ√™ncias de caracteres 
(texto) e √© indicado por aspas simples (`'`) ou duplas (`"`).

Em contextos de Administra√ß√£o, o tipo `character` √© utilizado 
para armazenar:

- Nomes de empresas, setores ou produtos
- Categorias em classifica√ß√µes de mercado
- Per√≠odos de tempo expressos como texto (Ex: "1¬∞ Trimestre 2024")
- C√≥digos de identifica√ß√£o alfanum√©ricos
- Observa√ß√µes qualitativas

A manipula√ß√£o de dados textuais √© particularmente importante em 
an√°lises de mercado, pesquisas de satisfa√ß√£o, classifica√ß√£o de 
produtos e organiza√ß√£o de relat√≥rios gerenciais, onde a categoriza√ß√£o 
textual precede an√°lises quantitativas.


```{r}
# character (texto)
instituicao <- "IFMG - Campus Formiga" 

# verifica o tipo 
typeof(instituicao)
```



## Tipo `logical` 

O tipo `logical` representa valores booleanos (`TRUE` ou `FALSE`) e √© 
fundamental para opera√ß√µes condicionais e filtragem de dados.

Em contextos pr√°ticos de gest√£o e finan√ßas, o tipo `logical` 
√© utilizado para:

- Verificar condi√ß√µes financeiras (Ex: lucro positivo, meta atingida)
- Filtrar dados que atendem a crit√©rios espec√≠ficos
- Automatizar decis√µes baseadas em regras de neg√≥cio
- Sinalizar eventos importantes (Ex: inadimpl√™ncia, quebra de estoque)
- Implementar valida√ß√µes em modelos de previs√£o

Os valores `TRUE` e `FALSE` devem ser escritos em mai√∫sculas em R, e 
podem ser abreviados como `T` e `F`, respectivamente, embora a forma 
completa seja recomendada para maior clareza do c√≥digo.


```{r}
# logical (l√≥gico, TRUE/FALSE)
lucro_positivo <- TRUE  
lucro_negativo <- FALSE

# verifica o tipo 
typeof(lucro_positivo)
typeof(lucro_negativo)
```



## Tipo Especial `NA`

O tipo especial `NA` (*Not Available*) √© comum em an√°lises de dados 
reais, onde frequentemente nos deparamos com informa√ß√µes ausentes. Em 
contextos de Administra√ß√£o e Finan√ßas, dados faltantes podem representar:

- Vendas n√£o realizadas em determinados per√≠odos
- Informa√ß√µes cont√°beis pendentes
- Valores n√£o reportados em demonstra√ß√µes financeiras
- Respostas omitidas em pesquisas de mercado
- M√©tricas n√£o aplic√°veis a certos departamentos ou produtos

Identificar e tratar corretamente os valores `NA` √© essencial para 
evitar conclus√µes tendenciosas. R oferece fun√ß√µes espec√≠ficas 
como `is.na()` para detectar valores ausentes e m√©todos 
estat√≠sticos para lidar com eles de forma apropriada.

```{r}
# Exemplo: Detectando valores ausentes em dados de vendas 
vendas_trimestrais <- c(150000, 165000, NA, 180000)
is.na(vendas_trimestrais) 

# calculando a m√©dia excluindo valores ausentes
mean(vendas_trimestrais, na.rm = TRUE)
```

O tratamento adequado de dados falantes √© uma habilidade 
fundamental em Ci√™ncia de Dados.


## Tipo Especial `NaN` 

O valor `NaN` (*Not a Number*) ocorre quando uma opera√ß√£o matem√°tica 
produz um resultado indefinido. Em contextos de gest√£o e finan√ßas, 
este tipo especial pode surgir em:

- C√°lculos de indicadores financeiros com divisores zero
- Opera√ß√µes matem√°ticas inv√°lidas em modelos preditivos
- Transforma√ß√µes logar√≠tmicas de valores negativos ou zero
- Ra√≠zes quadradas de n√∫meros negativos em an√°lises estat√≠sticas

Enquanto `NA` representa dados ausentes, `NaN` indica especificamente 
um resultado num√©rico indefinido. Diferenci√°-los √© importante para 
diagn√≥stico de problemas em c√°lculos complexos, como em modelos de 
precifica√ß√£o de ativos ou simula√ß√µes financeiras.

A fun√ß√£o `is.nan()` permite identificar estes valores em conjuntos de dados:

```{r}
# Exemplo: Identificando resultados indefinidos em c√°lculos financeiros
resultados <- c(25, 0/0, 10)
is.nan(resultados)  
```



## Tipo Especial `inf`

O valor especial `Inf` (e `-Inf` para infinito negativo) ocorre 
principalmente em divis√µes por zero e representa valores que 
excedem os limites computacionais. Em an√°lises administrativas 
e financeiras, este tipo pode aparecer em:

- C√°lculos de taxas de crescimento a partir de valores base zero
- Raz√µes financeiras com denominadores muito pr√≥ximos a zero
- Proje√ß√µes exponenciais sem restri√ß√µes
- An√°lises de retorno sobre investimento com investimentos m√≠nimos

Diferentemente de `NA` e `NaN`, valores `Inf` podem ser utilizados 
em opera√ß√µes aritm√©ticas seguindo regras matem√°ticas de infinito:

```{r}
# Exemplo: Comportamento de infinito em opera√ß√µes
infinito_positivo <- 1/0
infinito_positivo + 1000  # Continua sendo Inf
infinito_positivo / 2     # Continua sendo Inf
```

Identificar valores infinitos √© importante, por exemplo, 
em modelos financeiros, pois podem indicar problemas estruturais 
nas f√≥rmulas utilizadas ou divis√µes por zero que 
comprometem a validade das an√°lises.


::: {.callout-tip}
## Sobre Convers√£o entre Tipos e Classes de Dados

- Voc√™ pode estar se perguntando como converter um tipo ou 
classe de dados em outro(a) (por exemplo, transformar um texto em 
n√∫mero ou vice-versa). 

- Embora R base ofere√ßa fun√ß√µes como `as.numeric()`, `as.character()` e 
`as.logical()` para essas convers√µes, abordaremos este t√≥pico mais 
adiante no tutorial, quando estudarmos a manipula√ß√£o de dados com 
o pacote `dplyr`.

- Especificamente, aprenderemos como usar as fun√ß√µes `mutate()` e 
`transmute()` para realizar convers√µes de tipos de maneira eficiente 
e leg√≠vel em conjuntos de dados estruturados. Esta abordagem se alinha 
com as pr√°ticas modernas de ci√™ncia de dados e permite transformar 
m√∫ltiplas vari√°veis simultaneamente dentro de um fluxo de trabalho 
anal√≠tico coerente.

- Por enquanto, foque em compreender as caracter√≠sticas e comportamentos 
dos diferentes tipos de dados apresentados nesta se√ß√£o, pois este 
conhecimento fundamentar√° toda sua jornada na an√°lise de dados com R.
:::




# Vetores em R {#sec-vetores}

::: {.callout-note icon="false"}
## Por que come√ßar pelos vetores?

- Vetores s√£o a **estrutura de dados mais b√°sica e fundamental** da linguagem R.
- Toda vari√°vel simples em R ‚Äî como um n√∫mero, texto ou valor l√≥gico ‚Äî **√© um vetor de comprimento 1**.
- Vetores armazenam sequ√™ncias de **valores homog√™neos**, ou seja, todos os elementos t√™m o **mesmo tipo**: num√©rico, l√≥gico ou texto.
- Compreender vetores √© **pr√©-requisito para manipular dados em estruturas mais avan√ßadas**, como *data frames*, *tibbles* e listas.
:::


::: {.callout-tip}
## Analogia

Imagine que voc√™ est√° lidando com uma **planilha do Excel** onde cada coluna cont√©m apenas um tipo de dado:

- A coluna "Receitas Mensais" possui apenas n√∫meros ‚Üí vetor `numeric`
- A coluna "Nome da Empresa" possui apenas textos ‚Üí vetor `character`
- A coluna "Meta Atingida?" possui apenas `TRUE` ou `FALSE` ‚Üí vetor `logical`

Cada coluna √©, conceitualmente, **um vetor em R**: uma sequ√™ncia ordenada, homog√™nea e indexada.
:::




## Criando vetores

A fun√ß√£o mais b√°sica para criar vetores √© `c()`, que significa "concatenar" ou "combinar".

```{r}
#| label: vet-criacao
#| echo: true

# Vetor de retornos mensais (%)
retornos <- c(0.012, -0.005, 0.007, 0.013)

# Sequ√™ncia de inteiros de 1 a 4
dias <- 1:4                 

# Sequ√™ncia trimestral: 1, 4, 7, 10
meses <- seq(1, 12, by = 3) 

# Vetor l√≥gico repetido quatro vezes
flags <- rep(TRUE, 4)       
```



::: {.callout-tip}
## Sobre a fun√ß√£o `c()`

A fun√ß√£o `c()` combina valores **do mesmo tipo** em um vetor.

```{r}
#| label: vet-cfunc
#| echo: true
c("IFMG", "UFV", "USP")      # vetor de textos
c(TRUE, FALSE, TRUE)         # vetor l√≥gico
c(1.2, 2.5, 3.8)             # vetor num√©rico (double)
```

Se os elementos tiverem **tipos diferentes**, R far√° *coer√ß√£o impl√≠cita* para um tipo comum. Por exemplo:

```{r}
c(1, "texto", TRUE)  # Todos convertidos para texto (character)
```
:::




## Indexa√ß√£o: selecionando elementos

Vetores s√£o indexados com colchetes `[]`. A indexa√ß√£o come√ßa em **1** (n√£o em zero, como em Python ou C).

```{r}
#| label: vet-index
#| echo: true

# Primeiro e √∫ltimo retorno
retornos[1]                  
retornos[length(retornos)]   

# Excluindo o segundo elemento
retornos[-2]                 

# Selecionando apenas valores positivos
retornos[retornos > 0]       
```



::: {.callout-note}
## Filtro condicional em vetores

Express√µes como `retornos > 0` retornam um vetor l√≥gico com `TRUE`/`FALSE`, que pode ser usado para **filtrar elementos**:

```{r}
#| echo: true
retornos > 0  # vetor l√≥gico
retornos[retornos > 0]  # filtragem condicional
```

Este comportamento √© fundamental para manipula√ß√£o de dados no `dplyr`.
:::




## Opera√ß√µes vetorizadas e reciclagem

Em R, voc√™ pode aplicar opera√ß√µes matem√°ticas diretamente sobre vetores.

```{r}
#| label: vet-ops
#| echo: true

# Aplicando desconto de IR (15%)
ret_liq <- retornos * (1 - 0.15)  

# Reciclagem de vetor: IR de 15% e 20% aplicados alternadamente
taxas <- c(0.15, 0.20)
ret_liq2 <- retornos * (1 - taxas)  
```


::: {.callout-warning}
## Cuidado com a reciclagem autom√°tica

Se os vetores tiverem **comprimentos incompat√≠veis**, R ainda assim executar√° a opera√ß√£o com uma **mensagem de aviso**, podendo gerar **resultados incorretos**.

```{r}
#| echo: true
c(1, 2, 3) + c(10, 20)  # comprimento 3 e 2 => erro sutil
```
:::


## Testando tipos e classes

Vetores devem ter **elementos do mesmo tipo**, mas podemos verificar isso com:

```{r}
# Verifica o tipo at√¥mico (typeof) e a classe do objeto
typeof(retornos)  # double
class(retornos)   # numeric
```



## Comprimento dos vetores

Use `length()` para saber quantos elementos um vetor possui:

```{r}
length(retornos)
```




## Vetores de texto (character) e l√≥gicos

```{r}
#| label: vet-text
#| echo: true

# Vetor de nomes de empresas
empresas <- c("Empresa A", "Empresa B", "Empresa C")

# Vetor l√≥gico: metas atingidas?
metas_atingidas <- c(TRUE, TRUE, FALSE)

# Combina√ß√£o com `cat()`
cat("Metas atingidas:", metas_atingidas, "\n")
```


## Boas pr√°ticas com vetores

- Prefira vetores **homog√™neos e bem nomeados**
- Use `typeof()` para detectar coer√ß√µes indesejadas
- Evite misturar tipos dentro de `c()` sem inten√ß√£o


::: {.callout-note icon="false"}
## Pr√≥ximos passos

Vetores s√£o a espinha dorsal de todas as estruturas de dados em R.
Compreender seu comportamento √© essencial para trabalhar com tabelas
(`data.frames`, `tibbles`), realizar filtros, aplicar transforma√ß√µes
e construir visualiza√ß√µes.

Na pr√≥xima se√ß√£o, vamos abordar os **data frames e tibbles**, que
correspondem √†s tabelas que usamos no dia a dia ‚Äî mas com todo o poder
do R por tr√°s.
:::




# Data Frames e Tibbles {#sec-dataframes}

::: {.callout-note icon="false"}
## Por que aprender sobre `data frames` e `tibbles`?

- Em R, **data frames** e **tibbles** s√£o as principais estruturas usadas para armazenar e analisar dados tabulares (como planilhas do Excel).

- Eles representam **conjuntos de dados organizados em colunas e linhas**, onde cada coluna √© um vetor.

- Compreender o funcionamento dessas estruturas √© essencial para importar, limpar, transformar, visualizar e modelar dados.
:::



::: {.callout-tip}
## Analogia

Pense em um **data frame** como uma **planilha**:

- Cada **coluna** √© uma vari√°vel (vetor).
- Cada **linha** representa uma observa√ß√£o ou caso.
- Um **tibble** √© como uma **planilha moderna**: mant√©m as mesmas funcionalidades, mas com melhorias que evitam erros e facilitam o uso com dados reais.
:::



## Criando uma `data frame` simples

```{r}
#| label: df-criar
#| echo: true

# Dados hipot√©ticos de empresas
empresa  <- c("A", "B", "C")
receita  <- c(3.5, 5.2, 4.1)     # em R$ milh√µes
metas    <- c(TRUE, TRUE, FALSE)

emp_df <- data.frame(empresa, receita, metas)
```

```{r}
#| label: df-print
#| echo: true

# Visualizando o data frame
emp_df
```


::: {.callout-note}
## Estrutura interna

Cada **coluna de um `data.frame` √© um vetor**, e todos os vetores **devem ter o mesmo comprimento**. As colunas podem ter **tipos diferentes**, mas devem ser **homog√™neas internamente**.
:::



## Convertendo para tibble

```{r}
#| label: df-tibble
#| echo: true
library(tibble)

emp_tb <- as_tibble(emp_df)
emp_tb
```


::: {.callout-tip}
## Por que usar tibbles?

- **Exibi√ß√£o inteligente**: Mostra apenas as primeiras linhas e colunas.
- **Evita convers√µes autom√°ticas perigosas** (como `stringsAsFactors`).
- **Integra-se perfeitamente ao tidyverse (`dplyr`, `ggplot2`, `tidyr`)**.
- **Mais leve para trabalhar com dados grandes ou listas aninhadas**.
:::



## Inspe√ß√£o da estrutura

```{r}
#| label: df-inspecao
#| echo: true

# vis√£o detalhada da tibble
str(emp_tb)

# vis√£o geral da tibble
glimpse(emp_tb)    

# resumo estat√≠stico das colunas num√©ricas
summary(emp_tb)    
```



## Nomes e tipos das colunas

```{r}
#| label: df-nomes-tipos
#| echo: true

# nomes das colunas
names(emp_tb)     

# classe de cada coluna
sapply(emp_tb, class) 
```




## Acessando colunas

```{r}
#| label: df-acesso
#| echo: true

# usando o operador $
emp_tb$receita         
```




## Exemplo com dados financeiros reais

Vamos utilizar o pacote `PerformanceAnalytics`, amplamente usado em finan√ßas, para ilustrar o uso de `tibbles` com s√©ries temporais reais.

```{r}
#| label: df-managers
#| echo: true


library(PerformanceAnalytics) # para obter a df `managers`
library(tidyverse)  # carrega dplyr, tidyr, ggplot2, tibble etc.

# Carrega os dados de performance de carteiras
data(managers, package = "PerformanceAnalytics")  

# Converte objeto xts -> tibble, salvando datas na coluna "date"
managers_tb <- as_tibble(managers, rownames = "date")

# Vis√£o geral da tibble
glimpse(managers_tb)
```



::: {.callout-note}
## O que aprendemos aqui?

- O objeto `managers_tb` cont√©m **retornos mensais de carteiras e benchmarks**.

- As colunas cont√™m s√©ries de retornos como `ManagerA`, `SP500`, `Russell2000`, etc.

- A coluna `date` foi criada a partir dos nomes das linhas do objeto 
original xts.
:::



## Verificando tipos e valores ausentes

```{r}
#| label: df-validacao
#| echo: true

# Verificando tipos at√¥micos e classes
sapply(managers_tb, typeof)     

# Verifica a presen√ßa dados faltantes
colSums(is.na(managers_tb))     
```

::: {.callout-warning}
## Import√¢ncia de entender a estrutura

Antes de aplicar qualquer modelo econom√©trico ou visualiza√ß√£o, **√© essencial garantir que os dados est√£o em um formato apropriado**:

- Verificar tipos (`character`, `numeric`, `logical`)
- Detectar valores ausentes (`NA`)
- Garantir que as colunas estejam nomeadas corretamente
:::


::: {.callout-tip}
## Trabalhar com dados reais

- Os dados do `PerformanceAnalytics` s√£o amplamente utilizados para an√°lise de performance de carteiras, avalia√ß√£o de risco, regress√µes CAPM e outros modelos em finan√ßas quantitativas.

- Utilizaremos este conjunto como **base para as pr√≥ximas se√ß√µes**: tidyverse, visualiza√ß√£o e modelagem.
:::



::: {.callout-note icon="false"}
## Pr√≥ximos passos

Agora que sabemos como criar, inspecionar e acessar `data frames` e `tibbles`, estamos prontos para trabalhar com **os pacotes do tidyverse**, que permitem manipular e transformar dados de forma elegante, eficiente e audit√°vel.
:::




# Metapacote tidyverse

::: {.callout-note icon=false}
## Descri√ß√£o

- O [tidyverse](https://www.tidyverse.org){target="_blank"} √© um 
ecossistema coerente de pacotes R para ci√™ncia de dados que compartilham 
uma filosofia de design e gram√°tica comuns.

- Desenvolvido por Hadley Wickham e mantido pela Posit, o tidyverse 
facilita todo o fluxo de trabalho de an√°lise de dados atrav√©s de 
pacotes integrados.

##### Alguns dos Principais Pacotes do tidyverse {.unnumbered}

- **readr/readxl**: Importa√ß√£o eficiente de dados retangulares
- **tidyr**: Estrutura√ß√£o de dados no formato "tidy" (`pivot_longer`, `pivot_wider`)
- **dplyr**: Manipula√ß√£o de dados com verbos intuitivos (`filter`, `select`, `mutate`)
- **ggplot2/gt**: Visualiza√ß√£o de dados baseada na gram√°tica dos gr√°ficos

- O tidyverse implementa o princ√≠pio de "tidy data", criando um fluxo 
de trabalho coeso atrav√©s do operador pipe (`%>%` ou `|>`).


#### Integra√ß√£o entre os Pacotes {.unnumbered}

O grande poder do tidyverse est√° na **integra√ß√£o entre seus pacotes**. 
Exemplo: um fluxo completo que:

1. **Transforma** os dados (`mutate`)
2. **Agrupa e resume** estat√≠sticas (`group_by`, `summarise`)
3. **Converte** em formato longo (`pivot_longer`)
4. **Visualiza** os dados (`ggplot2`)


#### Princ√≠pios do tidyverse {.unnumbered}

- **Consist√™ncia**: fun√ß√µes com sintaxe similar.
- **Composi√ß√£o**: c√≥digo encadeado com `%>%` ou `|>`.
- **Clareza sem ambiguidade**: nomes expressivos e argumentos expl√≠citos.
- **Reprodutibilidade**: f√°cil de entender, refatorar e auditar.

A filosofia do tidyverse est√° alinhada com os princ√≠pios modernos 
de ci√™ncia de dados transparente, audit√°vel e reproduz√≠vel.
:::




## Dados Organizados

- O conceito de **Tidy Data** (Dados Organizados) foi formalizado por
Hadley Wickham.

- Um arquivo de dados organizado possui a seguinte estrutura:

    - Cada **linha** representa **uma** observa√ß√£o individual
    - Cada **coluna** representa **uma** vari√°vel espec√≠fica
    - Cada **c√©lula** cont√©m **um** valor de **uma** vari√°vel para 
      **uma** observa√ß√£o espec√≠fica
  
- A @fig-2 ilustra o conceito de dados organizados visualmente.

![Dados Organizados](img/tidy_data.jpeg){#fig-2}



::: {.callout-note icon=false}
## Benef√≠cios de Dados Organizados

- **Adequa√ß√£o para Ferramentas**: Formato de armazenamento de dados 
adequado para an√°lise em linguagens (R/Python) e softwares de 
an√°lise de dados.

- **Consist√™ncia**: Estrutura uniforme para todos os conjuntos de dados

- **Facilidade para opera√ß√µes comuns**:

  - Filtragem de observa√ß√µes
  - Sele√ß√£o de vari√°veis
  - Cria√ß√£o de novas vari√°veis
  - Agrega√ß√£o de dados
  - Jun√ß√£o de m√∫ltiplas tabelas
:::



::: {.callout-note icon=false}
## Dados Financeiros Desorganizados T√≠picos

**Colunas contendo valores**: Nomes de colunas contendo valores 
de uma ou mais vari√°veis.

   - Ex: Colunas nomeadas com anos (2020, 2021, 2022)

```{.markdown style="font-size: 1em;"}
| Empresa   | 2020    | 2021    | 2022    |
|-----------|---------|---------|---------|
| Empresa A | 350.000 | 425.000 | 510.000 |
| Empresa B | 780.000 | 815.000 | 840.000 |
| Empresa C | 540.000 | 490.000 | 620.000 |
```
:::




::: {.callout-note icon=false}
## Vers√£o Organizada dos Dados Anteriores:

```{.markdown style="font-size: 1em;"}
| Empresa   | Ano  | Valor   |
|-----------|------|---------|
| Empresa A | 2020 | 350.000 |
| Empresa A | 2021 | 425.000 |
| Empresa A | 2022 | 510.000 |
| Empresa B | 2020 | 780.000 |
| Empresa B | 2021 | 815.000 |
| Empresa B | 2022 | 840.000 |
| Empresa C | 2020 | 540.000 |
| Empresa C | 2021 | 490.000 |
| Empresa C | 2022 | 620.000 |
```

**Caracter√≠sticas:**

- Cada vari√°vel est√° em uma coluna separada
- Cada observa√ß√£o est√° em uma linha
- Cada c√©lula cont√©m um valor √∫nico
:::




::: {.callout-note icon=false}
## Tipos de "Desorganiza√ß√£o" Comuns em Administra√ß√£o

**M√∫ltiplas vari√°veis em uma coluna**: Uma coluna contendo mais 
de uma vari√°vel

   - Ex: "Nome_Empresa (Ano)" combinando empresa e ano

```{.markdown style="font-size: 1em;"}
| Nome_Empresa (Ano) | Receita       | Despesa       |
|--------------------|---------------|---------------|
| Empresa A (2020)   | R$ 350.000,00 | R$ 290.000,00 |
| Empresa A (2021)   | R$ 425.000,00 | R$ 320.000,00 |
| Empresa B (2020)   | R$ 780.000,00 | R$ 710.000,00 |
| Empresa B (2021)   | R$ 815.000,00 | R$ 735.000,00 |
```

- **N√£o** se deve usar unidades (R$ no caso) em arquivos 
para armazenamento de dados para an√°lise.
:::



::: {.callout-note icon=false}
## **Vers√£o Organizada dos Dados**:

```{.markdown style="font-size: 1em;"}
| Empresa    | Ano  | Receita  | Despesa  |
|------------|------|----------|----------|
| Empresa A  | 2020 | 350000   | 290000   |
| Empresa A  | 2021 | 425000   | 320000   |
| Empresa B  | 2020 | 780000   | 710000   |
| Empresa B  | 2021 | 815000   | 735000   |
```
:::




::: {.callout-note icon=false}
## M√∫ltiplas vari√°veis em uma coluna:

- Os n√∫meros referem-se ao lucro l√≠quido trimestral das 
empresas em milh√µes de reais:

```{.markdown style="font-size: 1em;"}
| Empresa    | T1 2023 | T2 2023 | T3 2023 | T4 2023 |
|------------|---------|---------|---------|---------|
| TechSoft   | 25.3    | 31.7    | 28.4    | 35.2    |
| VarejoMax  | 12.8    | 15.4    | 19.3    | 22.7    |
| FinGroup   | 41.6    | 38.9    | 45.2    | 51.8    |
```

- **Problemas:**

    - Valores de uma vari√°vel (trimestre) est√£o nas colunas
    - N√£o segue o princ√≠pio "uma coluna, uma vari√°vel"
    - Dificulta an√°lises temporais e comparativas
:::



::: {.callout-note icon=false}
## **Vers√£o Organizada dos Dados**:

```{.markdown style="font-size: 1em;"}
| Empresa   | Trimestre | Ano  | Lucro_Liquido |
|-----------|-----------|------|---------------|
| TechSoft  | T1        | 2023 | 25.3          |
| TechSoft  | T2        | 2023 | 31.7          |
| TechSoft  | T3        | 2023 | 28.4          |
| TechSoft  | T4        | 2023 | 35.2          |
| VarejoMax | T1        | 2023 | 12.8          |
| VarejoMax | T2        | 2023 | 15.4          |
| VarejoMax | T3        | 2023 | 19.3          |
| VarejoMax | T4        | 2023 | 22.7          |
| FinGroup  | T1        | 2023 | 41.6          |
| FinGroup  | T2        | 2023 | 38.9          |
| FinGroup  | T3        | 2023 | 45.2          |
| FinGroup  | T4        | 2023 | 51.8          |
```
:::





::: {.callout-note icon=false}
## Tipos de "Desorganiza√ß√£o" Comuns em Administra√ß√£o

**Vari√°veis em linhas e colunas**

   - Ex: Planilha de desempenho onde ROE aparece como coluna, mas 
   Lucro L√≠quido e outras vari√°veis aparecem nas linhas

```{.markdown style="font-size: 1em;"}
| Empresa            | ROE (%)       | Liquidez Corrente |
|--------------------|---------------|-------------------|
| Empresa XYZ        | 15,2          | 1,8               |
| Lucro L√≠quido      | R$ 2.500.000  | -                 |
| Patrim√¥nio L√≠quido | R$ 16.400.000 | -                 |
| Ativo Circulante   | -             | R$ 3.600.000      |
| Passivo Circulante | -             | R$ 2.000.000      |
```
:::



::: {.callout-note icon=false}
## **Vers√£o Organizada dos Dados**:

```{.markdown style="font-size: 1em;"}
| Empresa    | Indicador           | Valor       |
|------------|---------------------|-------------|
| Empresa XYZ| ROE                 | 0.152       |
| Empresa XYZ| Liquidez Corrente   | 1.8         |
| Empresa XYZ| Lucro L√≠quido       | 2500000     |
| Empresa XYZ| Patrim√¥nio L√≠quido  | 16400000    |
| Empresa XYZ| Ativo Circulante    | 3600000     |
| Empresa XYZ| Passivo Circulante  | 2000000     |
```
:::


  
::: {.callout-tip}  
## Por que a absoluta maioria dos arquivos de dados s√£o desorganizados?

- Por que a maioria das pessoas que trabalham na √°rea de neg√≥cios 
**n√£o est√°** familiarizada com os **princ√≠pios** da organiza√ß√£o 
de dados para an√°lise e utilizam **planilhas eletr√¥nicas** para 
trabalhar com dados.

- Planilhas de dados s√£o frequentemente organizadas pensando em 
**apresentar** os dados ou para tornar a **entrada** de dados mais 
simples, n√£o em um formato adequado para armazenamento e an√°lise.

- Isso significa que, para a maioria das an√°lises reais, cientistas e 
analistas de dados **dispendem muito tempo e esfor√ßo** organizando e 
preparando dados elaborados por terceiros.

- A **primeira etapa** √© sempre descobrir quais s√£o as **observa√ß√µes** 
e as **vari√°veis** associadas a cada observa√ß√£o.
:::



::: {.callout-note icon=false}
## Benef√≠cios para Disserta√ß√µes e Artigos Cient√≠ficos

Dados organizados viabilizam e facilitam a:

- **Reprodutibilidade**: Formato padronizado que outros pesquisadores 
podem entender e utilizar

- **Visualiza√ß√µes avan√ßadas**: Estrutura ideal para a cria√ß√£o de diversos 
tipos de tabelas e gr√°ficos.

- **An√°lise econom√©trica**: Adequa√ß√£o imediata para estudos e 
modelos econom√©tricos em  (regress√£o linear, painel, logit, probit etc.)
:::




## Planilhas Eletr√¥nicas


::: {.callout-warning}
## @broman2018: Riscos para Armazenamento de Dados

- Planilhas eletr√¥nicas t√™m **alto risco de erros**: Em 13 auditorias de 
planilhas reais, uma m√©dia de **88%** continham erros [@broman2018].

- Problemas comuns incluem: 

  - Convers√£o autom√°tica de formatos (ex: nomes de genes 
    interpretados como datas)
  
  - Armazenamento de datas de forma diferente entre sistemas operacionais
  
  - C√°lculos incorporados que podem corromper dados originais

  - A mistura de an√°lise, visualiza√ß√£o e armazenamento no mesmo arquivo 
    aumenta o risco de comprometer os dados brutos e os resultados.

- Mas dada a ubiquidade de planilhas nas organiza√ß√µes, caso precise usar 
planilhas para armazenar dados, siga as seguintes boas pr√°ticas:
:::



::: {.callout-tip}
## Recomenda√ß√µes pr√°ticas para organizar dados em planilhas.

- Artigo de @broman2018

- Crie planilhas **organizadas** (uma linha = uma observa√ß√£o, uma 
coluna = uma vari√°vel, uma c√©lula = um valor)

- Seja **consistente** e escolha **bons nomes** para as vari√°veis: 

    - use `snake_case` ou `CamelCase`
    - `Lucro L√≠quido (R$)` üò±
    - `lucro_liquido` ou `LucroLiquido` üòÉ
    - **NUNCA use** acentos, caracteres especiais e espa√ßos vaziso para nomes ou 
      valores.
   

- Escreva **datas** conforme a [Norma ISO 8601](https://pt.wikipedia.org/wiki/ISO_8601){target="_blank}: 

    - `YYYY-MM-DD`, exemplo: `2025-05-07`

- **Sem** c√©lulas vazias: use h√≠fen (`-`) e no caso de usar R, use `NA` 

- Crie um **dicion√°rio dos dados**

- **NUNCA fa√ßa c√°lculos** na planilha dos dados originais/brutos

- **NUNCA use** unidades de medida (R$), cor ou realce como um dado.

    - `R$ 50.000,00` üò±
    - `50000` üòÉ
    - `10 %` üò± 
    - `O.1` üòÉ

- **Fa√ßa backups**

- Use **valida√ß√£o** dos dados para evitar erros

- **Salve** os dados em **arquivos de texto simples** (`.csv`): 

    - todas as linguagens (R/Python) e softwares de an√°lises de dados 
      reconhecem facilmente esse formato.
:::


::: {.callout-tip}  
## Pacote tidyr

Na pr√≥xima se√ß√£o, vamos aprender sobre como o pacote tidyr do 
tidyverse pode ser usado para tornar alguns tipos de dados 
desorganizados em dados organizados para an√°lise.
:::




# Introdu√ß√£o ao Pacote tidyr 

![](https://tidyr.tidyverse.org/logo.png){fig-align="center" width="30%"}

::: {.callout-note icon=false}
## O pacote tidyr no ecossistema tidyverse

- O [tidyr](https://tidyr.tidyverse.org){target="_blank"} √© um pacote do 
  tidyverse para **organizar dados desorganizados**

- Seu nome vem de "*tidy*" (organizado) + "r" (R)

- Foi criado para facilitar a transforma√ß√£o de dados desorganizados em 
dados organizados (*tidy data*) para an√°lise

- √â muito √∫til para a prepara√ß√£o de dados na fase 3 do CRISP-DM (Prepara√ß√£o dos Dados)

- Permite que dados em formatos comuns de planilhas e relat√≥rios sejam 
  transformados em formatos adequados para an√°lise e visualiza√ß√£o
:::




::: {.callout-note icon=false}
## A Principal fun√ß√£o do pacote tidyr para n√≥s

- `pivot_longer()`: Converte dados do formato amplo 
(onde valores de uma ou mais vari√°veis s√£o espalhadas por colunas) em 
um formato longo (onde cada vari√°vel est√° em uma √∫nica coluna).

  - √ötil quando voc√™ precisa de de dados para an√°lise ou visualiza√ß√£o
  
  - **Ex**: Transformar colunas de trimestres (Q1, Q2, Q3, Q4) em uma 
    √∫nica coluna "trimestre"

- Iremos estudar **somente** a fun√ß√£o `pivot_longer()`, porque 
o foco deste m√≥dulo √© a prepara√ß√£o de dados para an√°lise.

- Mas h√° diversas outras fun√ß√µes √∫teis para a organiza√ß√£o de dados:
:::




### Quando usar o tidyr?

::: {.callout-note icon=false}
## Situa√ß√µes comuns em Administra√ß√£o

- Quando voc√™ tem **planilhas financeiras** com colunas para diferentes 
per√≠odos (meses, trimestres, anos)
  
- Quando voc√™ recebe **planilhas Excel** organizadas para visualiza√ß√£o 
humana, mas n√£o para an√°lise de dados.
  
- Quando precisa **combinar dados** de diferentes fontes que est√£o em 
formatos incompat√≠veis.
  
- Quando precisa **preparar dados** para visualiza√ß√µes espec√≠ficas com 
ggplot2 (gr√°ficos de linhas, facetas, etc.)
  
- Quando realiza **an√°lises temporais** e precisa converter entre 
formatos de data/hora.
:::




### A Fun√ß√£o tidyr::pivot_longer 


::: {.callout-note icon=false}
## Ao final desta se√ß√£o, voc√™ ser√° capaz de:

- **Aplicar** a fun√ß√£o pivot_longer() com seus par√¢metros essenciais:
  `cols`, `names_to` e `values_to`
  
- **Organizar/Transformar** dados complexos extraindo m√∫ltiplas 
informa√ß√µes de colunas
  
- **Integrar** pivot_longer() em pipelines de an√°lise com dplyr
  
- **Implementar** solu√ß√µes para casos reais de an√°lise de dados 
administrativos
:::


::: {.callout-note icon=false}
## Transformando dados de formato amplo para longo

- A fun√ß√£o `pivot_longer()` converte dados do formato **amplo** (wide) 
para o formato **longo** (long)

- √â muito √∫til quando as colunas cont√™m **valores** em vez de **vari√°veis**
  
- Geralmente, √© o primeiro passo para transformar planilhas de neg√≥cios em 
  dados organizados para an√°lise (*tidy data*)
  
- A @fig-3 ilustra o uso desta fun√ß√£o
:::


![Aplicando a fun√ß√£o pivot_longer()](img/pivot_longer.jpeg){#fig-3}



### Sintaxe da fun√ß√£o pivot_longer()

::: {.callout-tip}
## Como usar pivot_longer() na pr√°tica

```{r}
#| eval: false

# Formato b√°sico
dados %>%
  pivot_longer(
    cols = "valores_de_uma_nova_coluna",
    names_to = "nome_nova_coluna",
    values_to = "nome_outra_nova_coluna"
  )
```

- **valores_de_uma_nova_coluna**: as <u>colunas</u> que cont√™m valores de 
uma vari√°vel e ser√£o transformadas.

- **nome_nova_coluna**: <u>nome</u> da nova coluna/vari√°vel que conter√° os 
nomes das colunas originais.

- **nome_outra_nova_coluna**: <u>nome</u> da nova coluna/vari√°vel que 
conter√° os valores originais.
:::




### Fun√ß√£o pivot_longer 

::: {.callout-tip}
## Descri√ß√£o

| Caracter√≠stica         | pivot_longer()                                    | 
|------------------------|---------------------------------------------------|
| **Transforma**         | Colunas ‚Üí Linhas                                  | 
| **Formato resultante** | Longo (mais linhas)                               |
| **Quando usar**        | Para an√°lise e visualiza√ß√£o                       | 
| **Exemplo t√≠pico**     | Transformar colunas de anos em uma vari√°vel "ano" | 
:::





### A Fun√ß√£o tribble()

::: {.callout-note icon=false}
## Descri√ß√£o

A fun√ß√£o `tribble()` (abrevia√ß√£o de "*transposed tibble*") √© uma forma 
elegante de criar pequenas tibbles/data frames para exemplos ou testes:

```{r}
# Criando uma data frame com tribble() - "tibble transposta"
produtos <- tribble(
  ~codigo, ~produto, ~preco, # Nomes das colunas come√ßam com ~
  "A123", "Notebook", 3500, # Cada linha √© um registro
  "B456", "Smartphone", 1800, # Os valores s√£o separados por v√≠rgulas
  "C789", "Monitor", 950 # A formata√ß√£o facilita a leitura
)

# Visualizando a data frame criada
produtos
```

**Vantagens da fun√ß√£o tribble():**

- **Layout Visual**: Cada linha do c√≥digo corresponde a uma linha da data 
  frame, tornando o c√≥digo mais leg√≠vel
  
- **Especifica√ß√£o direta**: Os nomes das colunas s√£o definidos com ~ (til)

- **Flexibilidade de tipos**: Cada coluna pode conter diferentes tipos de dados

- **Ideal para exemplos**: Perfeita para criar pequenas data frames para 
demonstra√ß√µes ou testes.

Esta fun√ß√£o faz parte do pacote `tibble`, que √© carregado automaticamente 
quando voc√™ carrega o `tidyverse`.
:::




### Exemplo B√°sico de pivot_longer()

::: {.callout-note icon=false}
## Dados de receita trimestral (formato amplo/wide)

```{r}
# Criando a data frame de exemplo
receitas <- tribble(
  ~produto, ~T1, ~T2, ~T3, ~T4,
  "Produto A", 50000, 55000, 60000, 65000,
  "Produto B", 30000, 32000, 35000, 37000,
  "Produto C", 20000, 22000, 25000, 27000
)

# Visualizando a data frame original (formato amplo/wide)
receitas
```

Este formato √© para apresenta√ß√£o, n√£o para armazenamento e 
an√°lise.
:::



::: {.callout-note icon=false}
## Transformando para o formato longo

```{r}
#| eval: true

# Transformando para o formato longo usando pivot_longer
receitas_longas <- receitas %>%
  pivot_longer(
    cols = c("T1", "T2", "T3", "T4"), # colunas que ser√£o valores da nova coluna
    names_to = "trimestre", # nome da nova coluna
    values_to = "receita" # nome de outra nova coluna
  )

# Visualizando o resultado (formato longo/long)
receitas_longas
```

Agora os dados est√£o organizados:

- Cada linha √© uma observa√ß√£o (um produto em um trimestre)
- Cada coluna √© uma vari√°vel (produto, trimestre, receita)
- Cada c√©lula cont√©m um √∫nico valor
:::




### Exemplo Intermedi√°rio: V√°rias Colunas

::: {.callout-note icon=false}
## Dados de desempenho financeiro 

```{r}
# Criando a data frame com m√∫ltiplas m√©tricas por trimestre
desempenho <- tribble(
  ~empresa, ~receita_T1, ~receita_T2, ~despesa_T1, ~despesa_T2,
  "Empresa A", 150000, 175000, 120000, 130000,
  "Empresa B", 250000, 270000, 200000, 220000,
  "Empresa C", 100000, 115000, 80000, 95000
)

# Visualizando a data frame original
desempenho
```

Este formato √© ainda mais desorganizado, pois mistura tr√™s vari√°veis 
(receita, despesa e trimestre) nos nomes das colunas.
:::



::: {.callout-note icon=false}
## Transformando para o formato longo com dois n√≠veis

```{r}
# Transformando para o formato longo usando pivot_longer com nomes separados
desempenho_longo <- desempenho %>%
  pivot_longer(
    cols = -empresa, # todas as colunas exceto "empresa"
    names_to = c("indicador", "trimestre"), # nomes das duas novas colunas
    names_sep = "_", # separador nos nomes das colunas
    values_to = "valor" # nome de nova coluna para receber os valores
  )

# Visualizando o resultado
desempenho_longo
```

**Observa√ß√£o importante:** 

- Os nomes das colunas originais (`receita_T1`, `receita_T2`, etc.) s√£o 
divididos pelo separador "_" em exatamente duas partes. 

- A primeira parte ("receita" ou "despesa") vai para a coluna "indicador" 
e a segunda parte ("T1" ou "T2") vai para a coluna "trimestre". 

- Este √© um padr√£o comum em dados financeiros: quando os nomes de colunas 
seguem um formato consistente com separadores, podemos extrair as informa√ß√µes 
contidas neles para criar novas vari√°veis.
:::




### Exemplo Avan√ßado 

::: {.callout-note icon=false}
## Indicadores financeiros por trimestre

```{r}
# Exemplo mais gerenci√°vel para slides
receita_trimestral <- tribble(
  ~empresa, ~`2022_T1_Receita`, ~`2022_T2_Receita`, ~`2023_T1_Receita`, ~`2023_T2_Receita`,
  "ABC Ltda", 1200000, 1350000, 1500000, 1620000,
  "XYZ S.A.", 2500000, 2700000, 2900000, 3100000
)

# Visualizando a data frame original
receita_trimestral
```

- Temos informa√ß√µes de ano e trimestre nos nomes das colunas
:::



::: {.callout-note icon=false}
## Organizando dados financeiros complexos

```{r}
# Transformando para o formato longo usando pivot_longer com tr√™s n√≠veis
receita_trimestral_organizada <- receita_trimestral %>%
  pivot_longer(
    cols = -empresa, # todas as colunas exceto "empresa"
    names_to = c("ano", "trimestre"), # nomes de duas novas colunas
    names_sep = "_", # separador nos nomes das colunas
    values_to = "receita" # nome de nova coluna para receber os valores da receita
  )

# Visualizando o resultado
receita_trimestral_organizada
```
:::




### Resumo: Fun√ß√£o pivot_longer()

::: {.callout-tip}
## O que voc√™ precisa lembrar

1. **Finalidade**: Transformar dados do formato amplo (wide) para o 
formato longo (long), organizando-os conforme o princ√≠pio tidy data

2. **Sintaxe b√°sica**:

```{r}
#| eval: false
dados %>%
  pivot_longer(
    cols = colunas_a_transformar,
    names_to = "nome_nova_coluna_para_nomes",
    values_to = "nome_nova_coluna_para_valores"
  )
```

3. **Par√¢metros principais**:

- `cols`: Quais colunas ser√£o transformadas em pares nome-valor
- `names_to`: Nome da nova coluna que receber√° os nomes das colunas originais
- `values_to`: Nome da nova coluna que receber√° os valores

<br>
4. **Caso avan√ßado**:

- Quando os nomes de colunas cont√™m m√∫ltiplas informa√ß√µes, use:

    - `names_to = c("variavel1", "variavel2", ...)`
    - `names_sep = "_"` (ou outro separador presente nos nomes)

<br>
5. **Benef√≠cios**:

- Padroniza o formato de dados conforme princ√≠pios da ci√™ncia de dados
- Facilita an√°lises com dplyr (group_by, summarize, etc.)
- Prepara dados para visualiza√ß√µes eficientes
:::




### Dicas para Trabalhar com tidyr

::: {.callout-tip}
## Recomenda√ß√µes pr√°ticas

1. **Identifique as vari√°veis**: Antes de transformar, identifique 
claramente quais s√£o as observa√ß√µes e vari√°veis reais nos seus dados

2. **Comece com subconjuntos**: Para dados complexos, comece testando 
com um pequeno subconjunto de dados

3. **Use nomes descritivos**: Escolha bons nomes para as novas colunas 
criadas por `pivot_longer()` 

4. **Combine com dplyr**: As transforma√ß√µes com tidyr geralmente s√£o 
seguidas por opera√ß√µes com dplyr para an√°lise

5. **Verifique os resultados**: Sempre confira se os dados transformados 
mant√™m as mesmas informa√ß√µes dos dados originais
:::





### Resumo: Pacote tidyr

::: {.callout-tip}
## O que voc√™ precisa lembrar

1. **O que faz**: O pacote tidyr transforma dados entre os formatos 
amplo (wide) e longo (long)

2. **Principal fun√ß√£o**:

   - `pivot_longer()`: Converte de amplo (*wide*) para longo (*long*) 
   (colunas para linhas)

3. **Quando usar**:

   - Use `pivot_longer()` quando colunas contiverem valores em vez de 
     vari√°veis

4. **Import√¢ncia na an√°lise de dados**:

   - √â essencial para a prepara√ß√£o de dados (fase 3 do CRISP-DM)
   
   - Permite transformar dados comuns de neg√≥cios em formatos adequados 
     para an√°lise

   - Facilita a aplica√ß√£o de fun√ß√µes do dplyr e cria√ß√£o de visualiza√ß√µes

5. **Lembre-se sempre**:

   - Dados organizados (tidy) t√™m uma vari√°vel por coluna, uma observa√ß√£o 
     por linha.
:::





# Introdu√ß√£o ao Pacote dplyr

![](https://dplyr.tidyverse.org/logo.png){fig-align="center"}

::: {.callout-note icon=false}
## O pacote dplyr no ecossistema tidyverse

- O [dplyr](https://dplyr.tidyverse.org/index.html){target="_blank"} √© um 
dos pacotes principais do [tidyverse](https://www.tidyverse.org){target="_blank"}, 
criado por Hadley Wickham

- Seu nome vem de "*data plier*" (alicate para dados) - uma ferramenta 
para manipular dados

- Foi projetado seguindo a filosofia "*tidy data*" (dados 
organizados) - cada vari√°vel √© uma coluna, cada observa√ß√£o √© uma linha

- √â escrito em C++ para performance otimizada

- Permite manipula√ß√£o de dados de forma consistente, clara e encadeada
:::




::: {.callout-note icon=false}
## O dplyr no Ecossistema R

- O pacote dplyr √© parte do **tidyverse**
  
- Enquanto os pacotes **readr** e **readxl** ajudam 
  na importa√ß√£o de dados, o dplyr √© especializado na **manipula√ß√£o** 
  de dados
  
- O dplyr foi otimizado para manipular sobre **dados organizados**, 
longos ou *tidy data*
  
- O dplyr trabalha com uma estrutura de dados de R que j√° 
  conhecemos: **data frames/tibbles**
  
- As fun√ß√µes do dplyr foram projetadas para serem usadas com o 
  operador pipe (`%>%`), que j√° vimos brevemente no relat√≥rio Junglivet
:::




::: {.callout-tip}
## O dplyr como uma "linha de produ√ß√£o"

Imagine o processo de an√°lise de dados como uma linha de produ√ß√£o:

- Os **dados brutos** s√£o sua "mat√©ria-prima"

- Cada fun√ß√£o do dplyr √© uma "esta√ß√£o de trabalho" que realiza 
  uma opera√ß√£o espec√≠fica:
  
  - `filter()` seleciona apenas os materiais que atendem a certos crit√©rios
  - `select()` separa apenas as partes que voc√™ precisa
  - `mutate()` transforma ou cria novos componentes
  - `group_by()` + `summarize()` agrupam e calculam estat√≠sticas
  - `arrange()` organiza o resultado final
  
- O operador pipe (`%>%`) √© a "esteira" que move os dados de uma esta√ß√£o 
para outra
:::



::: {.callout-note icon=false}
## Opera√ß√µes Comuns em An√°lise de Dados

- Muitas vezes precisamos **filtrar** somente certas linhas 
(**observa√ß√µes** ) de uma data frame. 

- Muitas vezes precisamos **selecionar** somente certas colunas 
(**vari√°veis**) de uma data frame.

- Muitas vezes precisamos **agrupar** os dados por uma determinada(s)
vari√°vel(s) categ√≥rica.

- Muitas vezes precisamos **calcular estat√≠sticas descritivas** para 
esses subconjuntos de dados (fun√ß√£o `summarize`). 
:::




### Por que usar o dplyr?

- **Exemplo 1:** Usando R base

```{r}
# pib per capita m√©dio dos pa√≠ses do continente americano
mean(gapminder$gdpPercap[gapminder$continent == "Americas"])
```

- **Exemplo 1:** Usando o pacote dplyr

```{r}
# pib per capita m√©dio dos pa√≠ses do continente americano
gapminder %>%
  filter(continent == "Americas") %>%
  summarize(mean(gdpPercap))
```



- **Exemplo 2:** R base (aninhado)

```{r}
#| eval: true

# Calcular a m√©dia de PIB per capita para 
# pa√≠ses asi√°ticos com popula√ß√£o > 50 milh√µes 
# em 2007
mean(gapminder$gdpPercap[
  gapminder$continent == "Asia" & 
  gapminder$pop > 50000000 & 
  gapminder$year == 2007
])
```

- Dif√≠cil de ler e entender
- Propenso a erros
- Dif√≠cil de modificar


- **Exemplo 2:** Com dplyr e o operador pipe

```{r}
#| eval: true

# O mesmo c√°lculo com dplyr
gapminder %>%
  filter(
    continent == "Asia",
    pop > 50000000,
    year == 2007
  ) %>%
  summarize(mean(gdpPercap))
```

- Leitura sequencial, mais natural
- Cada etapa claramente separada
- F√°cil de modificar ou expandir




### Comparando Abordagens

::: {.callout-note icon=false}
## Vantagens e Desvantagens

**Base R: Fun√ß√µes aninhadas**

- **Vantagens**: N√£o requer pacotes adicionais, dispon√≠vel em qualquer 
   instala√ß√£o do R
   
- **Desvantagens**: 

  - C√≥digo dif√≠cil de ler com fun√ß√µes aninhadas
  - Dif√≠cil de depurar quando h√° erros
  - Fun√ß√µes com sintaxes inconsistentes

**dplyr: Gram√°tica da manipula√ß√£o de dados**

- **Vantagens**:

  - C√≥digo mais leg√≠vel e expressivo
  - Fun√ß√µes com nomes intuitivos e consistentes
  - Ideal para an√°lises sequenciais com pipes
  
- **Desvantagens**:

  - Requer aprender uma nova sintaxe (para usu√°rios experientes)
  - Depend√™ncia de pacotes externos
  - Algumas opera√ß√µes podem ser mais lentas que o R base em casos espec√≠ficos
:::




### Fluxo de trabalho com tidyvese 

::: {.callout-note icon=false}
## Gram√°tica da manipula√ß√£o de dados

O fluxo t√≠pico de uma an√°lise de dados com tidyverse segue 
este padr√£o:

1. **Importar** dados (com pacotes here, readr, readxl,...)
2. **Organizar** dados para an√°lise (pacote tidyr)
3. **Unir** arquivos/tabelas se necess√°rio (fun√ß√µes para `joins`)
4. **Filtrar** observa√ß√µes (fun√ß√£o `filter`)
5. **Selecionar** vari√°veis (fun√ß√£o `select`)
6. **Transformar** dados (fun√ß√£o `mutate`)
7. **Agrupar** dados (fun√ß√£o `group_by`)
8. **Resumir** informa√ß√µes (fun√ß√£o `summarize`)
9. **Ordenar** resultados (fun√ß√£o `arrange`)
:::




### Um Pipeline de An√°lise com dplyr

::: {.callout-note icon=false}
## Informa√ß√µes sobre expectativa de vida por continente

```{r}
#| eval: true

# Um pipeline de an√°lise com dplyr
relatorio_expectativa <- gapminder %>%
  # Filtra apenas os dados de 2007
  filter(year == 2007) %>%
  # Agrupa por continente
  group_by(continent) %>%
  # Calcula estat√≠sticas resumidas
  summarize(
    expectativa_media = mean(lifeExp),
    expectativa_minima = min(lifeExp),
    expectativa_maxima = max(lifeExp),
    num_paises = n()
  ) %>%
  # Ordena do maior para o menor
  arrange(desc(expectativa_media))

# Visualiza o resultado final
relatorio_expectativa
```

Este exemplo demonstra como um conjunto de fun√ß√µes do dplyr pode 
ser combinado para transformar dados brutos **organizados** em um relat√≥rio 
informativo com apenas algumas linhas de c√≥digo.
:::



::: {.callout-note icon=false}
## **Pacote dplyr: Vantagens**

O pacote dplyr fornece uma s√©rie de fun√ß√µes muito √∫teis para 
manipular data frames de uma maneira que: 

- reduz a probabilidade de cometer erros 
- economiza digita√ß√£o 
- o c√≥digo √© mais leg√≠vel e compreens√≠vel
:::



::: {.callout-note icon=false}
## Objetivos de Aprendizagem

Vamos aprender 5 das fun√ß√µes mais usadas do pacote dplyr, 

::: {style="font-size: 90%;"}
| Fun√ß√£o              | Descri√ß√£o                                           |
|---------------------|-----------------------------------------------------|
| `dplyr::filter()`   | para filtrar linhas (observa√ß√µes)                   | 
| `dplyr::select()`   | para selecionar colunas (vari√°veis )                |
| `dplyr::mutate()`   | para criar novas vari√°veis                          |
| `dplyr::group_by()` | para opera√ß√µes "por grupo"                          |
| `dplyr::summarize()`| para calcular estat√≠sticas                          |
| `dplyr::arrange()`  | para ordenar resultados                             |
:::

Al√©m disso, veremos como como usar o operador pipe (`%>%`) para 
combin√°-las.
:::




### Boas Pr√°ticas com dplyr

::: {.callout-tip}
## Recomenda√ß√µes para c√≥digo eficiente e leg√≠vel

1. **Indenta√ß√£o consistente**: 

   - Um n√≠vel de identa√ß√£o para cada fun√ß√£o
   - Par√¢metros adicionais alinhados

2. **Nomeie seu c√≥digo**: 

   - Use nomes descritivos para vari√°veis intermedi√°rias e finais
   - Ex: `dados_filtrados`, `relatorio_vendas_por_regiao`

3. **Comente seu c√≥digo**:

   - Explique o "por qu√™", n√£o apenas o "o qu√™"
   - √ötil para voc√™ mesmo no futuro e para colegas

4. **Dividir an√°lises complexas em etapas**:

   - Para an√°lises muito complexas, divida em objetos intermedi√°rios
   - Facilita a depura√ß√£o e compreens√£o

5. **Consist√™ncia de estilo**:

   - Seja consistente com o estilo de nomea√ß√£o (snake_case ou CamelCase)
   - Seja consistente com o uso de aspas (simples ou duplas)
:::




### Pacote gapminder - Dados 

::: {.callout-note icon=false}
## Descri√ß√£o 

- O pacote gapminder da linguagem R cont√©m uma data frame tamb√©m chamada 
gapminder. 

- A df gapminder fornece informa√ß√µes detalhadas sobre indicadores 
socioecon√¥micos reais de v√°rios pa√≠ses ao longo do tempo. 

- Este conjunto de dados √© muito utilizado no ensino da linguagem R e 
de m√©todos estat√≠sticos.

- Vamos utilizar a df `gapminder` para ilustrar as fun√ß√µes do 
pacote dplyr.

- Para acessar os dados gapminder, basta instalar e carregar o 
pacote gapminder:

```{r}
# carrega os pacotes
library(tidyverse)
library(gapminder)
```
:::




### Data Frame gapminder

::: {.callout-note icon=false}
## Fase 1 (CRISP-DM): Entendimento dos Dados

Para obter uma vis√£o geral da estrutura da df gapminder, podemos usar 
a fun√ß√£o glimpse do pacote dplyr:

```{r}
# visualizando a estrutura dos dados
dplyr::glimpse(gapminder)
```

Podemos tamb√©m inspecionar as primeiras 6 linhas da data frame com a 
fun√ß√£o head:

```{r}
head(gapminder)
```

:::




### Boa Pr√°tica 

::: {.callout-note icon=false}
## Dicion√°rio dos dados

A data frame gapminder contida no pacote de mesmo nome, possui 
1704 linhas (observa√ß√µes) e 6 colunas (vari√°veis).

| Vari√°vel    | Classe/Tipo | Descri√ß√£o                                                      |
|-------------|-------------|----------------------------------------------------------------|
| `country`   | `factor`    | Nome do pa√≠s (142 n√≠veis/pa√≠ses)                                      |
| `continent` | `factor`    | Continente ao qual o pa√≠s pertence (5 n√≠veis/continentes)                  |
| `year`      | `integer`   | Ano da observa√ß√£o (1952 a 2007 em incrementos de 5 anos)       |
| `lifeExp`   | `double`    | Expectativa de vida ao nascer, em anos                         |
| `pop`       | `integer`   | Popula√ß√£o total do pa√≠s                                        |
| `gdpPercap` | `double`    | PIB per capita em US$, ajustado pela infla√ß√£o                  |
:::



## Fun√ß√£o select() 


### O que √© a fun√ß√£o select()?

::: {.callout-note icon=false}
## Selecionando vari√°veis (colunas) de uma data frame

- A fun√ß√£o `select()` permite escolher quais **vari√°veis** 
(colunas) voc√™ quer manter ou remover de uma data frame

- Enquanto `select()` trabalha com **colunas** (vari√°veis), 
`filter()` trabalha com **linhas** (observa√ß√µes), 
  
- √â essencial para simplificar seus dados, focando apenas nas vari√°veis relevantes para sua an√°lise
:::


![](img/select.jpeg){fig-align="center"}




### Sintaxe da fun√ß√£o select()

::: {.callout-tip}
## Sintaxe b√°sica

```{r}
#| eval: false

# Estrutura b√°sica
select(df, var1, var2, var3)

# Com operador pipe
df %>% select(var1, var2, var3)
```

- **df**: A data frame da qual voc√™ quer selecionar vari√°veis
- **var1, var2, var3**: Nomes das vari√°veis que voc√™ quer manter
- Todas as vari√°veis n√£o listadas ser√£o removidas do resultado
:::




### Exemplo: An√°lise Financeira Simplificada

::: {.callout-note icon=false}
## Cen√°rio: An√°lise financeira de pa√≠ses

Imagine que voc√™ √© um analista financeiro internacional e precisa 
preparar um relat√≥rio sobre PIB:

```{r}
# Seleciona apenas as vari√°veis relevantes para an√°lise financeira
dados_financeiros <- gapminder %>%
  select(country, year, gdpPercap)

# Visualiza as primeiras linhas do resultado
head(dados_financeiros)
```

**Interpreta√ß√£o:** Este c√≥digo seria equivalente a extrair apenas os 
dados financeiros relevantes (pa√≠s, ano e PIB per capita) de uma 
grande base de dados para uma an√°lise espec√≠fica de desempenho 
econ√¥mico.
:::




### T√©cnicas de Sele√ß√£o Avan√ßadas

::: {.callout-note icon=false}
## Diversas formas de selecionar vari√°veis

```{r}
#| eval: false

# Selecionar vari√°veis por inclus√£o
gapminder %>% select(country, year, gdpPercap)

# Selecionar vari√°veis por exclus√£o (com sinal de menos)
gapminder %>% select(-continent, -lifeExp)

# Selecionar vari√°veis em sequ√™ncia
gapminder %>% select(country:pop)

# Selecionar vari√°veis que come√ßam com determinado texto
gapminder %>% select(starts_with("c"))

# Selecionar vari√°veis que terminam com determinado texto
gapminder %>% select(ends_with("p"))

# Selecionar vari√°veis que cont√™m determinado texto
gapminder %>% select(contains("exp"))
```
:::



::: {.callout-tip}
## Aplica√ß√µes pr√°ticas em neg√≥cios

Estas t√©cnicas s√£o muito √∫teis quando voc√™ trabalha com:

- Grandes conjuntos de dados com dezenas ou centenas de vari√°veis
- Planilhas de dados financeiros onde precisa focar em determinadas m√©tricas
- Relat√≥rios onde precisa apresentar apenas informa√ß√µes espec√≠ficas
:::




### Erros Comuns e Como Evit√°-los


::: {.callout-caution}
## Os erros mais comuns com select()

| Erro | Errado | Correto |
|------|-------------------|-----------------|
| Nomes de vari√°veis com aspas | `select(gapminder, "country")` | `select(gapminder, country)` |
| Tentar condi√ß√µes como em filter | `select(gapminder, gdpPercap > 1000)` | Use `filter()` para isso, n√£o `select()` |
| N√£o salvar o resultado | `gapminder %>% select(country, year)` | `dados_novos <- gapminder %>% select(country, year)` |
| Remover vari√°veis necess√°rias | `select(country)` e depois tentar usar `continent` | Verifique se manteve todas as vari√°veis necess√°rias |
:::


::: {.callout-tip}
## Dica importante:

Lembre-se: `select()` √© para escolher **colunas (vari√°veis)** e `filter()` √© para escolher **linhas (observa√ß√µes)**!
:::




### Exemplo: Salvando o resultado

::: {.callout-note icon=false}
## Sele√ß√£o por Exclus√£o

- Se quisermos remover apenas a vari√°vel **continent**, podemos usar 
a sint√°xe abaixo e salvar o resultado em outro objeto:

```{r}
variaveis_selecionadas <- select(gapminder, -continent)
variaveis_selecionadas
```
:::




### Pacote dplyr e o operador pipe ( `|>` ou `%>%`)

::: {.callout-note icon=false}
## Combina√ß√£o de Opera√ß√µes com `|>` ou `%>%`

- Nos slides anteriores, usamos a sint√°xe 'normal' da linguagem R. 

- Mas o ponto forte do dplyr est√° na **combina√ß√£o** de v√°rias fun√ß√µes 
usando o **operador pipe** `%>%`. 

- Vamos analisar a gram√°tica do uso de fun√ß√µes do dplyr combinadas 
com o operador `%>%`. 

- Atalho para inserir o operador pipe: **Ctrl + shift + M**
:::



::: {.callout-note icon=false}
## Significado conceitual do pipe %>%

- O operador pipe pode ser lido como "ent√£o" ou "em seguida"

- Fluxo da esquerda para a direita, similar √† leitura natural

- Transforma: 

`funcao(dados, arg1, arg2)` 

em 

`dados %>% funcao(arg1, arg2)`

:::



::: {.callout-note icon=false}
## Analogia

Uma linha de montagem onde cada fun√ß√£o faz uma opera√ß√£o nos dados

```{r}
#| eval: true
#| code-line-numbers: "1|2|3|4-7"

gapminder %>% # Pegue os dados gapminder, ent√£o...
  filter(year == 2007) %>% # Filtre para apenas o ano 2007, ent√£o...
  group_by(continent) %>% # Agrupe por continente, ent√£o...
  summarize( # Calcule resumos:
    mean(lifeExp), # expectativa de vida m√©dia
    sum(pop) # popula√ß√£o total 
  )
```
:::




::: {.callout-tip}
## Nomeie os resumos calculados com summarize

```{r}
#| eval: true
#| 
#| code-line-numbers: "4-7"
gapminder %>% # Pegue os dados gapminder, ent√£o...
  filter(year == 2007) %>% # Filtre para apenas o ano 2007, ent√£o...
  group_by(continent) %>% # Agrupe por continente, ent√£o...
  summarize( # Calcule resumos:
    exp_vida_media = mean(lifeExp), # expectativa de vida m√©dia
    populacao_total = sum(pop) # popula√ß√£o total
  )
```
:::




### Fun√ß√£o select() e o Operador Pipe


::: {.callout-tip}
## Selecionando Vari√°veis com o Pipe

```{r}
variaveis_selecionadas <- gapminder %>%
  dplyr::select(year, country, gdpPercap)
```

Vamos entender o c√≥digo:

1. Primeiro invocamos a df gapminder e a passamos, usando o operador
pipe `%>%`, para a pr√≥xima etapa, que √© a fun√ß√£o select(). 

2. Neste caso, n√£o especificamos qual df usamos na 
fun√ß√£o select(), porque que ela obt√©m essa informa√ß√£o do pipe 
anterior. 

3. Salvamos o resultado no objeto `variaveis_selecionadas`
:::




### Resumo: Fun√ß√£o select() 

::: {.callout-tip}
## O que voc√™ precisa lembrar

1. **Para que serve:** Selecionar apenas as colunas (vari√°veis) que voc√™ deseja manter ou remover

2. **Sintaxe b√°sica:** 

```{r}
#| eval: false
dados %>% select(var1, var2, var3)  # Mant√©m apenas var1, var2 e var3
dados %>% select(-var4, -var5)      # Remove var4 e var5, mant√©m o resto
```

3. **T√©cnicas √∫teis:**
   - Sele√ß√£o por inclus√£o: `select(pa√≠s, ano, vendas)`
   - Sele√ß√£o po exclus√£o: `select(-observa√ß√µes, -notas)`
   - Sele√ß√£o por padr√£o de texto: `select(starts_with("venda"))`

4. **Lembre-se sempre:**
   - `select()` trabalha com COLUNAS
   - `filter()` trabalha com LINHAS
   - Sempre salve o resultado em um novo objeto!

```{r}
#| eval: false
novo_df <- dados %>% select(...)
```
:::






## Fun√ß√£o filter() 


### O que √© a fun√ß√£o filter()?

::: {.callout-note icon=false}
## Filtrando observa√ß√µes (linhas) de uma data frame

- A fun√ß√£o `filter()` permite **filtrar subconjuntos de observa√ß√µes** 
(linhas) que atendem determinadas condi√ß√µes ou crit√©rios.

- √â uma das fun√ß√µes mais utilizadas na an√°lise de dados para criar 
  subconjuntos espec√≠ficos dos dados
  
- Pense nela como um "filtro" que deixa passar apenas as observa√ß√µes 
  que atendem aos crit√©rios que voc√™ definir
:::


![Neste caso, duas linhas atendem √†s condi√ß√µes](img/filter.jpeg){fig-align="center"}




### O que √© a fun√ß√£o filter()?

::: {.callout-note icon=false}
## Filtrando observa√ß√µes (linhas) de uma data frame

- Imagine que voc√™ tem uma planilha de vendas e quer analisar apenas 
as vendas:

  - de um produto espec√≠fico
  - acima de determinado valor
  - em uma regi√£o espec√≠fica
  - em um per√≠odo espec√≠fico

- A fun√ß√£o `filter()` permite fazer essa filtragem de forma r√°pida e precisa
:::




### Sintaxe da fun√ß√£o filter()

::: {.callout-tip}
## Sintaxe b√°sica

```{r}
#| eval: false

# Estrutura b√°sica
filter(df, condi√ß√£o)

# Com operador pipe
df %>% filter(condi√ß√£o)
```

- **df**: A data frame a ser filtrada
- **condi√ß√£o**: Express√£o l√≥gica que retorna TRUE/FALSE para cada linha
- Somente as linhas que resultam em TRUE s√£o mantidas no resultado
:::




### Operadores para construir condi√ß√µes

::: {.callout-tip}
## Operadores na linguagem dos neg√≥cios

| Operador | Exemplo em Linguagem Natural | C√≥digo em R |
|----------|--------------------------|----------|
| ==  | Apenas os pa√≠ses europeus | continent == "Europe" |
| != | Todos, exceto os pa√≠ses europeus | continent != "Europe" |
| > | Pa√≠ses com PIB per capita maior que 10.000 | gdpPercap > 10000 |
| < | Pa√≠ses com menos de 1 milh√£o de habitantes | pop < 1000000 |
| >= | Pa√≠ses a partir do ano 2000 | year >= 2000 |
| &  | Pa√≠ses europeus a partir de 2000 | continent == "Europe" & year >= 2000 |
| `|` | Pa√≠ses da Europa ou da √Åsia | continent == "Europe" &#124; continent == "Asia"</code> |

:::


::: {.callout-tip}
## Dicas

- Use `==` para igualdade (lembre-se: dois sinais de igual, n√£o apenas um)
- Use `&` para "E" (quero este crit√©rio **E** aquele tamb√©m)
- Use `|` para "OU" (quero este crit√©rio **OU** aquele)
:::




### Exemplo b√°sico

::: {.callout-note icon=false}
## Cen√°rio: An√°lise de vendas por continente

Imagine que a data frame `gapminder` representa dados de filiais de uma 
empresa multinacional:

```{r}
# Filtra apenas pa√≠ses das Am√©ricas
# como se fossem filiais da regi√£o Am√©ricas

filiais_americas <- gapminder %>%
  filter(continent == "Americas")

# Visualiza as primeiras 6 linhas do resultado
head(filiais_americas)
```

**Interpreta√ß√£o:** Este filtro seria equivalente a selecionar 
apenas dados de filiais localizadas nas Am√©ricas para uma an√°lise 
regional de desempenho.
:::




### Pensando como um Analista de Neg√≥cios

::: {.callout-note icon=false}
## Perguntas de neg√≥cios traduzidas para filter()

| Pergunta de Neg√≥cio | C√≥digo com filter() |
|---------------------|---------------------|
| Quais pa√≠ses tiveram PIB per capita acima de $20.000 em 2007? | `filter(year == 2007 & gdpPercap > 20000)` |
| Quais pa√≠ses da √Åsia tiveram expectativa de vida acima de 75 anos? | `filter(continent == "Asia" & lifeExp > 75)` |
| Quais pa√≠ses tiveram popula√ß√£o superior a 100 milh√µes em 2007? | `filter(year == 2007 & pop > 100000000)` |
| Quais pa√≠ses n√£o s√£o da Europa nem da Am√©rica? | `filter(continent != "Europe" & continent != "Americas")` |


**Dica:** Comece sempre pensando na pergunta de neg√≥cio, depois 
traduza para o c√≥digo
:::




### M√∫ltiplas condi√ß√µes com filter()

::: {.callout-note icon=false}
## Combinando condi√ß√µes

H√° duas maneiras principais de combinar condi√ß√µes:

```{r}
#| echo: true
#| eval: false

# M√©todo 1: Usando o operador & (E l√≥gico) - equivalente ao m√©todo 1
europeus_2007_alt <- gapminder %>%
  filter(continent == "Europe" & year == 2007)

# M√©todo 2: Usando o operador | (OU l√≥gico)
europa_ou_asia <- gapminder %>%
  filter(continent == "Europe" | continent == "Asia")
```

Dica importante:

- Com `&` ("E") ambas as condi√ß√µes precisam ser `TRUE` para que
a linha seja mantida

- Com `|` ("OU"), apenas uma das condi√ß√µes precisa ser `TRUE`
:::




### Filtrando com operadores relacionais

::: {.callout-note icon=false}
## Exemplos com diferentes operadores

```{r}
#| eval: true

# Pa√≠ses com alta expectativa de vida (maior que 80 anos)
alta_exp_vida <- gapminder %>%
  filter(lifeExp > 80)

# Pa√≠ses com PIB per capita abaixo de 500 d√≥lares
baixo_pib <- gapminder %>%
  filter(gdpPercap < 500)

# Anos diferentes de 2002
nao_2002 <- gapminder %>%
  filter(year != 2002)
```

Utilize operadores relacionais para:

- Encontrar valores acima/abaixo de limites importantes
- Excluir per√≠odos ou categorias espec√≠ficas
- Identificar casos extremos ou outliers
:::




### Combinando filter() com outras fun√ß√µes

::: {.callout-note icon=false}
## A import√¢ncia da ordem das opera√ß√µes

```{r}
#| eval: true

# Pa√≠ses europeus em 2007, mostrando apenas pa√≠s e expectativa de vida
europeus_lifeExp_2007 <- gapminder %>%
  filter(continent == "Europe" & year == 2007) %>%
  select(country, lifeExp)

# Ordenando o resultado por expectativa de vida (decrescente)
europeus_lifeExp_2007_ordenado <- gapminder %>%
  filter(continent == "Europe" & year == 2007) %>%
  select(country, lifeExp) %>%
  arrange(desc(lifeExp))

head(europeus_lifeExp_2007_ordenado)
```

**Ordem correta** das opera√ß√µes:

1. Comece com **filter()** 
2. Use **select()** depois de filter
3. Se inverter a ordem, a fun√ß√£o filter() pode falhar se voc√™ removeu 
colunas necess√°rias

Lembre-se: primeiro **filter()**, depois **select()**!
:::




### Erros Comuns e Como Evit√°-los

::: {.callout-caution}
## Os 4 erros mais comuns com filter()

| Erro | Errado | Correto |
|------|-------------------|-----------------|
| Usar = em vez de == | `filter(continent = "Europe")` | `filter(continent == "Europe")` |
| Esquecer as aspas em nomes | `filter(continent == Europe)` | `filter(continent == "Europe")` |
| N√£o salvar o resultado | `gapminder %>% filter(year == 2007)` | `dados_2007 <- gapminder %>% filter(year == 2007)` |
:::




### Exemplo Completo Comum

::: {.callout-note icon=false}
## Pa√≠ses europeus com alta expectativa de vida em 2007?

```{r}
#| eval: true

# Pa√≠ses europeus com expectativa de vida acima de 78 anos em 2007
resultado_final <- gapminder %>%
  # Filtrar por continente, ano e expectativa de vida
  filter(continent == "Europe" & year == 2007 & lifeExp > 78) %>%
  # Selecionar vari√°veis de interesse
  select(country, lifeExp, gdpPercap) %>%
  # Ordenar por expectativa de vida (decrescente)
  arrange(desc(lifeExp))

# Mostrar resultados
resultado_final
```

Observe o fluxo de an√°lise:

1. Filtramos os dados com crit√©rios espec√≠ficos
2. Selecionamos apenas as vari√°veis de interesse
3. Ordenamos os resultados para facilitar a interpreta√ß√£o
4. Todo o processo forma um "pipeline" de an√°lise limpo e leg√≠vel
:::




### Resumo: Fun√ß√£o filter() 

::: {.callout-tip}
## O que voc√™ precisa lembrar

1. **Para que serve:** Selecionar apenas as linhas (observa√ß√µes) 
que atendem a determinadas condi√ß√µes

2. **Sintaxe b√°sica:** 

```{r}
#| eval: false

dados %>% filter(condi√ß√£o1, condi√ß√£o2, ...)
```

3. **Compara√ß√µes mais usadas:**

   - Igual: == (dois sinais de igual!)
   - Diferente: !=
   - Maior/Menor: >, <, >=, <=

4. **M√∫ltiplas condi√ß√µes:**
   - Todas as condi√ß√µes (E): `filter(condi√ß√£o1 & condi√ß√£o2)`
   - Qualquer condi√ß√£o (OU): `filter(condi√ß√£o1 | condi√ß√£o2)`

5. **Lembre-se sempre de salvar o resultado:**

```{r}
#| eval: false

nova_df <- dados %>% filter(...)
```
:::




## Fun√ß√£o mutate() 


::: {.callout-note icon=false}
## O que √© a fun√ß√£o mutate()?

- A fun√ß√£o `mutate()` permite **criar novas vari√°veis** ou 
  **modificar vari√°veis existentes**

- Enquanto `filter()` seleciona linhas e `select()` seleciona colunas, 
  `mutate()` **adiciona ou modifica colunas**

- √â como ter uma "calculadora" que cria novas informa√ß√µes a partir dos 
  dados existentes

- Ideal para c√°lculos como: percentuais, totais, m√©dias, categorias, etc.
:::


![Cria novas vari√°veis a partir das vari√°veis existentes](img/mutate.jpeg){fig-align="center"}



::: {.callout-tip}
## Sintaxe da fun√ß√£o mutate()

```{r style="font-size: 1em;"}
#| eval: false

# Formato b√°sico
dados %>% mutate(nova_coluna = express√£o)

# Exemplos pr√°ticos
dados %>% mutate(valor_total = preco * quantidade)
dados %>% mutate(valor_com_desconto = preco * 0.9)
```

**O que cada parte significa:**

- **nova_coluna**: Nome da nova vari√°vel que voc√™ est√° criando
- **express√£o**: F√≥rmula que calcula os valores da nova vari√°vel
- A express√£o √© aplicada a cada linha individualmente
:::



::: {.callout-note icon=false}
## Aplica√ß√£o: An√°lise de Vendas

Imagine que a data frame `gapminder` cont√©m dados de vendas 
globais da sua empresa:

```{r style="font-size: 1em;"}
#| eval: false

# Criando vari√°veis para an√°lise de vendas
vendas_analise <- gapminder %>%
  filter(year == 2007) %>%  # Filtra dados somente de 2007
  mutate(
    # PIB total representa a receita total da regi√£o
    receita_total = gdpPercap * pop,
    # Receita em milh√µes (para facilitar a leitura)
    receita_milhoes = receita_total / 1000000,
    # Indicador de destaque (regi√µes com alta receita por pessoa)
    destaque = gdpPercap > 20000
  ) %>%
  # Vamos visualizar apenas algumas colunas e 5 linhas
  select(country, receita_milhoes, gdpPercap, destaque) %>%
  head(5)

vendas_analise
```

**Interpreta√ß√£o administrativa:** Este tipo de transforma√ß√£o √© usado 
diariamente nas empresas para converter dados brutos em m√©tricas de 
neg√≥cios √∫teis para tomada de decis√£o.
:::



::: {.callout-note icon=false}
## Transforma√ß√µes mais comuns: Opera√ß√µes aritm√©ticas b√°sicas

```{r style="font-size: 1em;"}
#| eval: false
# Opera√ß√µes aritm√©ticas b√°sicas com mutate()
gapminder %>%
  filter(country == "Brazil", year >= 2000) %>%
  mutate(
    # Adi√ß√£o: adiciona um valor fixo
    pop_ajustada = pop + 1000000,
    # Multiplica√ß√£o: multiplica por um fator
    gdp_reais = gdpPercap * 5.2,  # Convertendo para reais
    # Divis√£o: divide para mudar a escala 
    pop_milhoes = pop / 1000000   # Popula√ß√£o em milh√µes
  ) %>%
  select(year, pop, pop_ajustada, pop_milhoes, gdpPercap, gdp_reais)
```

**Dica:** As opera√ß√µes mais utilizadas em an√°lises de neg√≥cios s√£o 
multiplica√ß√£o (para fatores, taxas, convers√µes) e divis√£o (para mudar 
escalas e calcular propor√ß√µes).
:::




### Criando categorias com ifelse()

::: {.callout-note icon=false}
## O que √© a fun√ß√£o ifelse()?

A fun√ß√£o `ifelse()` permite criar novas vari√°veis categ√≥ricas baseadas 
em condi√ß√µes:

**Como funciona:** `ifelse(condi√ß√£o, valor_se_verdadeiro, valor_se_falso)`

```{r style="font-size: 1em;"}
#| eval: false
# Criando categorias com ifelse
paises_categorizados <- gapminder %>%
  filter(year == 2007) %>%
  mutate(
    nivel_desenvolvimento = ifelse(gdpPercap > 10000, 
                                   "Desenvolvimento Alto", 
                                   "Desenvolvimento Baixo")
  ) %>%
  select(country, gdpPercap, nivel_desenvolvimento) %>%
  head(6)

paises_categorizados
```

- √â como dizer: "SE o PIB per capita for maior que 10.000, ent√£o 
classifique como 'Desenvolvimento Alto', SEN√ÉO classifique como 
'Desenvolvimento Baixo'"
:::



::: {.callout-note icon=false}
## Criando KPIs com mutate() e ifelse() 

```{r style="font-size: 1em;"}
#| eval: false
gapminder %>%
 filter(year == 2007) %>%
 mutate(
   pib_total = gdpPercap * pop,  # PIB total
   pib_percentual_global = (pib_total/sum(pib_total))*100, # % do PIB global
   performance = ifelse(gdpPercap > mean(gdpPercap), 
                       "Acima da m√©dia", 
                       "Abaixo da m√©dia")
 ) %>% 
 select(country, pib_total, pib_percentual_global, performance)
```

Isso mostra como transformar dados brutos em informa√ß√µes gerenciais.
:::




### Criando M√∫ltiplas Categorias com case_when()

::: {.callout-note icon=false}
## Quando precisamos de mais de duas categorias

`case_when()` √© como um "sistema de classifica√ß√£o" para criar 
categorias mais complexas:

```{r style="font-size: 1em;"}
#| eval: false

# Exemplo de m√∫ltiplas categorias
paises_classificados <- gapminder %>%
  filter(year == 2007) %>%
  mutate(
    classe_desenvolvimento = case_when(
      gdpPercap < 2000 ~ "Baixo",
      gdpPercap < 10000 ~ "M√©dio",
      gdpPercap >= 10000 ~ "Alto"
    )
  ) %>%
  select(country, gdpPercap, classe_desenvolvimento) %>%
  head(6)

paises_classificados
```

**Como funciona:**

- Cada linha representa uma condi√ß√£o: `condi√ß√£o ~ "valor a atribuir"`
- As condi√ß√µes s√£o verificadas em ordem (de cima para baixo)
- Quando uma condi√ß√£o √© verdadeira, o valor correspondente √© atribu√≠do
:::



::: {.callout-tip}
## Quando usar ifelse() vs. case_when()?

| Fun√ß√£o | Quando usar | Exemplo |
|--------|-------------|---------|
| `ifelse()` | Para divis√µes simples em duas categorias | `ifelse(vendas > meta, "Meta atingida", "Meta n√£o atingida")` |
| `case_when()` | Para m√∫ltiplas categorias ou condi√ß√µes complexas | Classificar clientes em "Bronze", "Prata", "Ouro" e "Platina" baseado em diferentes crit√©rios |

**Analogia de neg√≥cios:**

- `ifelse()` √© como uma decis√£o "sim/n√£o" (aprova√ß√£o de cr√©dito simples)

- `case_when()` √© como um sistema de classifica√ß√£o de clientes com 
v√°rias categorias
:::





### Erros Comuns e Como Evit√°-los

::: {.callout-caution}
## Os erros que todos cometem no in√≠cio

1. **Usar o operador de atribui√ß√£o errado**

   - ERRADO: `mutate(nova_var <- express√£o)` ‚ùå 
   - CORRETO: `mutate(nova_var = express√£o)` ‚úÖ

2. **Esquecer de salvar o resultado**

   - ERRADO: `dados %>% mutate(nova_var = x * 2)` ‚ùå (resultado n√£o salvo)
   - CORRETO: `dados_novos <- dados %>% mutate(nova_var = x * 2)` ‚úÖ

3. **Tentar usar vari√°veis que acabou de criar sem manter os resultados**

ERRADO: 

```{r style="font-size: 1.2em;"}
#| eval: false
# Executando dois comandos separados:
dados %>% mutate(nova_var = x * 2)  # Resultado n√£o salvo em lugar nenhum
dados %>% filter(nova_var > 10)     # ‚ùå Erro! nova_var n√£o existe em 'dados'
```

CORRETO (Pipeline √∫nico):

```{r style="font-size: 1.2em;"}
#| eval: false
dados_novos <- dados %>%
  mutate(nova_var = x * 2) %>%
  filter(nova_var > 10) # ‚úÖ Funciona porque tudo est√° no mesmo pipeline
```
:::




### Resumo: Fun√ß√£o mutate()

::: {.callout-tip}
## O que voc√™ precisa lembrar

1. **O que faz:** `mutate()` cria novas vari√°veis ou modifica existentes
   
2. **Usos comuns no mundo dos neg√≥cios:**

   - Calcular totais, m√©dias, porcentagens
   - Converter unidades (d√≥lares para reais, unidades para milhares)
   - Criar categorias e classifica√ß√µes

3. **Como usar na pr√°tica:**

```{r style="font-size: 1em;"}
#| eval: false
dados %>% mutate(nova_variavel = express√£o)
```

4. **Ferramentas complementares:**

   - `ifelse()` para classifica√ß√µes simples (sim/n√£o)
   - `case_when()` para classifica√ß√µes m√∫ltiplas

5. **Lembre-se de salvar o resultado em um novo objeto:**

```{r style="font-size: 1em;"}
#| eval: false
novo_df <- dados %>% mutate(...)
```
:::





## Fun√ß√µes group_by() + summarize() 

::: {.callout-note icon=false}
## O que s√£o as fun√ß√µes group_by() e summarize()?

- A fun√ß√£o `group_by()` permite **agrupar dados** por uma ou mais 
vari√°veis categ√≥ricas
  
- A fun√ß√£o `summarize()` (ou `summarise()`) permite **calcular 
estat√≠sticas resumidas** para cada grupo

- Estas fun√ß√µes geralmente trabalham juntas como uma ferramenta 
poderosa para an√°lise

- √â como criar "subtotais" ou "relat√≥rios consolidados" por 
categorias (ex: vendas por regi√£o, despesas por departamento)
:::


![Fun√ß√µes group_by() e summarize()?](img/groupby.jpeg){fig-align="center" width="40%"}



::: {.callout-tip}
## Sintaxe das fun√ß√µes group_by() e summarize()

```{r style="font-size: 1em;"}
#| eval: false

# Estrutura b√°sica
df %>% 
  group_by(variavel_de_agrupamento) %>%
  summarize(nome_do_resumo = funcao(variavel))

# Exemplo pr√°tico
df %>%
  group_by(departamento) %>%
  summarize(media_vendas = mean(vendas))
```

- **df**: A data frame que cont√©m os dados
- **variavel_de_agrupamento**: Vari√°vel **categ√≥rica** pela qual agrupar 
   (ex: regi√£o, produto)
- **nome_do_resumo**: Nome que voc√™ escolhe para o resultado calculado
- **funcao**: Fun√ß√£o estat√≠stica (ex: mean, sum, max, min, sd, n)
- **variavel**: Vari√°vel para calcular a estat√≠stica
:::




::: {.callout-note icon=false}
## Exemplo: An√°lise Financeira por Continente

Imagine que voc√™ √© um analista financeiro e precisa preparar 
um relat√≥rio executivo comparando regi√µes:

```{r}
# Cria um relat√≥rio de PIB m√©dio por continente
relatorio_continentes <- gapminder %>%
  filter(year == 2007) %>%  # Filtra para dados mais recentes
  group_by(continent) %>%   # Agrupa por continente
  summarize(
    PIB_medio = mean(gdpPercap),         # M√©dia do PIB per capita
    Total_populacao = sum(pop),          # Popula√ß√£o total
    Paises_analisados = n(),             # N√∫mero de pa√≠ses
    PIB_minimo = min(gdpPercap),         # PIB m√≠nimo
    PIB_maximo = max(gdpPercap)          # PIB m√°ximo
  ) %>%
  arrange(desc(PIB_medio))  # Ordena do maior para o menor PIB m√©dio

# Visualiza o resultado
relatorio_continentes
```

**Interpreta√ß√£o** Este tipo de relat√≥rio consolidado por 
regi√£o √© cr√≠tico para an√°lises comparativas entre mercados e para 
apresenta√ß√µes executivas. Mostra claramente as estat√≠sticas-chave 
para cada grupo (continente), facilitando compara√ß√µes e decis√µes 
estrat√©gicas.
:::



::: {.callout-tip}
## Fun√ß√µes Estat√≠sticas Mais Usadas com summarize()

| Fun√ß√£o | O que calcula | Exemplo em R | Uso em Neg√≥cios |
|--------|---------------|-------------|-----------------|
| `mean()`| M√©dia | `mean(vendas)` | Valor m√©dio de vendas por regi√£o |
| `sum()` | Soma total | `sum(receita)` | Receita total por categoria |
| `min()` | Valor m√≠nimo | `min(preco)` | Menor pre√ßo praticado |
| `max()` | Valor m√°ximo | `max(despesa)` | Maior despesa do per√≠odo |
| `sd()` | Desvio padr√£o | `sd(producao)` | Variabilidade da produ√ß√£o |
| `n()` | Contagem de linhas | `n()` | N√∫mero de transa√ß√µes |
| `n_distinct()`| Contagem de valores √∫nicos | `n_distinct(cliente)` | N√∫mero de clientes √∫nicos |
| `median()` | Mediana | `median(vendas)` | Valor t√≠pico de vendas |

**Dica para gestores:** Sempre inclua tanto medidas de "tend√™ncia central" 
(m√©dia, mediana) quanto de "varia√ß√£o" (desvio padr√£o) para ter uma 
vis√£o mais completa dos dados.
:::




### Agrupando por M√∫ltiplas Vari√°veis

::: {.callout-note icon=false}
## An√°lises mais detalhadas

```{r style="font-size: 1em;"}
# An√°lise de expectativa de vida por continente e ano
tendencias_por_continente <- gapminder %>%
  group_by(continent, year) %>%  # Agrupa por DUAS vari√°veis
  summarize(
    expectativa_vida_media = mean(lifeExp),
    paises_analisados = n()
  ) %>%
  arrange(continent, year)

# Mostra resultados parciais
tendencias_por_continente %>% 
  filter(continent == "Americas") %>%
  head(3)
```

**Contexto empresarial:** Este tipo de an√°lise √© comum em:

- Relat√≥rios de vendas por regi√£o e trimestre
- An√°lise de desempenho por departamento e m√™s
- Monitoramento de m√©tricas por produto e canal de vendas
:::




### Erros Comuns e Como Evit√°-los

::: {.callout-caution}
## Os erros que todos cometem no in√≠cio

| Erro | Errado | Correto |
|------|-------------------|-----------------|
| N√£o usar summarize ap√≥s group_by | `dados %>% group_by(regiao)` | `dados %>% group_by(regiao) %>% summarize(...)` |
| Tentar agrupar antes de filtrar | `group_by(regiao) %>% filter(mean(vendas) > 1000)` | Usar `filter()` ANTES de `group_by()` |
| Esquecer de desagrupar | Continuar usando dados agrupados | Usar `ungroup()` quando terminar com an√°lises agrupadas |

**Dica:** `group_by` por si n√£o produz nenhum resultado.
:::




### Resumo: Fun√ß√µes group_by() e summarize()

::: {.callout-tip}
## O que voc√™ precisa lembrar

1. **Para que servem:**

   - `group_by()`: Agrupa dados por categorias (como agrupar linhas em 
     uma planilha)
     
   - `summarize()`: Calcula estat√≠sticas para cada grupo 
      (como criar subtotais)

2. **Sintaxe b√°sica:**

```{r}
#| eval: false

dados %>% 
  group_by(categoria) %>%
  summarize(resumo = funcao(variavel))
```

3. **Fun√ß√µes estat√≠sticas b√°sicas:**

   - Para totais: `sum()`
   - Para m√©dias: `mean()`
   - Para contagens: `n()`
   - Para m√≠nimos/m√°ximos: `min()`, `max()`

4. **Fluxo de trabalho t√≠pico:**

   - Primeiro filtre os dados (`filter()`)
   - Depois agrupe (`group_by()`)
   - Em seguida calcule estat√≠sticas (`summarize()`)
   - Por fim, ordene os resultados (`arrange()`)

5. **Lembre-se sempre de salvar o resultado:**

```{r}
#| eval: false

relatorio_final <- dados %>% group_by(...) %>% summarize(...)
```
:::




## Fun√ß√£o arrange()

::: {.callout-note icon=false}
## Descri√ß√£o

- A fun√ß√£o `arrange()` ordena as linhas (observa√ß√µes) de uma data frame 
com base nos valores de uma ou mais colunas (vari√°veis)
   
- Por padr√£o, organiza em ordem **crescente** (do menor para o maior)

- Use `desc()` para ordenar em ordem decrescente (do maior para o menor)
:::


![Reordena as linhas de uma data frame segundo uma vari√°vel, por padr√£o em ordem crescente, com desc() em ordem decrescente](img/arrange.jpeg){fig-align="center"}



::: {.callout-tip}
## Sintaxe da fun√ß√£o arrange()

```{r}
#| eval: false

# Formato b√°sico
df %>% arrange(variavel)         # ordem crescente
df %>% arrange(desc(variavel))   # ordem decrescente

# Ordenar por m√∫ltiplas vari√°veis
dados %>% arrange(var1, var2)       # Ordenar primeiro por var1, depois var2
```

- **df**: A data frame que cont√©m os dados
- **variavel**: Nome da coluna pela qual voc√™ quer ordenar as observa√ß√µes
- Use `desc()` para ordem descrescente (do maior para o menor)
- Quando ordenando por m√∫ltiplas vari√°veis, a primeira tem prioridade
:::



::: {.callout-note icon=false}
## Aplica√ß√£o: An√°lise de Desempenho

Imagine que voc√™ √© um analista de mercado e precisa identificar 
rapidamente os pa√≠ses mais promissores para expans√£o:

```{r}
# Criando um ranking de pa√≠ses por PIB per capita em 2007
ranking_paises <- gapminder %>%
  filter(year == 2007) %>%                # Filtra dados apenas de 2007
  select(country, continent, gdpPercap) %>% # Seleciona colunas relevantes
  arrange(desc(gdpPercap)) %>%            # Ordena do maior para o menor PIB
  head(6)                                # Mostra os 10 primeiros resultados

# Visualiza o resultado
ranking_paises
```

**Interpreta√ß√£o** Este tipo de ordena√ß√£o √© relevante em 
an√°lises de mercado para identificar rapidamente os pa√≠ses mais ricos 
(potenciais mercados premium) ou para encontrar as regi√µes que precisam 
de mais aten√ß√£o (ordenando do menor para o maior).
:::




### Erros Comuns e Como Evit√°-los

::: {.callout-caution}
## Cuidados ao usar arrange()

| Erro | Problema | Solu√ß√£o |
|------|----------|---------|
| Ordem incorreta | `arrange(dados, desc())` sem especificar a vari√°vel | `arrange(dados, desc(variavel))` |
| Tentar ordenar por vari√°vel n√£o existente | `arrange(vendas_por_regiao)` quando a coluna n√£o existe | Verificar primeiro os nomes das colunas com `names()` |
| N√£o salvar o resultado ordenado | Ordenar mas n√£o atribuir a um objeto | `dados_ordenados <- dados %>% arrange(...)` |

**Lembre-se:** A ordena√ß√£o √© tempor√°ria se voc√™ n√£o salvar o resultado 
em um novo objeto!
:::




### Resumo: Fun√ß√£o arrange()

::: {.callout-tip}
## O que voc√™ precisa lembrar

1. **Para que serve:** Ordenar as linhas (observa√ß√µes) com base nos 
valores de uma ou mais colunas

2. **Sintaxe b√°sica:** 

```{r style="font-size: 1em;"}
#| eval: false
dados %>% arrange(variavel)         # ordem crescente 
dados %>% arrange(desc(variavel))   # ordem decrescente 
```

3. **Usos comuns em neg√≥cios:**

   - Criar rankings de vendedores, produtos ou regi√µes
   - Identificar os maiores clientes (Top 10)
   - Encontrar problemas (itens com menor desempenho)
   - Preparar dados para relat√≥rios e apresenta√ß√µes

4. **Lembre-se sempre:**

   - Use `desc()` para ordem decrescente
   - Para ordenar por m√∫ltiplas colunas: `arrange(var1, var2)`
   - Salve o resultado em um novo objeto!

```{r style="font-size: 1em;"}
#| eval: false
dados_ordenados <- dados %>% arrange(...)
```
:::




## Resumo das Fun√ß√µes dplyr

::: {.callout-tip icon=true}
## Resumo das seis fun√ß√µes principais

| Fun√ß√£o        | Prop√≥sito                              |
|---------------|----------------------------------------|
| `dplyr::filter()`    | Seleciona linhas baseadas em condi√ß√µes | 
| `dplyr::select()`    | Seleciona colunas espec√≠ficas          | 
| `dplyr::mutate()`    | Cria ou modifica colunas               |
| `dplyr::group_by()`  | Agrupa dados por categorias            |
| `dplyr::summarize()` | Calcula estat√≠sticas resumidas         | 
| `dplyr::arrange()`   | Ordena linhas                          |

**Lembre-se**: O poder do dplyr est√° em combinar estas fun√ß√µes com o 
operador pipe `%>%`
:::




## Pacote dplyr: Bibliografia Recomendada

- [R para Ci√™ncia de Dados - Cap. 3](http://pt.r4ds.hadley.nz/data-transform.html){target="_blank"}

- [Introdu√ß√£o √† Linguagem R - Cap. 5](https://pedropark99.github.io/Introducao_R/Cap√≠tulos/04-transformacao.html){target="_blank"}

- [Resumo](https://rstudio.github.io/cheatsheets/translations/portuguese/data-transformation_pt_br.pdf){target="_blank"}





# dplyr: Tipos B√°sicos de *joins* 


::: {.callout-note icon=false}
## O Problema da Fragmenta√ß√£o de Dados

- Dados financeiros raramente est√£o concentrados em uma √∫nica 
base ou sistema:

  - **Dados de Mercado**: Pre√ßos de ativos, volumes, volatilidade em 
    sistemas como Bloomberg ou Econom√°tica
  - **Demonstra√ß√µes Financeiras**: Balan√ßos patrimoniais, DREs e fluxos 
    de caixa em bases como CVM ou Capital IQ
  - **Informa√ß√µes de Governan√ßa**: Composi√ß√£o de conselhos, estrutura de 
    propriedade em formul√°rios de refer√™ncia
  - **Dados Macroecon√¥micos**: Indicadores como juros, infla√ß√£o e PIB em 
    bases do Banco Central ou IBGE

- An√°lises de dados muitas vezes exigem a **integra√ß√£o** dessas m√∫ltiplas 
  fontes

- **Exemplo:** Para estudar a rela√ß√£o entre governan√ßa e retorno ajustado ao 
risco, precisamos combinar:

  - Hist√≥rico de pre√ßos das a√ß√µes (base de mercado)
  - Indicadores cont√°beis como ROE e alavancagem (demonstra√ß√µes financeiras)
  - Estrutura de propriedade e composi√ß√£o do conselho (dados de governan√ßa)
  - Fatores de risco sistem√°tico (dados macroecon√¥micos)

- **Joins** (**Uni√µes**) s√£o opera√ß√µes fundamentais para esta integra√ß√£o 
em pesquisas financeiras emp√≠ricas
:::




::: {.callout-note icon=false}
## Joins na Pesquisa Emp√≠rica em Finan√ßas

- **Dados Multidimensionais**: Pesquisas financeiras tipicamente 
requerem a integra√ß√£o de:

  - Dados de mercado (pre√ßos, retornos, volume)
  - Informa√ß√µes cont√°beis (balan√ßos, DREs)
  - Indicadores macroecon√¥micos (PIB, taxas de juros, infla√ß√£o)
  - Dados de governan√ßa corporativa

- **Estudos de Evento**: An√°lises que combinam s√©ries temporais de 
pre√ßos de ativos com datas espec√≠ficas de eventos corporativos 
(fus√µes, aquisi√ß√µes, distribui√ß√£o de dividendos)

- **An√°lises de Dados em Painel**: Pesquisas que acompanham m√∫ltiplas empresas 
ao longo do tempo, exigindo combina√ß√£o de dados transversais e longitudinais

- **Reprodutibilidade Cient√≠fica**: Joins documentados garantem que 
outros pesquisadores possam reproduzir exatamente o mesmo conjunto 
de dados da an√°lise
:::




## Desafios Espec√≠ficos de Dados em Finan√ßas

::: {.callout-note icon=false}
## Problemas Comuns em Bases Financeiras

- **C√≥digos de Identifica√ß√£o Inconsistentes**:
  - Empresas podem ter m√∫ltiplos identificadores (ticker, CNPJ, c√≥digo CVM)
  - Mesma empresa pode aparecer com nomes diferentes em bases distintas
  - Subsidi√°rias e controladoras podem ter tratamentos diferentes

- **Periodicidades Divergentes**:
  - Dados de mercado (geralmente di√°rios ou intradi√°rios)
  - Dados cont√°beis (trimestrais ou anuais)
  - Dados macroecon√¥micos (mensais, trimestrais)

- **Sobreviv√™ncia das Empresas**:
  - Empresas que entram/saem da bolsa (IPOs, delisting)
  - Processos de fus√£o e aquisi√ß√£o alterando a estrutura dos dados
  - Vi√©s de sobreviv√™ncia em estudos longitudinais

- **Tratamento Especial para Eventos Financeiros**:
  - Splits, bonifica√ß√µes e outros eventos corporativos
  - Reorganiza√ß√µes societ√°rias
  - Mudan√ßas em pr√°ticas cont√°beis (IFRS)
:::




## Aplica√ß√µes Pr√°ticas de Joins na Pesquisa em Finan√ßas

::: {.callout-note icon=false}
## Exemplos de Estudos que podem Aplicar Joins

- **Estudos de Retornos Anormais**:

  ```r
  # Combinar dados de mercado com an√∫ncios de eventos
  estudo_evento <- dados_retornos %>%
    left_join(anuncios_dividendos, by = c("codigo_empresa", "data"))
   ```

- **Estudos sobre Governan√ßa e Valor**:

  ```r
  # Integrar dados de governan√ßa corporativa com desempenho cont√°bil
  analise_governanca <- empresas_dados_contabeis %>%
    left_join(indices_governanca, by = "codigo_cvm") %>%
    left_join(composicao_conselhos, by = c("codigo_cvm", "ano_fiscal"))
  ```

- **Modelos de Precifica√ß√£o de Ativos**:

  ```r
  # Combinar fatores de risco com caracter√≠sticas das empresas
  modelo_multifatorial <- retornos_ativos %>%
    left_join(fatores_mercado, by = "data") %>%
    left_join(caracteristicas_empresas, by = c("codigo_empresa", "ano", "trimestre"))
  ```

- **Mercado de Cr√©dito e Ratings**:

  ```r
  # Analisar impacto de mudan√ßas de rating no custo de capital
  analise_credito <- custos_captacao %>%
    inner_join(historico_ratings, by = c("codigo_empresa", "data_emissao"))
  ```
:::




## CRISP-DM e Joins

::: {.callout-tip icon=true}
## Joins na Fase 3 (Prepara√ß√£o dos Dados) do CRISP-DM

- Joins s√£o opera√ß√µes fundamentais na **Fase 3 (Prepara√ß√£o dos Dados)** 
  de CRISP-DM, permitindo:

- **Integrar dados fragmentados** que est√£o distribu√≠dos em m√∫ltiplas tabelas
  relacionadas entre si

- **Consolidar informa√ß√µes** de diferentes fontes ou sistemas para an√°lise
  (vendas + produtos + clientes)

- **Enriquecer dados principais** com informa√ß√µes contextuais adicionais
  (ex: adicionar categoria de produto aos dados de vendas)

- **Completar o ciclo de prepara√ß√£o** iniciado com:

  - Importa√ß√£o de dados (`read_csv()`, `read_xlsx()`)
  - Organiza√ß√£o de dados (`pivot_longer()`) para an√°lise
  - Limpeza de dados (`rename()``, `as.___()`)
  - Filtragem (`filter()`) e sele√ß√£o (`select()`) de dados relevantes
  - Transforma√ß√£o de dados (`mutate()`) para criar novas vari√°veis
  - Manipula√ß√£o de dados ( `group_by()`, `summarize()` e `arrange()`)
  - **Joins**: integrando m√∫ltiplas fontes em um arquivo de dados coeso

- Dados bem integrados facilitam as **Fases 4 e 5** (Modelagem e Avalia√ß√£o) 
  por fornecerem uma vis√£o completa do problema
:::




## Joins no dplyr

::: {.callout-note icon=false}
## O que s√£o joins?

- **Joins** s√£o opera√ß√µes que combinam duas tabelas de dados 

- Em termos simples, joins s√£o como "colar" duas tabelas lado a lado, 
  combinando linhas que t√™m valores em comum, como um "c√≥digo de cliente" 
  ou "c√≥digo de produto"

- No pacote dplyr, temos fun√ß√µes espec√≠ficas para cada tipo de join:

  - `left_join()`: Mant√©m todas as linhas da tabela da esquerda
  - `inner_join()`: Mant√©m apenas correspond√™ncias entre as tabelas
  - `full_join()`: Mant√©m todas as linhas de ambas as tabelas
  - `right_join()`: Mant√©m todas as linhas da tabela da direita

- S√£o essenciais quando precisamos combinar informa√ß√µes que est√£o separadas
:::




## Criando Tabelas de Exemplo

::: {.callout-note icon=false}
## Tabela produtos

```{r}
# Cria a tabela de produtos
produtos <- tribble(
  ~codigo_produto, ~nome_produto,      ~preco_unitario, ~categoria,
  "P001",         "Notebook Pro",      4500,           "Eletr√¥nicos",
  "P002",         "Smartphone X",      2800,           "Eletr√¥nicos",
  "P003",         "Monitor 24pol",     1200,           "Inform√°tica",
  "P004",         "Mouse Gamer",       250,            "Inform√°tica",
  "P005",         "Cadeira Ergon√¥mica", 950,           "Mobili√°rio"
)

# exibe a tabela
produtos
```
:::



::: {.callout-note icon=false}
## Tabela vendas

```{r}
# Cria a tabela de vendas
vendas <- tribble(
  ~id_venda, ~codigo_produto, ~id_cliente, ~data_venda,  ~quantidade,
  1,         "P001",          "C001",      "2025-04-15", 1,
  2,         "P002",          "C002",      "2025-04-16", 2,
  3,         "P003",          "C001",      "2025-04-18", 2,
  4,         "P002",          "C003",      "2025-04-20", 1,
  5,         "P006",          "C002",      "2025-04-22", 3,
  6,         "P004",          "C004",      "2025-04-23", 4
)

# exibe a tabela
vendas
```
:::



::: {.callout-note icon=false}
## Tabela Clientes

```{r style="font-size: 1em;"}
# Crian a tabela de clientes 
clientes <- tribble(
  ~id_cliente, ~nome_cliente,     ~cidade,
  "C001",      "Empresa Alpha",   "S√£o Paulo",
  "C002",      "Empresa Beta",    "Rio de Janeiro",
  "C003",      "Jo√£o Silva",      "Belo Horizonte",
  "C005",      "Maria Oliveira",  "Recife"
)

# exibe a tabela
clientes
```
:::


::: {.callout-note icon=false}
## Dados dos Exemlos 

```{r style="font-size: 1em;"}
produtos
vendas
clientes
```


**Observe que h√° dados "imperfeitos"**: 

- Produto "P006" est√° nas vendas, mas n√£o na tabela de produtos
- Cliente "C004" est√° nas vendas, mas n√£o na tabela de clientes
- Cliente "C005" est√° na tabela de clientes, mas n√£o tem vendas
:::




## Chaves em Joins

::: {.callout-note icon=false}
## Como tabelas se relacionam

- **Chaves** s√£o as colunas usadas para combinar as tabelas

- Na pr√°tica:

  - A tabela de clientes tem um "codigo_cliente" √∫nico para cada cliente
  
  - A tabela de vendas usa esse mesmo "codigo_cliente" para indicar qual 
    cliente fez cada compra
    
  - O "codigo_cliente" √© a "chave" que permite combinar as informa√ß√µes 
    das duas tabelas

- Nas fun√ß√µes de join do dplyr, as chaves s√£o especificadas pelo 
argumento `by`
:::




## Tipos de Chaves em Bancos de Dados Relacionais


::: {.callout-note icon=false}
## Chaves Prim√°rias e Estrangeiras

- **Chave prim√°ria**: Identificador √∫nico para cada registro em uma tabela

  - Ex: `codigo_cliente` na tabela de clientes identifica unicamente cada cliente
  - N√£o pode conter valores duplicados ou nulos
  
- **Chave estrangeira**: Coluna que referencia a chave prim√°ria de outra tabela

  - Ex: `codigo_cliente` na tabela de vendas √© uma chave estrangeira
  - Estabelece rela√ß√µes entre tabelas e mant√©m a integridade referencial

- **Analogia**: Pense em chaves como um sistema de CPF

  - A chave prim√°ria √© como o CPF √∫nico de cada pessoa
  - A chave estrangeira √© como mencionar o CPF de algu√©m em um documento
  - Os joins s√£o como reunir documentos diferentes sobre a mesma pessoa usando seu CPF
:::





## Diagrama de Rela√ß√µes com Chaves


::: {.callout-note icon=false}
## Visualizando a rela√ß√£o entre tabelas

```{.markdown}
Tabela CLIENTES                 Tabela VENDAS
+--------------+            +---------------+
| codigo_cliente| <--------- |codigo_cliente |  
| nome_cliente  |            | id_venda      |
| cidade        |            | data_venda    |
+--------------+            +---------------+
   Chave Prim√°ria             Chave Estrangeira
```

- **Integridade referencial**: Garante que rela√ß√µes entre tabelas permane√ßam v√°lidas
  - Impede a cria√ß√£o de vendas para clientes inexistentes
  - Fundamental para a confiabilidade dos dados em sistemas empresariais
:::





## Exemplos Comuns de Chaves

::: {.callout-note icon=false}
## Chaves em sistemas empresariais

Exemplos comuns de chaves em sistemas de informa√ß√£o empresariais:

- **"codigo_produto"** para relacionar produtos e vendas
- **"codigo_funcionario"** para relacionar funcion√°rios e departamentos
- **"numero_pedido"** para relacionar pedidos e itens de pedido
- **"codigo_fiscal"** para relacionar notas fiscais e itens fiscais
- **"matricula_aluno"** em sistemas educacionais
- **"numero_prontuario"** em sistemas de sa√∫de

A identifica√ß√£o correta das chaves √© fundamental para o sucesso de joins e para garantir a integridade das an√°lises de dados.
:::





## Desafios com Chaves em Joins

::: {.callout-note icon=false}
## Problemas comuns ao trabalhar com chaves

- **Chaves duplicadas**: 

  - Podem gerar m√∫ltiplas linhas no resultado (multiplica√ß√£o de dados)
  - Exemplo: Um cliente vinculado a v√°rias vendas resulta em m√∫ltiplas linhas

- **Chaves ausentes**: 

  - Resultam em valores NA quando usando left, right ou full joins
  - Exemplo: Vendas sem cliente cadastrado ou produtos sem vendas

- **Inconsist√™ncia de tipos**: 

  - Problemas quando a mesma chave tem tipos diferentes em tabelas distintas
  - Exemplo: c√≥digo armazenado como texto em uma tabela e n√∫mero em outra

- **Diferen√ßas de nomenclatura**:

  - Quando a mesma informa√ß√£o tem nomes diferentes em sistemas distintos
  - Requer especifica√ß√£o expl√≠cita: `by = c("codigo_produto" = "codigo")`
:::



## Sintaxe B√°sica de Joins no dplyr

::: {.callout-tip}
## Como usar joins no dplyr (simplificado)

```{r}
#| eval: false

# Formato b√°sico (simples)
resultado <- x %>% 
  tipo_join(y, by = "coluna_comum")

# Exemplo com nossas tabelas
vendas_com_produtos <- vendas %>%
  left_join(produtos, by = "codigo_produto")
```

**O que cada parte significa:**

- `vendas`: A primeira tabela (tabela da esquerda)
- `produtos`: A segunda tabela (tabela da direita)
- `by = "codigo_produto"`: A coluna comum que existe em ambas as tabelas
- `left_join`: O tipo de join que queremos usar
- `vendas_com_produtos`: O resultado da combina√ß√£o que salvaremos
:::




## Vis√£o Geral dos Joins 

::: {.callout-tip}
## Em resumo:

| Tipo de Join  | Fun√ß√£o no dplyr    | Quando usar                                  |
|---------------|--------------------|-------------------------------------------------|
| Left join     | `left_join()`      | Quando voc√™ precisa manter todos os registros da tabela principal (√† esquerda) |
| Inner join    | `inner_join()`     | Quando voc√™ precisa apenas dos registros que existem em ambas as tabelas |
| Full join     | `full_join()`      | Quando voc√™ precisa de todos os dados, independentemente de correspond√™ncias |
| Right join    | `right_join()`     | Quando voc√™ precisa manter todos os registros da tabela secund√°ria (√† direita) |
:::




## Left Join 

::: {.callout-tip}
## Fun√ß√£o left_join()

```{r}
#| eval: false
resultado <- x %>% 
  left_join(y, by = "chave")
```
:::


![](img/left-join.gif){fig-align="center"}



::: {.callout-note icon=false}
## Caracter√≠sticas do Left Join

- Mant√©m **todos** os registros da tabela da esquerda (primeira tabela)

- Para registros sem correspond√™ncia na tabela da direita, preenche com NA

- **Quando usar**:

  - Quando a primeira tabela √© sua tabela principal
  - Quando voc√™ precisa preservar todos os registros da primeira tabela
  - Quando voc√™ quer adicionar informa√ß√µes extras √† sua tabela principal

- **Exemplo**: Manter todas as vendas e adicionar dados dos produtos
:::





## Exemplo: Left Join em Pesquisa

::: {.callout-note icon=false}
## Left Join: An√°lise de Empresas e seus Indicadores Cont√°beis

```{r}
# Tabela de empresas listadas
empresas_listadas <- tribble(
  ~codigo_cvm, ~empresa,            ~setor,              ~segmento_listagem,
  "11592",     "Petrobras",         "Petr√≥leo e G√°s",    "N√≠vel 2",
  "19615",     "Vale",              "Minera√ß√£o",         "Novo Mercado",
  "14311",     "Ita√∫ Unibanco",     "Financeiro",        "N√≠vel 1",
  "18112",     "Natura",            "Bens de Consumo",   "Novo Mercado",
  "22691",     "Magazine Luiza",    "Varejo",            "Novo Mercado"
)

# visualiza o resultado
empresas_listadas 
```


```{r}
# Tabela de indicadores cont√°beis
indicadores_contabeis <- tribble(
  ~codigo_cvm, ~ano_fiscal, ~roa,    ~roe,    ~ebitda_margem,  ~divida_liquida,
  "11592",     2023,         0.089,   0.235,   0.392,           315780000,
  "19615",     2023,         0.112,   0.268,   0.468,           185230000,
  "14311",     2023,         0.064,   0.195,   0.412,           NULL,
  "22691",     2023,         0.052,   0.148,   0.185,           12450000
)
# visualiza o resultado
indicadores_contabeis 
```


```{r}
# Left join: todas as empresas, mesmo sem indicadores cont√°beis dispon√≠veis
analise_empresas <- empresas_listadas %>%
  left_join(indicadores_contabeis, by = "codigo_cvm")

# Visualizando o resultado
analise_empresas
```

**Observe que**:

- A empresa "Natura" (c√≥digo CVM "18112") **aparece** no resultado

- Como n√£o h√° dados cont√°beis dispon√≠veis para esta empresa, as colunas de indicadores aparecem com NA

- O left_join √© muito utilizado em pesquisas quando queremos manter todas as empresas da amostra, mesmo aquelas com dados incompletos - decis√£o metodol√≥gica comum em estudos com amostras pequenas
:::





## Inner Join {.smaller}


::: {.callout-tip}
## Fun√ß√£o inner_join()

```{r}
#| eval: false
resultado <- x %>% 
  inner_join(y, by = "chave")
```
:::


![](img/inner-join.gif){fig-align="center"}



::: {.callout-note icon=false}
## Caracter√≠sticas do Inner Join

- Mant√©m **apenas** os registros que possuem correspond√™ncia em **ambas** 
as tabelas

- Descarta linhas que n√£o t√™m correspond√™ncia

- **Quando usar**:

  - Quando voc√™ precisa garantir que todos os registros tenham informa√ß√µes 
    completas
    
  - Quando registros sem correspond√™ncia n√£o s√£o relevantes para sua an√°lise

- **Exemplo**: Relat√≥rio de vendas que precisa mostrar dados do produto
:::





## Exemplo: Inner Join em Pesquisa 


::: {.callout-note icon=false}
## Inner Join: Analisando Eventos de Rating e Performance de Bonds

```{r}
# Tabela de t√≠tulos de d√≠vida corporativa (bonds)
titulos_divida <- tribble(
  ~isin,          ~emissor,        ~valor_emissao, ~yield_to_maturity, ~vencimento,
  "BRPETRDBS036", "Petrobras",     1000000000,     0.0785,             "2030-03-15",
  "BRVALEDBF009", "Vale",           750000000,     0.0652,             "2032-10-08",
  "BRITAUDB0025", "Ita√∫ Unibanco",  500000000,     0.0723,             "2028-05-22",
  "BRBTGPDB0017", "BTG Pactual",    650000000,     0.0798,             "2029-08-30",
  "BRCVCODB0032", "Cielo",          350000000,     0.0815,             "2027-11-12"
)
# visualiza o resultado
titulos_divida
```


```{r}
# Tabela de mudan√ßas de rating
mudancas_rating <- tribble(
  ~isin,          ~data_evento,  ~agencia,   ~rating_anterior, ~novo_rating, ~perspectiva,
  "BRPETRDBS036", "2023-05-10",  "Moody's",  "Ba2",            "Ba1",        "Positiva",
  "BRVALEDBF009", "2023-06-22",  "S&P",      "BBB",            "BBB+",       "Est√°vel",
  "BRVALEDBF009", "2023-08-15",  "Fitch",    "BBB",            "BBB+",       "Est√°vel",
  "BRITAUDB0025", "2023-07-08",  "Moody's",  "Ba1",            "Baa3",       "Est√°vel",
  "BRECOPDB0016", "2023-09-14",  "S&P",      "BB-",            "BB",         "Positiva"
)
# visualiza o resultado
mudancas_rating
```


```{r}
# Inner join: apenas t√≠tulos de d√≠vida que tiveram mudan√ßas de rating
analise_rating_impacto <- titulos_divida %>%
  inner_join(mudancas_rating, by = "isin")

# Visualizando o resultado
analise_rating_impacto
```

**Observe que**:

- O t√≠tulo da "Cielo" (ISIN "BRCVCODB0032") **n√£o aparece** no resultado 
  pois n√£o teve mudan√ßa de rating no per√≠odo analisado

- A mudan√ßa de rating do t√≠tulo "BRECOPDB0016" tamb√©m **n√£o aparece** no resultado
  pois este t√≠tulo n√£o est√° na nossa base de t√≠tulos monitorados

- O inner_join √© apropriado para estudos de evento onde queremos analisar apenas 
  os casos onde ocorreu o evento espec√≠fico (neste caso, mudan√ßa de rating)
:::





## Full Join 

::: {.callout-tip}
## Fun√ß√£o full_join()

```{r}
#| eval: false
resultado <- x %>% 
  full_join(y, by = "chave")
```
:::


![](img/full-join.gif){fig-align="center"}



::: {.callout-note icon=false}
## Caracter√≠sticas do Full Join

- Mant√©m **todos** os registros de **ambas** as tabelas

- Para registros sem correspond√™ncia em qualquer tabela, preenche com NA

- **Quando usar**:

  - Quando voc√™ precisa de uma vis√£o completa de todos os dados
  - Quando quer identificar inconsist√™ncias entre tabelas
  - Quando √© importante n√£o perder nenhum registro de nenhuma tabela

- **Exemplo**: Relat√≥rio completo de produtos e vendas
:::





## Exemplo: Full Join

::: {.callout-note icon=false}
## Full Join entre Vendas e Produtos

```{r}
# Full join: todas as vendas e todos os produtos
# Passo 1: Pegamos a tabela 'vendas'
# Passo 2: Combinamos com produtos mantendo TUDO de ambas as tabelas
completo_vendas_produtos <- vendas %>%
  full_join(produtos, by = "codigo_produto")

# Visualizando o resultado
completo_vendas_produtos
```

**Observe que**:

- A venda do produto "P006" que n√£o existe na tabela de produtos aparece 
  com NAs
  
- O produto "P005" que n√£o tem vendas tamb√©m aparece com NAs

- O full_join √© √∫til para ver "tudo junto" e identificar inconsist√™ncias
:::




## Right Join


::: {.callout-tip}
## Fun√ß√£o right_join()

```{r}
#| eval: false
resultado <- x %>% 
  right_join(y, by = "chave")
```
:::


![](img/right-join.gif){fig-align="center"}



::: {.callout-note icon=false}
## Caracter√≠sticas do Right Join

- Mant√©m **todos** os registros da tabela da direita (segunda tabela)

- Para registros sem correspond√™ncia na tabela da esquerda, preenche com NA

- **Quando usar**:

  - Quando a segunda tabela √© sua tabela principal
  
  - Quando voc√™ precisa garantir que todos os registros da segunda tabela 
    estejam presentes
    
  - Na pr√°tica, muitas vezes √© mais f√°cil usar left_join invertendo a 
    ordem das tabelas

- **Exemplo**: Ver todos os produtos, mesmo os que n√£o foram vendidos
:::





## Exemplo: Right Join

::: {.callout-note icon=false}
## Right Join entre Vendas e Produtos

```{r}
# Right join: todos os produtos, mesmo sem vendas
# Passo 1: Pegamos a tabela 'vendas'
# Passo 2: Combinamos com TODOS os produtos, mesmo os sem vendas
produtos_vendas_right <- vendas %>%
  right_join(produtos, by = "codigo_produto")

# Visualizando o resultado
produtos_vendas_right
```

**Observe que**:

- Agora o produto "P005" (Cadeira Ergon√¥mica) **aparece** no resultado
- Como esse produto n√£o tem vendas, as colunas de vendas aparecem com NA
- O right_join √© √∫til para identificar produtos sem movimento
:::




## Exemplo: Combinando M√∫ltiplas Tabelas


::: {.callout-note icon=false}
## Estudo integrado de Governan√ßa, Retorno e Risco Sist√™mico 

```{r}
# Tabela de empresas e caracter√≠sticas de governan√ßa
governanca <- tribble(
  ~codigo_negociacao, ~empresa,         ~indice_governanca, ~tipo_controlador, ~comite_auditoria,
  "PETR4",            "Petrobras",      6.8,                "Estatal",         TRUE,
  "VALE3",            "Vale",           8.2,                "Pulverizado",     TRUE,
  "ITUB4",            "Ita√∫ Unibanco",  7.9,                "Familiar",        TRUE,
  "BBDC4",            "Bradesco",       7.6,                "Familiar",        TRUE,
  "MGLU3",            "Magazine Luiza", 7.1,                "Familiar",        FALSE
)
# visualiza o resultado
governanca
```


```{r}
# Tabela de retornos anuais ajustados
retornos <- tribble(
  ~codigo_negociacao, ~ano,  ~retorno_anual, ~volatilidade, ~beta,
  "PETR4",            2023,   0.125,          0.285,        1.32,
  "VALE3",            2023,   0.084,          0.215,        1.18,
  "ITUB4",            2023,   0.152,          0.195,        0.87,
  "BBDC4",            2023,   0.138,          0.205,        0.92,
  "ABEV3",            2023,   0.062,          0.165,        0.72
)
# visualiza o resultado
retornos
```


```{r}
# Tabela de indicadores cont√°beis
indicadores <- tribble(
  ~codigo_negociacao, ~ano,  ~roa,    ~alavancagem, ~tamanho_ativo,
  "PETR4",            2023,   0.089,   0.325,        395120000,
  "VALE3",            2023,   0.112,   0.285,        312450000,
  "ITUB4",            2023,   0.064,   0.852,        2185620000,
  "BBDC4",            2023,   0.058,   0.815,        1924380000,
  "MGLU3",            2023,   0.052,   0.368,         28540000
)
# visualiza o resultado
indicadores
```


```{r}
# Pipeline de an√°lise integrada
analise_integrada <- governanca %>%
  # Primeiro, adicionamos dados de retorno e risco
  left_join(retornos, by = "codigo_negociacao") %>%
  # Depois, adicionamos indicadores cont√°beis
  left_join(indicadores, by = c("codigo_negociacao", "ano")) %>%
  # Selecionamos apenas as vari√°veis relevantes para o estudo
  select(
    empresa, codigo_negociacao, ano, indice_governanca, tipo_controlador,
    retorno_anual, volatilidade, beta, 
    roa, alavancagem, tamanho_ativo
  )

# Visualizando o resultado
analise_integrada
```

**Observe como**:

- Este pipeline combina tr√™s conjuntos de dados distintos (governan√ßa, mercado e cont√°bil)
- Empresas como "Magazine Luiza" (MGLU3) aparecem sem dados de retorno (NA)
- "ABEV3" aparece nos dados de retorno, mas n√£o nas outras tabelas

**Implica√ß√µes metodol√≥gicas**:

- O uso de left_join manteve todas as empresas com dados de governan√ßa, revelando lacunas nos dados
- A defini√ß√£o desta amostra de estudo (firmas com dados de governan√ßa) √© uma escolha metodol√≥gica expl√≠cita
- Este tipo de constru√ß√£o de amostra √© muito √∫til em estudos emp√≠ricos que analisam rela√ß√µes entre diferentes conjuntos de observa√ß√µes e vari√°veis.
:::





## Exemplo: An√°lise de Demonstra√ß√µes Financeiras


::: {.callout-note icon=false}
## Cen√°rio: Pesquisa em Desempenho Financeiro Setorial

```{r}
# Tabela com informa√ß√µes b√°sicas das empresas
empresas <- tribble(
  ~codigo_cvm, ~nome_empresa,      ~setor,              ~tamanho,  ~governanca,
  "11592",    "Petrobras S.A.",    "Petr√≥leo e G√°s",    "Grande",  "N√≠vel 2",
  "19615",    "Vale S.A.",         "Minera√ß√£o",         "Grande",  "Novo Mercado",
  "14311",    "Ita√∫ Unibanco S.A.", "Financeiro",       "Grande",  "N√≠vel 1",
  "18112",    "Natura Cosm√©ticos", "Bens de Consumo",   "M√©dio",   "Novo Mercado",
  "22691",    "Magazine Luiza",    "Varejo",            "M√©dio",   "Novo Mercado"
)

# visualiza o resultado
empresas
```


```{r}
# Tabela de indicadores financeiros trimestrais
indicadores_financeiros <- tribble(
  ~codigo_cvm, ~ano, ~trimestre, ~roa,  ~alavancagem, ~liquidez_corrente, ~margem_ebitda,
  "11592",     2024,  1,          0.032,  0.58,         1.45,              0.28,
  "11592",     2024,  2,          0.041,  0.56,         1.52,              0.31,
  "19615",     2024,  1,          0.045,  0.32,         2.10,              0.34,
  "19615",     2024,  2,          0.048,  0.31,         2.15,              0.36,
  "14311",     2024,  1,          0.018,  0.82,         1.28,              0.42,
  "14311",     2024,  2,          0.019,  0.81,         1.31,              0.41,
  "22691",     2024,  1,          0.028,  0.62,         1.18,              0.12,
  "22691",     2024,  2,          0.025,  0.68,         1.12,              0.10
)
# visualiza o resultado
indicadores_financeiros
```


```{r}
# Combinando dados para an√°lise de desempenho por setor
analise_setorial <- empresas %>%
  left_join(indicadores_financeiros, by = "codigo_cvm") %>%
  select(nome_empresa, setor, ano, trimestre, roa, alavancagem, margem_ebitda)

# Visualizando o resultado
analise_setorial
```

**Aplica√ß√£o em Pesquisa**:

- Este tipo de join permite analisar desempenho financeiro controlando 
por caracter√≠sticas espec√≠ficas das empresas

- √ötil para estudos que investigam:
  - Impacto de governan√ßa corporativa nos indicadores cont√°beis
  - Diferen√ßas de desempenho entre setores
  - Efeito do tamanho da empresa na performance financeira

- **Nota**: Observem que "Natura Cosm√©ticos" (c√≥digo 18112) n√£o aparece 
nos resultados porque n√£o h√° dados financeiros correspondentes - 
situa√ß√£o comum em pesquisas emp√≠ricas
:::





## Exemplo: An√°lise de Retornos Anormais

::: {.callout-note icon=false}
## Cen√°rio: Estudo de Evento sobre An√∫ncios de Dividendos

```{r style="font-size: 1em;"}
# Tabela de pre√ßos di√°rios de a√ß√µes
precos_acoes <- tribble(
  ~ticker,   ~data,          ~preco_fechamento, ~retorno_diario, ~volume,
  "PETR4",   "2024-04-01",   36.75,             0.0125,          15200000,
  "PETR4",   "2024-04-02",   37.30,             0.0150,          18500000,
  "PETR4",   "2024-04-03",   37.05,            -0.0067,          14800000,
  "PETR4",   "2024-04-04",   37.82,             0.0208,          21300000,
  "PETR4",   "2024-04-05",   37.60,            -0.0058,          16900000,
  "VALE3",   "2024-04-01",   68.45,             0.0087,          22400000,
  "VALE3",   "2024-04-02",   68.92,             0.0069,          19800000,
  "VALE3",   "2024-04-03",   70.15,             0.0178,          25600000,
  "VALE3",   "2024-04-04",   71.20,             0.0150,          28300000,
  "VALE3",   "2024-04-05",   70.85,            -0.0049,          23100000
)

# visualiza o resultado
precos_acoes
```


```{r}
# Tabela de an√∫ncios de eventos corporativos
eventos_corporativos <- tribble(
  ~ticker,   ~data_anuncio,   ~tipo_evento,        ~valor,
  "PETR4",   "2024-04-03",    "Dividendo Extra",   2.85,
  "VALE3",   "2024-04-04",    "JCP",               1.75
)
# visualiza o resultado
eventos_corporativos
```


```{r}
# Realizando an√°lise de retornos nos dias de evento
estudo_evento <- precos_acoes %>%
  inner_join(eventos_corporativos, 
             by = c("ticker", "data" = "data_anuncio")) %>%
  select(ticker, data, tipo_evento, valor, retorno_diario, volume)

# Visualizando o resultado
estudo_evento
```

**Aplica√ß√£o em Pesquisa**:

- Este tipo de join √© relevante para estudos de evento que analisam o 
impacto de an√∫ncios corporativos sobre o pre√ßo das a√ß√µes

- Aplica√ß√µes em pesquisas financeiras incluem:
  - Rea√ß√£o do mercado a an√∫ncios de distribui√ß√£o de proventos
  - Avalia√ß√£o da efici√™ncia informacional em mercados emergentes
  - Impacto de divulga√ß√µes cont√°beis e eventos n√£o-recorrentes

- O `inner_join` utilizado garante que apenas os dias com eventos s√£o 
considerados para a an√°lise de retornos anormais
:::





## Fontes Comuns de Dados em Pesquisa Financeira


::: {.callout-note icon=false}
## Bases que Frequentemente Requerem Joins

- **Bases Estruturadas para Pesquisa Acad√™mica**:
  - **Econom√°tica**: Dados cont√°beis e de mercado de empresas brasileiras
  - **Bloomberg**: Dados financeiros globais de alta frequ√™ncia

- **Fontes P√∫blicas no Brasil**:
  - **B3**: Dados de negocia√ß√£o, √≠ndices e eventos corporativos
  - **CVM**: Demonstra√ß√µes financeiras padronizadas (DFPs) e formul√°rios de 
    refer√™ncia
  - **Banco Central**: Indicadores macroecon√¥micos e financeiros
  - **IBGE**: Dados econ√¥micos setoriais e regionais

- **Desafios na Integra√ß√£o**:
  - Identificadores divergentes entre bases (c√≥digos CVM vs. tickers vs. CNPJ)
  - Periodicidades diferentes (di√°ria, mensal, trimestral, anual)
  - Diferen√ßas metodol√≥gicas na compila√ß√£o dos dados
  - Tratamento de eventos corporativos (fus√µes, aquisi√ß√µes, cis√µes)

- **Estrat√©gias para Joins Eficientes**:
  - Criar tabelas de correspond√™ncia entre diferentes identificadores
  - Padronizar datas para permitir joins temporais precisos
  - Documentar crit√©rios de exclus√£o e tratamento de valores ausentes
:::




## Dicas para Uso Eficiente de Joins

::: {.callout-tip}
## Dicas pr√°ticas para iniciantes

1. **Conhe√ßa seus dados antes de combinar**:

   - Verifique se as tabelas t√™m as "chaves" correspondentes
   - Entenda o que significam valores ausentes (NAs)

2. **Filtre antes de combinar**:

   - Se voc√™ s√≥ precisa de alguns dados, filtre-os antes de fazer joins
   - Isso torna a an√°lise mais r√°pida e clara

3. **Verifique o resultado**:

   - O n√∫mero de linhas faz sentido?
   - H√° valores NA inesperados?
   - Os totais parecem corretos?

4. **Na d√∫vida, use left_join**:

   - √â o mais comum e seguro para iniciantes
   - Mant√©m todos os registros da tabela principal
:::





## O Desafio dos Sistemas Reais

::: {.callout-note icon=false}
## Situa√ß√£o Comum em Ambientes Empresariais

No mundo ideal, todos os sistemas usariam os mesmos nomes para as 
mesmas informa√ß√µes...

Mas na pr√°tica:

- O sistema de Vendas pode usar `codigo_produto`
- O Cadastro de Produtos pode usar `codigo`
- O ERP pode usar `cod_prod`
- O sistema legado pode usar `id_produto`

**Resultado**: Tentar unir estas tabelas com a sintaxe b√°sica falha:

```{r}
#| eval: false

# Esta tentativa falha:
vendas %>% 
  left_join(produtos, by = "codigo_produto") 
  
# ERRO: 'codigo_produto' n√£o encontrado em 'produtos'
```

Como resolver este problema comum?
:::




## A Solu√ß√£o

::: {.callout-note icon=false}
## Sintaxe para Colunas com Nomes Diferentes

O dplyr permite especificar explicitamente quais colunas devem ser 
correspondidas:

```{r style="font-size: 1em;"}
#| eval: false

# Sintaxe para colunas com nomes diferentes
tabela1 %>%
  left_join(tabela2, by = c("nome_na_tabela1" = "nome_na_tabela2"))
```

**Como interpretar:**

- `"nome_na_tabela1"`: Nome da coluna na primeira tabela (esquerda)
- `"nome_na_tabela2"`: Nome da coluna na segunda tabela (direita)
- O operador `=` estabelece a correspond√™ncia entre as colunas

**Analogia**: Voc√™ est√° criando um "dicion√°rio de tradu√ß√£o" entre 
os sistemas:

- "Quando eu digo `codigo_produto`, voc√™ entende `codigo`"
:::




::: {.callout-note icon=false}
## Cen√°rio: Relat√≥rio de Vendas Integrado

```{r}
# Sistema de Cadastro de Produtos (departamento de Compras)
produtos_cadastro <- tribble(
  ~codigo,       ~descricao,        ~valor_unitario, ~categoria,
  "P001",        "Notebook Pro",     4500,           "Eletr√¥nicos",
  "P002",        "Smartphone X",     2800,           "Eletr√¥nicos",
  "P003",        "Monitor 24pol",    1200,           "Inform√°tica"
)
# visualiza o resultado
produtos_cadastro
```


```{r}
# Sistema de Vendas (departamento Comercial)
vendas_sistema <- tribble(
  ~id_venda, ~cod_produto, ~data_venda,  ~qtd,
  1,         "P001",       "2025-04-15", 1,
  2,         "P002",       "2025-04-16", 2,
  3,         "P003",       "2025-04-18", 2
)
# visualiza o resultado
vendas_sistema
```


```{r}
# Integrando os sistemas com diferentes nomenclaturas
relatorio_vendas <- vendas_sistema %>%
  left_join(produtos_cadastro, by = c("cod_produto" = "codigo")) %>%
  select(id_venda, data_venda, cod_produto, descricao, qtd, valor_unitario) %>%
  mutate(valor_total = qtd * valor_unitario) %>%
  arrange(data_venda)

# Resultado: um relat√≥rio integrado
relatorio_vendas
```

**Observa√ß√£o**: Esta situa√ß√£o √© extremamente comum.
:::





## Resumo: Joins

::: {.callout-tip}
## Pontos-chave para lembrar

1. **Joins unem tabelas que est√£o separadas**

   - Combinam dados de clientes, produtos, vendas, etc.
   - Permitem an√°lises mais completas e informativas

2. **Os tipos mais importantes s√£o**:

   - `left_join()`: Mant√©m todos os registros da tabela principal (o mais 
      usado)
   - `inner_join()`: Mant√©m apenas registros com correspond√™ncia em ambas 
      tabelas
   - `full_join()`: Mant√©m todos os registros de ambas as tabelas

3. **Na pr√°tica, left_join √© o mais comum**:

   - Mant√©m todos os registros da tabela principal
   - Adiciona informa√ß√µes complementares quando dispon√≠veis
   - Evita a perda de registros importantes

4. **Comece simples e avance gradualmente**:

   - Primeiro fa√ßa joins entre duas tabelas
   - Depois adicione mais tabelas conforme necess√°rio
   - Verifique os resultados a cada passo
:::



::: {.callout-tip}
## Guia R√°pido de Joins no dplyr

| Tipo de Join | Fun√ß√£o | Resultado | Quando Usar | Analogia de Neg√≥cios |
|--------------|--------|-----------|-------------|----------------------|
| **Inner Join** | `inner_join()` | Apenas registros com correspond√™ncia | An√°lises que exigem dados completos | Relat√≥rio com apenas vendas confirmadas |
| **Left Join** | `left_join()` | Todos os registros da tabela esquerda | Manter a tabela principal intacta | Relat√≥rio de todas as vendas (com ou sem produto cadastrado) |
| **Right Join** | `right_join()` | Todos os registros da tabela direita | Quando a 2¬™ tabela √© a principal | Cat√°logo com todos os produtos (vendidos ou n√£o) |
| **Full Join** | `full_join()` | Todos os registros de ambas as tabelas | An√°lises completas e auditorias | Verifica√ß√£o de inconsist√™ncias no sistema |

**Dica para lembrar**: Pense no "lado" que voc√™ quer preservar:

- **Left** = Tudo do **lado esquerdo** (1¬™ tabela)
- **Inner** = S√≥ o que est√° nos **dois lados**
- **Full** = **Tudo** de **ambos os lados**
- **Right** = Tudo do **lado direito** (2¬™ tabela)
:::




## Sintaxe Comparativa


::: {.callout-note icon=false}
## Estrutura comum dos diferentes tipos de joins

```{r}
#| eval: false
# LEFT JOIN: todos os registros da tabela1

tabela1 %>% 
  left_join(tabela2, by = "coluna_comum")

# INNER JOIN: apenas registros com correspond√™ncia

tabela1 %>% 
  inner_join(tabela2, by = "coluna_comum")

# FULL JOIN: todos os registros de ambas as tabelas

tabela1 %>% 
  full_join(tabela2, by = "coluna_comum")

# RIGHT JOIN: todos os registros da tabela2

tabela1 %>% 
  right_join(tabela2, by = "coluna_comum")
```

**Observe que:**

1. **A estrutura b√°sica √© id√™ntica** para todos os joins:

   - Comece com a primeira tabela
   - Use o operador pipe `%>%`
   - Aplique a fun√ß√£o de join
   - Adicione a segunda tabela e a coluna comum

2. **S√≥ muda o nome da fun√ß√£o**, que indica qual tipo de join realizar:
   - `inner_join`, `left_join`, `right_join` ou `full_join`

3. **Quando as colunas t√™m nomes diferentes**, use esta sintaxe:

```{r style="font-size: 1em;"}
#| eval: false
# Quando colunas t√™m nomes diferentes nas tabelas
vendas %>% 
  left_join(produtos, by = c("codigo_produto" = "codigo"))
#            ^ coluna na tabela vendas   ^ coluna na tabela produtos
```
:::




## Onde Aplicar Joins em Pesquisa Financeira


::: {.callout-note icon=false}
## Aplica√ß√µes pr√°ticas em Pesquisa e An√°lise Financeira

- **Finan√ßas Corporativas**:

  - Combinar dados de estrutura de capital com m√©tricas de desempenho 
    para an√°lise de trade-offs
  - Unir s√©ries hist√≥ricas de dividendos com indicadores de estrutura 
    de propriedade
  - Integrar dados de fus√µes e aquisi√ß√µes com caracter√≠sticas espec√≠ficas 
    das empresas
  - Analisar rela√ß√µes entre estrutura de governan√ßa corporativa e custo 
    de capital

- **Mercado de Capitais**:

  - Relacionar retornos anormais a eventos corporativos espec√≠ficos 
    (estudos de evento)
  - Combinar fatores de risco sistem√°tico com caracter√≠sticas espec√≠ficas 
    das empresas
  - Unir dados de negocia√ß√£o de alta frequ√™ncia com an√∫ncios macroecon√¥micos
  - Integrar pre√ßos de ativos com m√©tricas de liquidez e volatilidade impl√≠cita

- **Finan√ßas Comportamentais**:

  - Integrar dados de transa√ß√µes de investidores individuais com 
    caracter√≠sticas socioecon√¥micas
  - Combinar sentiment analysis de not√≠cias financeiras com movimentos 
    de pre√ßos
  - Unir dados de pesquisas de percep√ß√£o de risco com comportamento real 
    de investimento
  - Relacionar caracter√≠sticas psicom√©tricas com decis√µes de portf√≥lio

- **Econometria Financeira**:

  - Construir pain√©is de dados balanceados para estima√ß√£o de modelos 
    longitudinais
  - Combinar s√©ries temporais financeiras com vari√°veis instrumentais 
    para an√°lises causais
  - Integrar dados de diferentes frequ√™ncias (di√°rios, mensais, trimestrais) 
     para modelos misto-frequ√™ncia
  - Unir dados micro e macroecon√¥micos para an√°lises multin√≠veis
:::




## Joins: Bibliografia Recomendada

- [R para Ci√™ncia de Dados - Cap. 19](http://pt.r4ds.hadley.nz/joins.html){target="_blank"}

- [Introdu√ß√£o √† Linguagem R - Cap. 6](https://pedropark99.github.io/Introducao_R/Cap√≠tulos/06-dados-relacionais.html#introduzindo-joins){target="_blank"}





# Dados Organizados: Potencializando An√°lises de Dados


::: {.callout-tip}
## Dados Longos = Dados Organizados

Com os dados organizados (formato longo), podemos facilmente, 
por exemplo:

- Calcular indicadores de desempenho por categoria e per√≠odo
- Calcular indicadores de desempenho por produto e per√≠odo
- Analisar tend√™ncias mensais para decis√µes de estoque e marketing
- etc.
:::




## Aplica√ß√µes 

::: {.callout-note icon=false}
## Dados organizados permitem:

- **Finan√ßas e Controladoria**: An√°lise de tend√™ncias financeiras entre 
per√≠odos, detec√ß√£o de anomalias em despesas, compara√ß√£o de desempenho entre 
unidades de neg√≥cio

- **Marketing**: Avalia√ß√£o de ROI por canal e campanha, an√°lise de 
comportamento do consumidor, segmenta√ß√£o de clientes baseada em 
m√∫ltiplas vari√°veis

- **Opera√ß√µes e Cadeia de Suprimentos**: Otimiza√ß√£o de estoques baseada em 
tend√™ncias sazonais, previs√£o de demanda, monitoramento da cadeia de 
suprimentos

- **Recursos Humanos**: An√°lise de desempenho ao longo do tempo, identifica√ß√£o 
de fatores de turnover, planejamento de capacita√ß√£o

- **Estrat√©gia de Neg√≥cios**: Consolida√ß√£o de KPIs de diversas √°reas para 
tomada de decis√£o, identifica√ß√£o de correla√ß√µes entre vari√°veis de neg√≥cio

- **Na pr√°tica**: Administradores frequentemente recebem dados em formatos 
inadequados para an√°lise (relat√≥rios est√°ticos, planilhas "bonitas"). 
A capacidade de reorganizar esses dados rapidamente para an√°lise 
representa uma vantagem competitiva significativa.
:::





## Um Pipeline Completo com dplyr


```{r}
# inicia com a df (gapminder) e salva o resultado final
relatorio_expectativa <- gapminder %>%
  # Filtra apenas os dados de 2007
  filter(year == 2007) %>%
  # Agrupa por continente
  group_by(continent) %>%
  # Calcula estat√≠sticas por continente
  summarize(
    expectativa_media = mean(lifeExp),
    expectativa_minima = min(lifeExp),
    expectativa_maxima = max(lifeExp),
  ) %>%
  # Ordena do maior para o menor
  arrange(desc(expectativa_media))

# Visualiza o resultado final
relatorio_expectativa
```





## Tabelas Profissionais 

::: {.callout-note icon=false}
## Limita√ß√µes das Data Frames Brutas em Relat√≥rios Profissionais

- As data frames produzidas pelos pipelines do dplyr s√£o excelentes 
para **an√°lise**, mas n√£o s√£o adequadas para **apresenta√ß√£o** em 
relat√≥rios profissionais.

- A linguagem R oferece v√°rias solu√ß√µes para esta limita√ß√£o:

    - O pacote **kableExtra** (que veremos a seguir) para relat√≥rios HTML e PDF
    - O pacote **gt** para tabelas altamente personaliz√°veis

- Estes pacotes permitem transformar dados anal√≠ticos em tabelas com 
qualidade profissional, incluindo:

    - t√≠tulo, nomes das colunas e notas formatadas
    - destaque visual para informa√ß√µes importantes  
    - personaliza√ß√£o de cores, bordas e estilos de texto
    - entre outras.

:::





## O Pacote kableExtra

::: {.callout-note icon=false}
## Transformando tabelas b√°sicas em apresenta√ß√µes profissionais

- O pacote `kableExtra` estende as funcionalidades da fun√ß√£o b√°sica 
`kable` do R, permitindo a cria√ß√£o de tabelas com qualidade de publica√ß√£o.

- Foi desenvolvido para trabalhar com tabelas em documentos HTML e 
PDF (LaTeX).

- Permite formatar tabelas para relat√≥rios profissionais, artigos 
acad√™micos e apresenta√ß√µes.

- √â extremamente √∫til na Fase 6 do CRISP-DM (Implanta√ß√£o), quando
precisamos comunicar resultados de forma clara e atrativa.
:::





## Sintaxe B√°sica do kableExtra

::: {.callout-tip}
## Fluxo b√°sico com kableExtra 

```{r}
#| eval: false

#  inicie com uma data frame
tabela_formatada <- dados %>%
  # Transforme a data frame em tabela b√°sica
  kable(
    caption = "T√≠tulo da Tabela",
    col.names = c("Nome1", "Nome2"), # Renomear colunas
    digits = 2,                      # Casas decimais
    format.args = list(decimal.mark = ",", big.mark = ".") # Define v√≠rgula como separador decimal e ponto como separador de milhares
  ) %>%
  # Adicionar estilos
  kable_styling(
    bootstrap_options = c("striped", "hover"),
    full_width = FALSE,
    position = "center"
  )
```

- **kable()**: Converte a data frame em tabela b√°sica
- **kable_styling()**: Aplica estilos visuais √† tabela
- Outros elementos podem ser adicionados em sequ√™ncia com o pipe (`%>%`)
:::



::: {.callout-tip}
## Pipeline para relat√≥rios profissionais

Em projetos de an√°lise de dados completos, o fluxo geralmente √©:

1. **Preparar dados** com  `tidyr` e `dplyr`
2. **Analisar dados** com `dplyr` (filter, select, group_by, etc.)
3. **Visualizar resultados** com `ggplot2` (gr√°ficos) e `kableExtra` (tabelas)

Um pipeline completo pode √© similar com:

```{r}
#| eval: false

# Pipeline completo de an√°lise at√© apresenta√ß√£o
dados_brutos %>%
  # Fase de limpeza e prepara√ß√£o
  filter(...) %>%
  select(...) %>%
  mutate(...) %>%
  
  # Fase de an√°lise e agrega√ß√£o
  group_by(...) %>%
  summarize(...) %>%
  
  # Fase de apresenta√ß√£o em tabela
  kable(...) %>%
  kable_styling(...) %>%
  column_spec(...)
```

Este fluxo integrado representa as fases 3, 4 e 6 do CRISP-DM.
:::




## Resumo

::: {.callout-tip}
## Pacote kableExtra

1. **Para que serve**: Transformar tabelas de dados simples em 
tabelas profissionais para relat√≥rios, apresenta√ß√µes e publica√ß√µes.

2. **Sintaxe b√°sica**:

```{r style="font-size: 1em;"}
#| eval: false
dados %>%
  kable(...) %>%
  kable_styling(...) %>%
  ... outras personaliza√ß√µes ...
```

3. **Fun√ß√µes principais**:

   - `kable()`: Converte data frame em tabela base
   - `kable_styling()`: Aplica estilos gerais √† tabela
   - `column_spec()` e `row_spec()`: Personaliza√ß√µes espec√≠ficas
   - `footnote()`: Adiciona notas de rodap√©

4. **Integra√ß√µes estrat√©gicas**:

   - Ideal no final de pipelines dplyr para apresentar resultados
   - Complementar aos gr√°ficos do ggplot2 em relat√≥rios

5. **Benef√≠cios em Administra√ß√£o**:

   - Eleva a qualidade visual de relat√≥rios gerenciais
   - Facilita a comunica√ß√£o de insights de dados para gestores
   - Permite destacar KPIs e m√©tricas cr√≠ticas para tomada de decis√£o
:::





## Tabela com o Pacote KableExtra


```{r}
#| label: tbl-1
#| tbl-cap: "Expectativa de Vida (em anos) por Continente (2007)"
#| echo: true

# inicia com a df contendo o resultado do pipeline
relatorio_expectativa %>%
  # Converte a df em uma tabela kable (tabela b√°sica HTML/LaTeX)
  kable(
    # Renomeia as colunas para portugu√™s
    col.names = c(
      "Continente", "Expectativa M√©dia", "Expectativa M√≠nima", "Expectativa M√°xima"
    ),
    # Formata os n√∫meros com 1 casa decimal
    digits = 1,
    # v√≠rgula como separador decimal
    format.args = list(decimal.mark = ",")
  ) %>%
  # Adiciona estilo √† tabela para melhorar o visual
  kable_classic(
    # tamanho da fonte
    font_size = 25,
    # Impede que a tabela ocupe toda a largura dispon√≠vel
    full_width = FALSE,
    # # Centraliza a tabela
    position = "center"
  ) %>%
  # Aplica formata√ß√£o espec√≠fica √† coluna da expectativa m√©dia
  column_spec(
    # Aplica a formata√ß√£o √† segunda coluna (Expectativa M√©dia)
    2,
    # Coloca o texto em negrito para melhor destaque
    bold = TRUE,
    # Define a cor dos n√∫meros como branco
    color = "white",
    # Aplica um gradiente de cores ao fundo das c√©lulas
    background = spec_color(
      # A expectativa_media determinar a intensidade das cores
      relatorio_expectativa$expectativa_media,
      # in√≠cio do gradiente com intensidade alta
      begin = 0.9,
      # fim do gradiente com intensidade baixa
      end = 0.1,
      # paleta de cores "viridis" (azul-verde-amarelo)
      option = "viridis",
      # 1 = valores mais altos recebem cores mais intensas
      direction = 1
    )
  )
```




## Exemplo T√≠pico em Administra√ß√£o (Wide)

::: {.callout-note icon=false}
## Dados de Vendas Mensais por Categoria e Produto

```{r}
# formato t√≠pico de planilhas gerenciais
dados_vendas_wide <- tribble(
  ~produto, ~categoria, ~Jan, ~Fev, ~Mar, ~Abr, ~Mai, ~Jun,
  "Notebook Pro", "Eletr√¥nicos", 45000, 38000, 42000, 47000, 52000, 49000,
  "Smartphone X", "Eletr√¥nicos", 38000, 41000, 40000, 39000, 45000, 50000,
  "Monitor 24pol", "Inform√°tica", 22000, 19000, 23000, 25000, 24000, 26000,
  "Mouse Gamer", "Inform√°tica", 12000, 14000, 13500, 15000, 16000, 17500,
  "Mesa Office", "Mobili√°rio", 28000, 25000, 24000, 26500, 27000, 29000,
  "Cadeira Ergo", "Mobili√°rio", 35000, 32000, 38000, 36000, 39000, 42000
)

# Visualizando os dados no formato amplo (wide)
dados_vendas_wide
```
:::




## Transformando para Analise de Dados

::: {.callout-note icon=false}
## Aplicando pivot_longer para organizar os dados

```{r}
# Transformando os dados para o formato longo (tidy)
dados_vendas_longo <- dados_vendas_wide %>%
  pivot_longer(
    cols = Jan:Jun, # colunas que ser√£o transformadas em valores de mes
    names_to = "mes", # nome da nova coluna
    values_to = "valor_vendas" # nome de outra nova coluna para as vendas
  )

# Visualizando o resultado
dados_vendas_longo
```

**Agora os dados est√£o organizados para an√°lise**:

- Cada linha representa uma combina√ß√£o √∫nica de produto, categoria e m√™s
- As vendas mensais est√£o em uma √∫nica coluna (valor_vendas)
- A informa√ß√£o do m√™s est√° em uma coluna pr√≥pria (mes)
:::




## An√°lise 1 - N√≠vel B√°sico

::: {.callout-note icon=false}
## An√°lise da Receita Bruta Mensa de Vendas

```{r}
# pipeline de an√°lise
receita_bruta_mes <- dados_vendas_longo %>%
  group_by(mes) %>%
  summarize(vendas_total = sum(valor_vendas)) %>%
  arrange(desc(vendas_total))

# visualiza o resultado
receita_bruta_mes
```
:::




## An√°lise 2 - N√≠vel B√°sico

::: {.callout-note icon=false}
## An√°lise das Vendas Mensais de um Produto Espec√≠fico

```{r}
# pipeline de an√°lise
vendas_mensais_notebookpro <- dados_vendas_longo %>%
  filter(produto == "Notebook Pro") %>%
  select(produto, mes, valor_vendas) %>%
  arrange(mes)

# visualiza o resultado
vendas_mensais_notebookpro
```
:::




## An√°lise 3 - N√≠vel B√°sico

::: {.callout-note icon=false}
## An√°lise das Vendas Totais por Categoria e M√™s

```{r}
# pipeline de an√°lise
vendas_totais_categoria_mes <- dados_vendas_longo %>%
  group_by(categoria, mes) %>%
  summarize(vendas_totais = sum(valor_vendas)) %>%
  arrange(desc(vendas_totais))

# visualiza o resultado
vendas_totais_categoria_mes
```
:::




## An√°lise 4 - N√≠vel Intermedi√°rio

::: {.callout-note icon=false}
## An√°lise do Desempenho mensal por produto

```{r}
# pipeline
desempenho_mensal_produto <- dados_vendas_longo %>%
  group_by(produto) %>%
  summarize(
    vendas_total = sum(valor_vendas),
    vendas_media = mean(valor_vendas),
    vendas_min = min(valor_vendas),
    vendas_max = max(valor_vendas)
  ) %>%
  arrange(desc(vendas_total))

# visualiza o resultado
desempenho_mensal_produto
```
:::




## An√°lise 4 - Tabela para Apresenta√ß√£o


```{r}
#| label: tbl-4
#| tbl-cap: "Desempenho mensal de Vendas por produto"
#| echo: true

# Formata a tabela de desempenho por produto com kableExtra
desempenho_mensal_produto %>%
  kable(
    # Renomeia as colunas para melhor apresenta√ß√£o
    col.names = c(
      "Produto", 
      "Vendas Totais (R$)", 
      "M√©dia Mensal (R$)", 
      "Venda M√≠nima (R$)", 
      "Venda M√°xima (R$)"
    ),
    # Formata n√∫meros com 2 casas decimais
    digits = 2,
    # Define v√≠rgula como separador decimal e ponto como separador de milhares
    format.args = list(decimal.mark = ",", big.mark = ".", nsmall = 2)
  ) %>%
  # Aplica um estilo cl√°ssico e limpo
  kable_classic_2(
    # Ajusta o tamanho da fonte
    font_size = 18,
    # Define largura para se ajustar melhor ao slide
    full_width = TRUE,
    # Centraliza a tabela
    position = "center"
  ) %>%
  # Destaca as colunas de valores em negrito
  column_spec(2:5, bold = TRUE) %>% 
  # Destaca as 3 primeiras linha da tabela
  row_spec(1:3, bold = T, color = "white", background = "#011f4b")
```




## An√°lise 5 - N√≠vel Intermedi√°rio

::: {.callout-note icon=false}
## Identificando meses de pico de vendas para cada categoria

```{r}
# Pipeline para identificar m√™s de melhor desempenho por categoria
meses_pico_categoria <- dados_vendas_longo %>%
  # Agrupa por categoria e m√™s
  group_by(categoria, mes) %>%
  # Calcula as vendas totais
  summarize(vendas_totais = sum(valor_vendas)) %>%
  # Filtra para o m√™s de maior venda
  filter(vendas_totais == max(vendas_totais)) %>%
  # Ordena o resultado pelas vendas totais
  arrange(desc(vendas_totais))

# visualiza o resultado 
meses_pico_categoria
```
:::





## An√°lise 6 - N√≠vel Intermedi√°rio

::: {.callout-note icon=false}
## Identificando meses de pior venda para cada categoria

```{r}
# Pipeline para identificar m√™s de pior desempenho por categoria
meses_pior_categoria <- dados_vendas_longo %>%
  # Agrupa por categoria e m√™s
  group_by(categoria, mes) %>%
  # Calcula as vendas totais
  summarize(vendas_totais = sum(valor_vendas)) %>%
  # Filtra para o m√™s de menor venda
  filter(vendas_totais == min(vendas_totais)) %>%
  # Ordena o resultado pelas vendas totais
  arrange(desc(vendas_totais))

# visualiza o resultado 
meses_pior_categoria
```
:::





### Fun√ß√µes which.max() e which.min()

::: {.callout-note icon=false}
## Localizando posi√ß√µes de valores m√°ximos e m√≠nimos

As fun√ß√µes `which.max()` e `which.min()` s√£o extremamente √∫teis em 
an√°lise de dados:

- `which.max(x)`: Retorna a **posi√ß√£o** (√≠ndice) do valor m√°ximo no vetor `x`
- `which.min(x)`: Retorna a **posi√ß√£o** (√≠ndice) do valor m√≠nimo no vetor `x`

**Exemplo simples:**

```{r}
# Vetor de valores
vendas_mensais <- c(120, 150, 140, 160, 110, 130)

# Qual a posi√ß√£o do valor m√°ximo?
posicao_max <- which.max(vendas_mensais)
posicao_max

# Qual o valor m√°ximo?
vendas_mensais[posicao_max]

# Supondo que temos nomes para os meses
nomes_meses <- c("Jan", "Fev", "Mar", "Abr", "Mai", "Jun")

# Em qual m√™s ocorreu a venda m√°xima?
mes_maior_venda <- nomes_meses[which.max(vendas_mensais)]
mes_maior_venda
```

Estas fun√ß√µes s√£o perfeitas para encontrar **quando** ocorreram eventos 
importantes nos seus dados (m√°ximos, m√≠nimos, picos) em vez de apenas 
quais foram os valores.
:::




## An√°lise 7 - N√≠vel Avan√ßado

::: {.callout-note icon=false}
## Identificando os Meses de Maior e Menor Venda por Produto

```{r}
# Pipeline de an√°lise para identificar os meses de pico e vale por produto
resumo_comparativo_produto <- dados_vendas_longo %>%
  # Agrupa os dados por produto para analisar cada um separadamente
  group_by(produto) %>%
  # Para cada produto, calculamos:
  summarize(
    # 1. Qual o m√™s da maior venda:
    # - which.max(valor_vendas) encontra a POSI√á√ÉO da maior venda
    # - mes[which.max(valor_vendas)] seleciona o nome do m√™s de maior venda
    melhor_mes = mes[which.max(valor_vendas)],

    # 2. Qual foi o valor da maior venda
    maior_venda = max(valor_vendas),

    # 3. Qual o m√™s da menor venda (mesma l√≥gica do melhor m√™s)
    pior_mes = mes[which.min(valor_vendas)],

    # 4. Qual foi o valor da menor venda
    menor_venda = min(valor_vendas)
  )

# Visualiza o resultado
resumo_comparativo_produto
```

**Explica√ß√£o do c√≥digo:**

1. Primeiro agrupamos por produto para realizar a an√°lise para 
   cada item
   
2. A fun√ß√£o `which.max(valor_vendas)` retorna a posi√ß√£o (√≠ndice) do 
  valor m√°ximo
  
3. Ao usar `mes[which.max(valor_vendas)]`, extra√≠mos o nome do m√™s na 
   posi√ß√£o com valor m√°ximo
   
4. Este tipo de an√°lise √© essencial para identificar padr√µes sazonais 
de produtos

Este relat√≥rio permite identificar rapidamente quais meses foram melhores 
e piores para cada produto - informa√ß√£o valiosa para planejamento de 
estoque e promo√ß√µes.

Assim, esta an√°lise permite otimizar o planejamento de estoque e 
a√ß√µes promocionais sazonais.
:::





## An√°lise 7 - Tabela para Apresenta√ß√£o


```{r}
#| label: tbl-7
#| tbl-cap: "Meses de Maior e Menor Venda por Produto"
#| echo: false
#| eval: true
#| html-table-processing: none

# Formata a tabela comparativa com kableExtra
resumo_comparativo_produto %>%
  kable(
    # Renomeia as colunas para melhor apresenta√ß√£o
    col.names = c(
      "Produto", 
      "Melhor M√™s", 
      "Maior Venda (R$)", 
      "Pior M√™s", 
      "Menor Venda (R$)"
    ),
    # Formata n√∫meros com 2 casas decimais
    digits = 2,
    # Define v√≠rgula como separador decimal e ponto como separador de milhares
    format.args = list(decimal.mark = ",", big.mark = ".", nsmall = 2)
  ) %>%
  # Aplica um estilo cl√°ssico e limpo
  kable_paper(
    # Ajusta o tamanho da fonte
    font_size = 22,
    # Define largura para se ajustar melhor ao slide
    full_width = FALSE,
    # Centraliza a tabela
    position = "center"
  ) %>%
  # Destaca as colunas de valores monet√°rios em negrito
  column_spec(c(3, 5), bold = TRUE) %>% 
  # Destaca a quarta linha da tabela
  row_spec(4, bold = T, color = "white", background = "#D7261E")
```




## Dados em Seu Ambiente de Trabalho

::: {.callout-tip}
## Reflex√£o

Considere os dados com os quais voc√™ j√° trabalha ou espera trabalhar 
em sua carreira:

1. **Que tipos** de dados desorganizados voc√™ encontra ou espera encontrar?

   - Relat√≥rios gerenciais? 
   - Planilhas financeiras?
   - Arquivos de sistemas ERP/CRM?

2. **Como** esses dados poderiam ser melhor organizados para an√°lise?

   - Quais s√£o as verdadeiras "observa√ß√µes" nesses dados?
   - Quais s√£o as verdadeiras "vari√°veis"?

3. **Quais insights de neg√≥cio** voc√™ poderia extrair se esses dados 
estivessem organizados adequadamente?

   - Padr√µes temporais?
   - Compara√ß√µes entre unidades/produtos/regi√µes?
   - Correla√ß√µes entre diferentes m√©tricas?

4. **Como voc√™ aplicaria** o conhecimento desta aula em um exemplo 
concreto do seu interesse profissional?

- **Dica para sua carreira**: Manter um reposit√≥rio pessoal de c√≥digos R 
para transforma√ß√µes comuns que voc√™ encontra no seu trabalho pode 
economizar horas de trabalho repetitivo no futuro.
:::
































