---
title: "Introdução à Linguagem R"
description: | 
  Um tutorial básico sobre a linguagem R para Ciência de Dados.
lang: "pt"
date: "2024-07-07"
toc: true
number-sections: true
toc-depth: 2
toc-location: left
highlight-style: pygments
author:
  - name: Prof. Dr. Washington S. da Silva 
    affiliation: IFMG - Campus Formiga - Mestrado Profissional em Administração.
    affiliation-url: https://www.formiga.ifmg.edu.br/mestrado
crossref:
  fig-title: '**Fig.**'
  fig-labels: arabic
execute: 
  echo: true
  warning: false
  message: false
bibliography: referencias.bib
csl: associacao-brasileira-de-normas-tecnicas-ipea.csl
categories: [R, Reprodutibilidade]
---

```{r}
#| label: setup
#| echo: false

# carrega pacotes
library(here)
library(tidyverse)
library(gapminder)
library(kableExtra)
library(PerformanceAnalytics)
```


![](img/Rlogo.png){width=30% fig-align="center"}


# Introdução {#sec-introducao}


::: {.callout-note icon="false"}
## Objetivos

- Este tutorial é destinado aos estudantes do bacharelado em Administração 
e aos mestrandos do Mestrado Profissional em Administração do 
IFMG - Campus Formiga.

- Também é útil para administradores, economistas, contabilistas, 
auditores e outros profissionais que desejam utilizar ferramentas 
modernas para criar relatórios e outros produtos de forma reproduzível 
e auditável.

- O objetivo principal é proporcionar uma compreensão sólida da linguagem 
R, desde seus fundamentos até aplicações em análise de dados, 
permitindo que alunos de graduação, mestrandos e demais profissionais 
e pesquisadores interessados desenvolvam habilidades para criar análises 
reproduzíveis e auditáveis. Embora o foco inicial seja a Ciência de Dados 
aplicada à Administração, o conteúdo foi elaborado para ser útil 
em diversas áreas do conhecimento.
:::




::: {.callout-note icon="false"}
## Instalando a Linguagem R 4.4.1

1.  Acesse [https://cloud.r-project.org/](https://cloud.r-project.org/){target="_blank"}

2.  Selecione o sistema operacional, clicando em **Download R for Windows** 
por exemplo.

3.  Na página seguinte clique em **base**.

4.  Clique em **Download R-4.4.3 for Windows**. 

5.  Feito o download basta ir clicando em próximo/next até a instalação 
ser concluída.
:::



::: {.callout-note icon="false"}
## RStudio: Ambiente de Desenvolvimento para R

- Para uma experiência de programação mais produtiva com R, recomenda-se 
fortemente o uso do RStudio, um IDE (Ambiente de Desenvolvimento Integrado) 
especialmente projetado para trabalhar com a linguagem R.

- O RStudio oferece diversas funcionalidades que facilitam o aprendizado 
e uso da linguagem, como editor de código com destaque de sintaxe, projetos 
Rstudio, integração com Git e suporte nativo ao sistema Quarto.

- Para instalar e configurar o RStudio, consulte nosso [Tutorial sobre RStudio](https://washingtonsilva.github.io/tutorials/rstudio/){target="_blank"}, 
onde são apresentadas instruções detalhadas para iniciantes.

- Embora seja perfeitamente possível utilizar R com outros IDEs, a 
combinação (R + RStudio) facilita e potencializa significativamente a 
experiência de aprendizado e desenvolvimento.
:::




::: {.callout-note icon="false"}
## O que é R?

- R é um ambiente ou sistema para computação estatística e gráfico. 

- Este sistema é composto por duas partes: a própria **linguagem** R (que é o 
que a maioria das pessoas querem dizer quando falam sobre R) e um 
**ambiente de tempo de execução** (*runtime environment*).

- R é uma linguagem **interpretada**, o que significa que os usuários acessam 
suas funções por meio de um interpretador de linha de comando.

- Ao contrário de linguagens como Python e Java, R não é uma linguagem 
de programação de uso geral. 

- Em vez disso, R é considerada uma linguagem de domínio específica (DSL), o 
que significa que suas funções e uso foram projetados para uma área 
específica de uso ou domínio.

- No caso de R, o domínio e a computação estatística. Por extensão, R é 
comumente usada para todos os tipos de tarefas de ciência de dados.

- A linguagem R está equipada com um grande conjunto de funções internas 
para a manipulação, análise e visualização de dados. 

- Além das funções internas da linguagem, existem inúmeros pacotes (como os
módulos de Python) que estendem as capacidades da linguagem.
:::




::: {.callout-note icon="false"}
## Origens da Linguagem R

**A linguagem S**

- A linguagem S foi desenvolvida em meados da década de 1970 por John Chambers 
no lendário Bell Labs. O objetivo era oferecer uma abordagem interativa 
para a computação estatística, que fosse fácil de usar e tornasse as tarefas 
de análise de dados mais fáceis e rápidas.

- Em uma entrevista de 2013, Chambers observou que a equipe do Bell Labs 
queria que as pessoas começassem em um ambiente interativo, onde não 
pensassem em si como programadores. Então, à medida que 
suas necessidades se tornaram mais claras e sua sofisticação aumentasse, 
eles dseriam capazes de se orientar gradualmente para a programação 
com a linguagem S.

- A filosofia geral de S era muito semelhante à de R: oferecer um ambiente 
de software que facilitasse a programação computacional e a análise 
estatística, que qualquer um possa aprender a usar.

- Como R, S também pode ser usada para escrever programas mais longos 
centrados em tarefas estatísticas. Ao contrário de R, no entanto, S e 
sua iteração posterior, *S-Plus*, eram produtos licenciados, o que 
significa que tinham que ser comprados de uma empresa.

- Portanto, é importante notar que a linguagem R é um dialeto da 
linguagem S.

**Sintáxe e Semântica**

- Os linguistas usam os termos sintaxe e semântica para descrever elementos 
de linguagens naturais, e os cientistas da computação também adotaram 
esses termos para linguagens de programação.

- Na programação de computadores, a sintaxe se refere às regras que ditam 
a 'ortografia' e a 'gramática' de uma linguagem, enquanto a semântica 
se refere a como os dados ou comandos de uma linguagem são apresentados.

- A sintaxe de R era muito semelhante à de S em seus primeiros anos. Isso 
tornou mais fácil para as pessoas que usavam *S-Plus* mudar para R, o que 
desempenhou um papel fundamental na eventual popularidade de R na academia. 

- A semântica de R, no entanto, está mais próxima da linguagem Scheme, 
uma linguagem de programação funcional.

**R é uma linguagem de baixo ou alto nível?**

- R é considerada uma linguagem de programação de alto nível. Essa 
classificação é baseada em seu nível de abstração da linguagem 
de máquina. 

- Ao contrário das linguagens de baixo nível que exigem conhecimento 
aprofundado da memória e dos processos do computador, linguagens de 
alto nível como R são projetadas para serem facilmente compreendidas 
e escritas por humanos, tornando-as mais acessíveis para estatísticos, 
analistas de dados e pesquisadores.
:::




::: {.callout-note icon="false"}
## Um Breve Histórico da Linguagem R

- **1991**: Os professores e estatísticos Ross Ihaka e Robert Gentleman 
começam a trabalhar em um novo dialeto da linguagem S como um projeto de 
pesquisa para o Departamento de Estatística da Universidade de Auckland 
na Nova Zelândia.

- **1993**: O primeiro anúncio de R chega ao público através do arquivo de 
dados StatLib e da lista de discussão s-news.

- **1995**: O estatístico Martin Mächler convence os criadodes de R a lançar 
a linguagem sob uma licença pública geral GNU, tornando R gratuita e 
de código aberto. Ihaka e Gentleman lançam seu artigo seminal apresentando 
R ao mundo.

- **1997**: O R Core Team foi formado, este grupo é o único com acesso ao 
código-fonte R. No mesmo ano, foi criada a 
*Comprehensive R Archive Network* (CRAN). Este repositório de pacotes R 
ajuda os profissionais em inúmeras tarefas.

- **2000**: R versão 1.0.0 foi lançada ao público.

- **Março de 2024**: Estamos atualmente na versão R 4.3.3
:::




::: {.callout-note icon="false"}
## Por que usar a linguagem R?

- **Gratuito e de código aberto**: Diferentemente de softwares estatísticos 
proprietários, R é completamente gratuito e seu código-fonte é aberto, 
permitindo total transparência e personalização.

- **Especialmente projetado para análise estatística e ciência de dados**: 
Enquanto outras linguagens podem ser adaptadas para estas tarefas, R foi 
concebida especificamente para computação estatística e visualização 
de dados.

- **Ampla comunidade acadêmica e profissional**: R possui uma comunidade 
ativa de usuários que contribuem constantemente com novos pacotes, métodos e 
soluções para problemas complexos.

- **Integração com o sistema Quarto**: Perfeita compatibilidade com o 
sistema de publicação Quarto, permitindo a criação de documentos, 
apresentações e websites dinâmicos e reproduzíveis.

- **Ecossistema Tidyverse**: O conjunto de pacotes Tidyverse fornece 
uma gramática consistente para manipulação, visualização e modelagem 
de dados, especialmente útil para iniciantes.

- **Excelência em visualização de dados**: Pacotes como ggplot2 permitem 
criar visualizações estatísticas sofisticadas e personalizáveis.

- **Relevância no mercado**: Profissionais com conhecimento em R são 
valorizados em setores como finanças, consultorias, pesquisa de mercado 
e análise de negócios.

- **Reprodutibilidade científica**: R facilita a implementação de 
práticas de ciência reproduzível, essencial para pesquisas acadêmicas 
e relatórios corporativos auditáveis.

- **Versatilidade em tipos de análise**: Desde estatísticas descritivas 
simples até modelos complexos de machine learning e econometria aplicada, 
R oferece ferramentas para diversos níveis de análise.

- **Documentação extensa**: Ampla disponibilidade de documentação, 
tutoriais, livros e recursos online, facilitando o aprendizado contínuo.
:::


::: {.callout-note icon="false"}
## Vídeo sobre R

- Para finalizar esta introdução, assista o vídeo a seguir sobre a 
linguagem R disponibilizado pelo 
[R Consortium](https://r-consortium.org){target="_blank"}: 

{{< video https://www.youtube.com/watch?v=XcBLEVknqvY
    title="What is R?"
    aspect-ratio="21x9" 
>}}
:::



::: {.callout-note icon="false"}
## Próximos Passos

Nas próximas seções do tutorial vamos explorar os conceitos básicos 
da linguagem R, que servirão como alicerce para os tópicos posteriores. 
Compreender esses fundamentos é essencial antes de avançarmos para 
análises mais complexas.
:::




# Objetos e Variáveis em R

Em R, os termos "variável" e "objeto" são frequentemente usados de 
forma intercambiável, o que pode causar confusão inicial, especialmente 
para quem já possui experiência com outras linguagens de programação. 
Esta seção esclarece essa terminologia para facilitar seu aprendizado.

::: {.callout-note icon="false"}
## A Filosofia "Tudo é um Objeto" em R

R segue uma filosofia fundamental: **tudo que existe em R é um objeto**. 
Isso significa que todos os elementos que você manipula — desde 
números simples até funções complexas — são tratados como objetos. 

Esta abordagem difere de muitas outras linguagens de programação que 
fazem distinção clara entre "variáveis primitivas" (como números) e 
"objetos" (estruturas mais complexas).

Quando criamos algo em R usando um operador de atribuição (`<-`), 
estamos essencialmente:

1. Criando um objeto na memória do computador
2. Atribuindo um nome a esse objeto para referenciá-lo posteriormente

Por exemplo, em `idade <- 25`, criamos um objeto do tipo numérico 
com valor 25 e o nomeamos como "idade". Este nome funciona como uma 
etiqueta que nos permite acessar e manipular o objeto.
:::

::: {.callout-tip}
## Por que usarei "variável" e "objeto" de forma intercambiável?

Por questões de clareza e para facilitar seu aprendizado:

- Utilizarei o termo **variável** principalmente quando falarmos de 
valores simples que "variam", como números, textos ou valores lógicos. 
Este termo é mais intuitivo para iniciantes e comum em estatística 
e análise de dados.

- Utilizarei o termo **objeto** quando precisarmos enfatizar a 
natureza mais complexa de algumas estruturas em R, como data frames, 
listas, funções ou quando discutirmos conceitos mais avançados.

- Em muitos contextos, usarei ambos os termos de forma intercambiável, 
refletindo a prática comum na comunidade R.

Esta flexibilidade terminológica espelha a documentação oficial da 
linguagem R e a literatura sobre a linguagem, preparando você 
para diferentes materiais que poderá encontrar em sua jornada 
de aprendizado.
:::



::: {.callout-note icon="false"}
## Uma Analogia Útil

Imagine uma biblioteca onde cada livro é um "objeto" de dados:

- O **conteúdo do livro** representa os dados ou valores armazenados.

- O **título na lateral** representa o nome da variável

- As **prateleiras e estantes** representam a memória do computador

- O **catálogo da biblioteca** equivale ao ambiente R, que mantém 
registro de onde cada objeto está armazenado

Quando você cria uma variável como `receita <- 5000`, é como se estivesse 
colocando um novo livro (com o conteúdo "5000") na biblioteca e 
rotulando sua lateral como "receita" para poder encontrá-lo depois.
:::


Este entendimento sobre variáveis e objetos em R estabelece uma base 
conceitual importante antes de mergulharmos nos tipos específicos de 
dados e em como manipulá-los para análises eficazes.





# Variáveis e Atribuição de Valores

Em R, a atribuição de valores a variáveis é fundamental para armazenar e 
manipular dados. Por exemplo, podemos criar variáveis para armazenar 
informações financeiras, como receitas, custos e lucros, que são 
essenciais para análises em Administração.

```{r}
# Exemplo: Atribuição de valores a variáveis
receita_mensal <- 850000  # Receita mensal da empresa
custos_mensais <- 500000  # Custos mensais

# Cálculo do lucro
lucro_mensal <- receita_mensal - custos_mensais  
lucro_mensal
```

Todas as instruções R com as quais criamos variáveis ou objetos têm 
o mesmo formato:

```{r}
#| eval: false
#| echo: true

nome_do_objeto <- valor
```

Lemos esse código como: "*valor é atribuído a nome_objeto*"

Em R, podemos atribuir informações às variáveis (ou objetos) utilizando 
os seguintes operadores de atribuição:

```{r}
#| label: op-atribuicao
#| echo: true

# Diferentes formas de atribuição em R
# Mesmo resultado, estilos diferentes

# Operador recomendado (<-) 
receita_mensal <- 850000
receita_mensal

# Alternativa (=), funciona, mas menos 
# recomendado
lucro_operacional = 320000
lucro_operacional
```

Em R, como em todas as linguagens, fazemos muitas atribuições de 
valores a variáveis, e não é agradável digitar o operador manualmente. 
Assim, o RStudio oferece um atalho de teclado simples para inserir 
o operador `<-`:

- Atalho do RStudio: `Alt + -` (Windows/Linux) ou `Option + -` (Mac)

- Observe que o RStudio automaticamente envolve `<-` 
com **espaços**, o que é uma boa prática de formatação de código.

- Códigos sem espaços são difíceis de ler compare: 

`lucro<-receita-custos` versus 

`lucro <- receita - custos`


::: {.callout-note icon="false"}
## Boas Práticas para Escrever Códigos R

Nomes de variáveis devem começar com uma letra e podem conter 
`letras`, `números`, `_` e `.`

É importante criar nomes de objetos **simples e descritivos** que 
representem claramente seu conteúdo. Em Administração, é comum 
trabalhar com dados financeiros, de desempenho ou de mercado, 
então use nomes que facilitem a compreensão do código.

**Exemplos de boas práticas**:

```{r}
#| eval: false

# Margem bruta da empresa
margem_bruta <- 0.35  

# Fluxo de caixa operacional
fluxo_caixa_operacional <- receita - custos  
```

**Estilos de nomenclatura**:

- **snake_case**: `margem_bruta`, `fluxo_caixa_operacional`
- **CamelCase**: `MargemBruta`, `FluxoCaixaOperacional`

Escolha um estilo e mantenha a consistência em todo o código.
:::


::: {.callout-warning}
## Práticas a evitar

Evite os seguintes erros comuns:

1. **Nomes genéricos**:

- Ruim: `dados`, `resultado`, `x`
- Melhor: `receita_anual`, `lucro_liquido`


2. **Nomes muito longos**:

- Ruim: `calculo_da_margem_de_contribuicao_ajustada`
- Melhor: `margem_contribuicao`


3. **Espaços nos nomes**:

- Ruim: `margem bruta <- 0.35` (causa erro)
- Melhor: `margem_bruta <- 0.35`


4. **Nomes começando com números**:

- Ruim: `1trimestre <- "Janeiro-Março"` (inválido)
- Melhor: `trimestre1 <- "Janeiro-Março"`


5. **Sobrescrever funções existentes**:

- Ruim: `mean <- 10` (sobrescreve a função `mean()`)
- Melhor: `media <- 10`
:::


::: {.callout-tip}
## Como Imprimir Informações sobre Objetos em R

Em R, existem algumas formas simples e eficazes de exibir 
informações sobre objetos ou variáveis. Esses métodos são ideais 
para visualizar valores, depurar código ou criar saídas personalizadas. 
Abaixo estão as principais formas:

**1. Usando** `print()`

A função `print()` é a maneira mais básica de exibir o conteúdo de 
um objeto:

```{r}
# Exemplo: Usando print()
receita <- 850000.50
print(receita)  # Exibe o valor da variável
```

**2. Imprimindo diretamente no console**

Em R, você pode exibir o conteúdo de um objeto simplesmente 
digitando seu nome no console. Isso chama automaticamente 
a função `print()` implicitamente:

```{r}
# digitar o nome do objeto exibe seu valor
receita  
```

**3. Usando a função** `cat()` 

A função `cat()` permite exibir informações de forma mais 
personalizada, combinando texto e valores. É útil para criar 
mensagens ou relatórios simples.

```{r}
# a funçaão cat() combina texto e valor
cat("A receita mensal é:", receita)  
```

**Resumo**:

- Use `print()` para exibir valores de forma explícita.

- Digite o nome do objeto diretamente no console para exibir 
  seu valor de forma rápida.
  
- Use `cat()` para criar saídas personalizadas, combinando 
  texto e valores.
:::





# Tipos Atômicos de Dados

Em R, os dados são armazenados em diferentes tipos atômicos (básicos), 
cada um com características específicas. A @tbl-1 mostra os principais 
tipos.

Tipo          | Classe      | Descrição                          
------------- | ----------- | ----------------------------------
`double`      | `numeric`   | um vetor contendo valores reais (números com casas decimais)
`integer`     | `numeric`   | um vetor contendo valores inteiros (números sem casas decimais)
`character`   | `character` | um vetor contendo valores de texto (caracteres)
`logical`     | `logical`   | um vetor contendo valores lógicos (`TRUE`/`FALSE`)

: Principais Tipos {#tbl-1}


A @tbl-2 exibe alguns tipos especiais que podem aparecer em análises de 
dados. 

Tipo       | Descrição    
-----------|---------------------------------------------  
`NA`       | `Not Available`: representa dados faltantes
`NaN`      | `Not a Number`: (ex: `0 / 0`)
`Inf`      | $+ \infty$ ou $- \infty$: (ex: `1 / 0`)

: Tipos Especiais {#tbl-2}


::: {.callout-tip}
## A Importância de Conhecer Tipos e Classes de Dados

Na prática da Ciência de Dados, estima-se que analistas e cientistas 
dedicam entre 60% a 80% do tempo de um projeto à importação, limpeza 
e preparação dos dados antes de iniciar análises mais sofisticadas. 
Compreender profundamente os tipos e classes de dados em R é fundamental 
por várias razões:

- **Evita erros sutis de processamento**: Operações matemáticas em 
dados textuais ou cálculos com valores ausentes podem produzir 
resultados inesperados.

- **Otimiza o desempenho**: Estruturas de dados apropriadas melhoram 
a eficiência computacional, especialmente em conjuntos grandes.

- **Facilita transformações**: O conhecimento dos tipos permite 
conversões adequadas (como texto para número) sem perda de informação.

- **Melhora a interpretabilidade**: Identificar corretamente dados 
faltantes (`NA`), indefinidos (`NaN`), ou infinitos (`Inf`) é crucial 
para conclusões válidas.

- **Aumenta a compatibilidade**: Diferentes funções e pacotes em R 
exigem tipos específicos de dados como entrada.

O domínio dos tipos e classes de dados não é apenas uma questão 
técnica, mas um requisito fundamental para análises confiáveis 
em contextos administrativos e financeiros. Este conhecimento 
permite ao analista de dados concentrar-se mais nos insights e 
menos na correção de problemas estruturais nos dados.
:::



## Tipos `double` e `integer`

Em R, existem dois tipos principais de dados numéricos:

- **`double`**: Armazena números com casas decimais (ponto flutuante), 
ideal para valores monetários, índices financeiros, taxas percentuais 
e outras medidas que exigem precisão decimal.

- **`integer`**: Armazena números inteiros sem casas decimais, útil 
para contagens, quantidades discretas e índices em séries temporais.

Na prática de Administração e Finanças, o tipo `double` é frequentemente 
utilizado para representar valores monetários, taxas de juros ou 
indicadores financeiros, enquanto `integer` é mais comum para 
representar quantidades como número de funcionários, produtos 
vendidos ou períodos de análise.

O sufixo `L` após um número (como em `50L`) indica explicitamente 
que se trata de um valor inteiro. Na maioria das operações, R utiliza 
automaticamente o tipo mais apropriado, o que simplifica a 
programação para análises financeiras e administrativas.

```{r}
# double (números com casas decimais)
receita <- 850000.50  

# integer (números inteiros)
total_funcionarios <- 50L   

# verifica os tipos
typeof(receita)
typeof(total_funcionarios)
```


::: {.callout-tip}
## classe `numeric`

Apesar dos tipos `double` e `integer` representarem números decimais e 
inteiros de forma diferente, ambos pertencem à classe `numeric`, assim, 
na maioria das situações, você não precisa se preocupar com a possível 
diferença.

```{r}
class(receita)
class(total_funcionarios)
```

**Diferença entre** `typeof` e `class`

Em R, as funções `typeof` e `class` fornecem informações diferentes 
sobre um objeto:

- **`typeof`**: Retorna o **tipo interno** do objeto, ou seja, 
como R armazena o objeto na memória. Por exemplo:

```{r}
#| eval: false
typeof(receita)  # Retorna "double"
typeof(total_funcionarios)  # Retorna "integer"
```

- **`class`**: Retorna a **classe** do objeto, que define como R 
trata o objeto em operações e funções. Por exemplo:

```{r}
#| eval: false
class(receita)  # Retorna "numeric"
class(total_funcionarios)  # Retorna "numeric"
```

Em resumo:

- Use `typeof` para entender como R armazena o objeto internamente.
- Use `class` para entender como R trata o objeto em operações e funções.
:::



## Tipo `character`

O tipo `character` é essencial para armazenar e manipular informações 
textuais. Este tipo de dado armazena sequências de caracteres 
(texto) e é indicado por aspas simples (`'`) ou duplas (`"`).

Em contextos de Administração, o tipo `character` é utilizado 
para armazenar:

- Nomes de empresas, setores ou produtos
- Categorias em classificações de mercado
- Períodos de tempo expressos como texto (Ex: "1° Trimestre 2024")
- Códigos de identificação alfanuméricos
- Observações qualitativas

A manipulação de dados textuais é particularmente importante em 
análises de mercado, pesquisas de satisfação, classificação de 
produtos e organização de relatórios gerenciais, onde a categorização 
textual precede análises quantitativas.


```{r}
# character (texto)
instituicao <- "IFMG - Campus Formiga" 

# verifica o tipo 
typeof(instituicao)
```



## Tipo `logical` 

O tipo `logical` representa valores booleanos (`TRUE` ou `FALSE`) e é 
fundamental para operações condicionais e filtragem de dados.

Em contextos práticos de gestão e finanças, o tipo `logical` 
é utilizado para:

- Verificar condições financeiras (Ex: lucro positivo, meta atingida)
- Filtrar dados que atendem a critérios específicos
- Automatizar decisões baseadas em regras de negócio
- Sinalizar eventos importantes (Ex: inadimplência, quebra de estoque)
- Implementar validações em modelos de previsão

Os valores `TRUE` e `FALSE` devem ser escritos em maiúsculas em R, e 
podem ser abreviados como `T` e `F`, respectivamente, embora a forma 
completa seja recomendada para maior clareza do código.


```{r}
# logical (lógico, TRUE/FALSE)
lucro_positivo <- TRUE  
lucro_negativo <- FALSE

# verifica o tipo 
typeof(lucro_positivo)
typeof(lucro_negativo)
```



## Tipo Especial `NA`

O tipo especial `NA` (*Not Available*) é comum em análises de dados 
reais, onde frequentemente nos deparamos com informações ausentes. Em 
contextos de Administração e Finanças, dados faltantes podem representar:

- Vendas não realizadas em determinados períodos
- Informações contábeis pendentes
- Valores não reportados em demonstrações financeiras
- Respostas omitidas em pesquisas de mercado
- Métricas não aplicáveis a certos departamentos ou produtos

Identificar e tratar corretamente os valores `NA` é essencial para 
evitar conclusões tendenciosas. R oferece funções específicas 
como `is.na()` para detectar valores ausentes e métodos 
estatísticos para lidar com eles de forma apropriada.

```{r}
# Exemplo: Detectando valores ausentes em dados de vendas 
vendas_trimestrais <- c(150000, 165000, NA, 180000)
is.na(vendas_trimestrais) 

# calculando a média excluindo valores ausentes
mean(vendas_trimestrais, na.rm = TRUE)
```

O tratamento adequado de dados falantes é uma habilidade 
fundamental em Ciência de Dados.


## Tipo Especial `NaN` 

O valor `NaN` (*Not a Number*) ocorre quando uma operação matemática 
produz um resultado indefinido. Em contextos de gestão e finanças, 
este tipo especial pode surgir em:

- Cálculos de indicadores financeiros com divisores zero
- Operações matemáticas inválidas em modelos preditivos
- Transformações logarítmicas de valores negativos ou zero
- Raízes quadradas de números negativos em análises estatísticas

Enquanto `NA` representa dados ausentes, `NaN` indica especificamente 
um resultado numérico indefinido. Diferenciá-los é importante para 
diagnóstico de problemas em cálculos complexos, como em modelos de 
precificação de ativos ou simulações financeiras.

A função `is.nan()` permite identificar estes valores em conjuntos de dados:

```{r}
# Exemplo: Identificando resultados indefinidos em cálculos financeiros
resultados <- c(25, 0/0, 10)
is.nan(resultados)  
```



## Tipo Especial `inf`

O valor especial `Inf` (e `-Inf` para infinito negativo) ocorre 
principalmente em divisões por zero e representa valores que 
excedem os limites computacionais. Em análises administrativas 
e financeiras, este tipo pode aparecer em:

- Cálculos de taxas de crescimento a partir de valores base zero
- Razões financeiras com denominadores muito próximos a zero
- Projeções exponenciais sem restrições
- Análises de retorno sobre investimento com investimentos mínimos

Diferentemente de `NA` e `NaN`, valores `Inf` podem ser utilizados 
em operações aritméticas seguindo regras matemáticas de infinito:

```{r}
# Exemplo: Comportamento de infinito em operações
infinito_positivo <- 1/0
infinito_positivo + 1000  # Continua sendo Inf
infinito_positivo / 2     # Continua sendo Inf
```

Identificar valores infinitos é importante, por exemplo, 
em modelos financeiros, pois podem indicar problemas estruturais 
nas fórmulas utilizadas ou divisões por zero que 
comprometem a validade das análises.


::: {.callout-tip}
## Sobre Conversão entre Tipos e Classes de Dados

- Você pode estar se perguntando como converter um tipo ou 
classe de dados em outro(a) (por exemplo, transformar um texto em 
número ou vice-versa). 

- Embora R base ofereça funções como `as.numeric()`, `as.character()` e 
`as.logical()` para essas conversões, abordaremos este tópico mais 
adiante no tutorial, quando estudarmos a manipulação de dados com 
o pacote `dplyr`.

- Especificamente, aprenderemos como usar as funções `mutate()` e 
`transmute()` para realizar conversões de tipos de maneira eficiente 
e legível em conjuntos de dados estruturados. Esta abordagem se alinha 
com as práticas modernas de ciência de dados e permite transformar 
múltiplas variáveis simultaneamente dentro de um fluxo de trabalho 
analítico coerente.

- Por enquanto, foque em compreender as características e comportamentos 
dos diferentes tipos de dados apresentados nesta seção, pois este 
conhecimento fundamentará toda sua jornada na análise de dados com R.
:::




# Vetores em R {#sec-vetores}

::: {.callout-note icon="false"}
## Por que começar pelos vetores?

- Vetores são a **estrutura de dados mais básica e fundamental** da linguagem R.
- Toda variável simples em R — como um número, texto ou valor lógico — **é um vetor de comprimento 1**.
- Vetores armazenam sequências de **valores homogêneos**, ou seja, todos os elementos têm o **mesmo tipo**: numérico, lógico ou texto.
- Compreender vetores é **pré-requisito para manipular dados em estruturas mais avançadas**, como *data frames*, *tibbles* e listas.
:::


::: {.callout-tip}
## Analogia

Imagine que você está lidando com uma **planilha do Excel** onde cada coluna contém apenas um tipo de dado:

- A coluna "Receitas Mensais" possui apenas números → vetor `numeric`
- A coluna "Nome da Empresa" possui apenas textos → vetor `character`
- A coluna "Meta Atingida?" possui apenas `TRUE` ou `FALSE` → vetor `logical`

Cada coluna é, conceitualmente, **um vetor em R**: uma sequência ordenada, homogênea e indexada.
:::




## Criando vetores

A função mais básica para criar vetores é `c()`, que significa "concatenar" ou "combinar".

```{r}
#| label: vet-criacao
#| echo: true

# Vetor de retornos mensais (%)
retornos <- c(0.012, -0.005, 0.007, 0.013)

# Sequência de inteiros de 1 a 4
dias <- 1:4                 

# Sequência trimestral: 1, 4, 7, 10
meses <- seq(1, 12, by = 3) 

# Vetor lógico repetido quatro vezes
flags <- rep(TRUE, 4)       
```



::: {.callout-tip}
## Sobre a função `c()`

A função `c()` combina valores **do mesmo tipo** em um vetor.

```{r}
#| label: vet-cfunc
#| echo: true
c("IFMG", "UFV", "USP")      # vetor de textos
c(TRUE, FALSE, TRUE)         # vetor lógico
c(1.2, 2.5, 3.8)             # vetor numérico (double)
```

Se os elementos tiverem **tipos diferentes**, R fará *coerção implícita* para um tipo comum. Por exemplo:

```{r}
c(1, "texto", TRUE)  # Todos convertidos para texto (character)
```
:::




## Indexação: selecionando elementos

Vetores são indexados com colchetes `[]`. A indexação começa em **1** (não em zero, como em Python ou C).

```{r}
#| label: vet-index
#| echo: true

# Primeiro e último retorno
retornos[1]                  
retornos[length(retornos)]   

# Excluindo o segundo elemento
retornos[-2]                 

# Selecionando apenas valores positivos
retornos[retornos > 0]       
```



::: {.callout-note}
## Filtro condicional em vetores

Expressões como `retornos > 0` retornam um vetor lógico com `TRUE`/`FALSE`, que pode ser usado para **filtrar elementos**:

```{r}
#| echo: true
retornos > 0  # vetor lógico
retornos[retornos > 0]  # filtragem condicional
```

Este comportamento é fundamental para manipulação de dados no `dplyr`.
:::




## Operações vetorizadas e reciclagem

Em R, você pode aplicar operações matemáticas diretamente sobre vetores.

```{r}
#| label: vet-ops
#| echo: true

# Aplicando desconto de IR (15%)
ret_liq <- retornos * (1 - 0.15)  

# Reciclagem de vetor: IR de 15% e 20% aplicados alternadamente
taxas <- c(0.15, 0.20)
ret_liq2 <- retornos * (1 - taxas)  
```


::: {.callout-warning}
## Cuidado com a reciclagem automática

Se os vetores tiverem **comprimentos incompatíveis**, R ainda assim executará a operação com uma **mensagem de aviso**, podendo gerar **resultados incorretos**.

```{r}
#| echo: true
c(1, 2, 3) + c(10, 20)  # comprimento 3 e 2 => erro sutil
```
:::


## Testando tipos e classes

Vetores devem ter **elementos do mesmo tipo**, mas podemos verificar isso com:

```{r}
# Verifica o tipo atômico (typeof) e a classe do objeto
typeof(retornos)  # double
class(retornos)   # numeric
```



## Comprimento dos vetores

Use `length()` para saber quantos elementos um vetor possui:

```{r}
length(retornos)
```




## Vetores de texto (character) e lógicos

```{r}
#| label: vet-text
#| echo: true

# Vetor de nomes de empresas
empresas <- c("Empresa A", "Empresa B", "Empresa C")

# Vetor lógico: metas atingidas?
metas_atingidas <- c(TRUE, TRUE, FALSE)

# Combinação com `cat()`
cat("Metas atingidas:", metas_atingidas, "\n")
```


## Boas práticas com vetores

- Prefira vetores **homogêneos e bem nomeados**
- Use `typeof()` para detectar coerções indesejadas
- Evite misturar tipos dentro de `c()` sem intenção


::: {.callout-note icon="false"}
## Próximos passos

Vetores são a espinha dorsal de todas as estruturas de dados em R.
Compreender seu comportamento é essencial para trabalhar com tabelas
(`data.frames`, `tibbles`), realizar filtros, aplicar transformações
e construir visualizações.

Na próxima seção, vamos abordar os **data frames e tibbles**, que
correspondem às tabelas que usamos no dia a dia — mas com todo o poder
do R por trás.
:::




# Data Frames e Tibbles {#sec-dataframes}

::: {.callout-note icon="false"}
## Por que aprender sobre `data frames` e `tibbles`?

- Em R, **data frames** e **tibbles** são as principais estruturas usadas para armazenar e analisar dados tabulares (como planilhas do Excel).

- Eles representam **conjuntos de dados organizados em colunas e linhas**, onde cada coluna é um vetor.

- Compreender o funcionamento dessas estruturas é essencial para importar, limpar, transformar, visualizar e modelar dados.
:::



::: {.callout-tip}
## Analogia

Pense em um **data frame** como uma **planilha**:

- Cada **coluna** é uma variável (vetor).
- Cada **linha** representa uma observação ou caso.
- Um **tibble** é como uma **planilha moderna**: mantém as mesmas funcionalidades, mas com melhorias que evitam erros e facilitam o uso com dados reais.
:::



## Criando uma `data frame` simples

```{r}
#| label: df-criar
#| echo: true

# Dados hipotéticos de empresas
empresa  <- c("A", "B", "C")
receita  <- c(3.5, 5.2, 4.1)     # em R$ milhões
metas    <- c(TRUE, TRUE, FALSE)

emp_df <- data.frame(empresa, receita, metas)
```

```{r}
#| label: df-print
#| echo: true

# Visualizando o data frame
emp_df
```


::: {.callout-note}
## Estrutura interna

Cada **coluna de um `data.frame` é um vetor**, e todos os vetores **devem ter o mesmo comprimento**. As colunas podem ter **tipos diferentes**, mas devem ser **homogêneas internamente**.
:::



## Convertendo para tibble

```{r}
#| label: df-tibble
#| echo: true
library(tibble)

emp_tb <- as_tibble(emp_df)
emp_tb
```


::: {.callout-tip}
## Por que usar tibbles?

- **Exibição inteligente**: Mostra apenas as primeiras linhas e colunas.
- **Evita conversões automáticas perigosas** (como `stringsAsFactors`).
- **Integra-se perfeitamente ao tidyverse (`dplyr`, `ggplot2`, `tidyr`)**.
- **Mais leve para trabalhar com dados grandes ou listas aninhadas**.
:::



## Inspeção da estrutura

```{r}
#| label: df-inspecao
#| echo: true

# visão detalhada da tibble
str(emp_tb)

# visão geral da tibble
glimpse(emp_tb)    

# resumo estatístico das colunas numéricas
summary(emp_tb)    
```



## Nomes e tipos das colunas

```{r}
#| label: df-nomes-tipos
#| echo: true

# nomes das colunas
names(emp_tb)     

# classe de cada coluna
sapply(emp_tb, class) 
```




## Acessando colunas

```{r}
#| label: df-acesso
#| echo: true

# usando o operador $
emp_tb$receita         
```




## Exemplo com dados financeiros reais

Vamos utilizar o pacote `PerformanceAnalytics`, amplamente usado em finanças, para ilustrar o uso de `tibbles` com séries temporais reais.

```{r}
#| label: df-managers
#| echo: true


library(PerformanceAnalytics) # para obter a df `managers`
library(tidyverse)  # carrega dplyr, tidyr, ggplot2, tibble etc.

# Carrega os dados de performance de carteiras
data(managers, package = "PerformanceAnalytics")  

# Converte objeto xts -> tibble, salvando datas na coluna "date"
managers_tb <- as_tibble(managers, rownames = "date")

# Visão geral da tibble
glimpse(managers_tb)
```



::: {.callout-note}
## O que aprendemos aqui?

- O objeto `managers_tb` contém **retornos mensais de carteiras e benchmarks**.

- As colunas contêm séries de retornos como `ManagerA`, `SP500`, `Russell2000`, etc.

- A coluna `date` foi criada a partir dos nomes das linhas do objeto 
original xts.
:::



## Verificando tipos e valores ausentes

```{r}
#| label: df-validacao
#| echo: true

# Verificando tipos atômicos e classes
sapply(managers_tb, typeof)     

# Verifica a presença dados faltantes
colSums(is.na(managers_tb))     
```

::: {.callout-warning}
## Importância de entender a estrutura

Antes de aplicar qualquer modelo econométrico ou visualização, **é essencial garantir que os dados estão em um formato apropriado**:

- Verificar tipos (`character`, `numeric`, `logical`)
- Detectar valores ausentes (`NA`)
- Garantir que as colunas estejam nomeadas corretamente
:::


::: {.callout-tip}
## Trabalhar com dados reais

- Os dados do `PerformanceAnalytics` são amplamente utilizados para análise de performance de carteiras, avaliação de risco, regressões CAPM e outros modelos em finanças quantitativas.

- Utilizaremos este conjunto como **base para as próximas seções**: tidyverse, visualização e modelagem.
:::



::: {.callout-note icon="false"}
## Próximos passos

Agora que sabemos como criar, inspecionar e acessar `data frames` e `tibbles`, estamos prontos para trabalhar com **os pacotes do tidyverse**, que permitem manipular e transformar dados de forma elegante, eficiente e auditável.
:::




# Metapacote tidyverse

::: {.callout-note icon=false}
## Descrição

- O [tidyverse](https://www.tidyverse.org){target="_blank"} é um 
ecossistema coerente de pacotes R para ciência de dados que compartilham 
uma filosofia de design e gramática comuns.

- Desenvolvido por Hadley Wickham e mantido pela Posit, o tidyverse 
facilita todo o fluxo de trabalho de análise de dados através de 
pacotes integrados.

##### Alguns dos Principais Pacotes do tidyverse {.unnumbered}

- **readr/readxl**: Importação eficiente de dados retangulares
- **tidyr**: Estruturação de dados no formato "tidy" (`pivot_longer`, `pivot_wider`)
- **dplyr**: Manipulação de dados com verbos intuitivos (`filter`, `select`, `mutate`)
- **ggplot2/gt**: Visualização de dados baseada na gramática dos gráficos

- O tidyverse implementa o princípio de "tidy data", criando um fluxo 
de trabalho coeso através do operador pipe (`%>%` ou `|>`).


#### Integração entre os Pacotes {.unnumbered}

O grande poder do tidyverse está na **integração entre seus pacotes**. 
Exemplo: um fluxo completo que:

1. **Transforma** os dados (`mutate`)
2. **Agrupa e resume** estatísticas (`group_by`, `summarise`)
3. **Converte** em formato longo (`pivot_longer`)
4. **Visualiza** os dados (`ggplot2`)


#### Princípios do tidyverse {.unnumbered}

- **Consistência**: funções com sintaxe similar.
- **Composição**: código encadeado com `%>%` ou `|>`.
- **Clareza sem ambiguidade**: nomes expressivos e argumentos explícitos.
- **Reprodutibilidade**: fácil de entender, refatorar e auditar.

A filosofia do tidyverse está alinhada com os princípios modernos 
de ciência de dados transparente, auditável e reproduzível.
:::




## Dados Organizados

- O conceito de **Tidy Data** (Dados Organizados) foi formalizado por
Hadley Wickham.

- Um arquivo de dados organizado possui a seguinte estrutura:

    - Cada **linha** representa **uma** observação individual
    - Cada **coluna** representa **uma** variável específica
    - Cada **célula** contém **um** valor de **uma** variável para 
      **uma** observação específica
  
- A @fig-2 ilustra o conceito de dados organizados visualmente.

![Dados Organizados](img/tidy_data.jpeg){#fig-2}



::: {.callout-note icon=false}
## Benefícios de Dados Organizados

- **Adequação para Ferramentas**: Formato de armazenamento de dados 
adequado para análise em linguagens (R/Python) e softwares de 
análise de dados.

- **Consistência**: Estrutura uniforme para todos os conjuntos de dados

- **Facilidade para operações comuns**:

  - Filtragem de observações
  - Seleção de variáveis
  - Criação de novas variáveis
  - Agregação de dados
  - Junção de múltiplas tabelas
:::



::: {.callout-note icon=false}
## Dados Financeiros Desorganizados Típicos

**Colunas contendo valores**: Nomes de colunas contendo valores 
de uma ou mais variáveis.

   - Ex: Colunas nomeadas com anos (2020, 2021, 2022)

```{.markdown style="font-size: 1em;"}
| Empresa   | 2020    | 2021    | 2022    |
|-----------|---------|---------|---------|
| Empresa A | 350.000 | 425.000 | 510.000 |
| Empresa B | 780.000 | 815.000 | 840.000 |
| Empresa C | 540.000 | 490.000 | 620.000 |
```
:::




::: {.callout-note icon=false}
## Versão Organizada dos Dados Anteriores:

```{.markdown style="font-size: 1em;"}
| Empresa   | Ano  | Valor   |
|-----------|------|---------|
| Empresa A | 2020 | 350.000 |
| Empresa A | 2021 | 425.000 |
| Empresa A | 2022 | 510.000 |
| Empresa B | 2020 | 780.000 |
| Empresa B | 2021 | 815.000 |
| Empresa B | 2022 | 840.000 |
| Empresa C | 2020 | 540.000 |
| Empresa C | 2021 | 490.000 |
| Empresa C | 2022 | 620.000 |
```

**Características:**

- Cada variável está em uma coluna separada
- Cada observação está em uma linha
- Cada célula contém um valor único
:::




::: {.callout-note icon=false}
## Tipos de "Desorganização" Comuns em Administração

**Múltiplas variáveis em uma coluna**: Uma coluna contendo mais 
de uma variável

   - Ex: "Nome_Empresa (Ano)" combinando empresa e ano

```{.markdown style="font-size: 1em;"}
| Nome_Empresa (Ano) | Receita       | Despesa       |
|--------------------|---------------|---------------|
| Empresa A (2020)   | R$ 350.000,00 | R$ 290.000,00 |
| Empresa A (2021)   | R$ 425.000,00 | R$ 320.000,00 |
| Empresa B (2020)   | R$ 780.000,00 | R$ 710.000,00 |
| Empresa B (2021)   | R$ 815.000,00 | R$ 735.000,00 |
```

- **Não** se deve usar unidades (R$ no caso) em arquivos 
para armazenamento de dados para análise.
:::



::: {.callout-note icon=false}
## **Versão Organizada dos Dados**:

```{.markdown style="font-size: 1em;"}
| Empresa    | Ano  | Receita  | Despesa  |
|------------|------|----------|----------|
| Empresa A  | 2020 | 350000   | 290000   |
| Empresa A  | 2021 | 425000   | 320000   |
| Empresa B  | 2020 | 780000   | 710000   |
| Empresa B  | 2021 | 815000   | 735000   |
```
:::




::: {.callout-note icon=false}
## Múltiplas variáveis em uma coluna:

- Os números referem-se ao lucro líquido trimestral das 
empresas em milhões de reais:

```{.markdown style="font-size: 1em;"}
| Empresa    | T1 2023 | T2 2023 | T3 2023 | T4 2023 |
|------------|---------|---------|---------|---------|
| TechSoft   | 25.3    | 31.7    | 28.4    | 35.2    |
| VarejoMax  | 12.8    | 15.4    | 19.3    | 22.7    |
| FinGroup   | 41.6    | 38.9    | 45.2    | 51.8    |
```

- **Problemas:**

    - Valores de uma variável (trimestre) estão nas colunas
    - Não segue o princípio "uma coluna, uma variável"
    - Dificulta análises temporais e comparativas
:::



::: {.callout-note icon=false}
## **Versão Organizada dos Dados**:

```{.markdown style="font-size: 1em;"}
| Empresa   | Trimestre | Ano  | Lucro_Liquido |
|-----------|-----------|------|---------------|
| TechSoft  | T1        | 2023 | 25.3          |
| TechSoft  | T2        | 2023 | 31.7          |
| TechSoft  | T3        | 2023 | 28.4          |
| TechSoft  | T4        | 2023 | 35.2          |
| VarejoMax | T1        | 2023 | 12.8          |
| VarejoMax | T2        | 2023 | 15.4          |
| VarejoMax | T3        | 2023 | 19.3          |
| VarejoMax | T4        | 2023 | 22.7          |
| FinGroup  | T1        | 2023 | 41.6          |
| FinGroup  | T2        | 2023 | 38.9          |
| FinGroup  | T3        | 2023 | 45.2          |
| FinGroup  | T4        | 2023 | 51.8          |
```
:::





::: {.callout-note icon=false}
## Tipos de "Desorganização" Comuns em Administração

**Variáveis em linhas e colunas**

   - Ex: Planilha de desempenho onde ROE aparece como coluna, mas 
   Lucro Líquido e outras variáveis aparecem nas linhas

```{.markdown style="font-size: 1em;"}
| Empresa            | ROE (%)       | Liquidez Corrente |
|--------------------|---------------|-------------------|
| Empresa XYZ        | 15,2          | 1,8               |
| Lucro Líquido      | R$ 2.500.000  | -                 |
| Patrimônio Líquido | R$ 16.400.000 | -                 |
| Ativo Circulante   | -             | R$ 3.600.000      |
| Passivo Circulante | -             | R$ 2.000.000      |
```
:::



::: {.callout-note icon=false}
## **Versão Organizada dos Dados**:

```{.markdown style="font-size: 1em;"}
| Empresa    | Indicador           | Valor       |
|------------|---------------------|-------------|
| Empresa XYZ| ROE                 | 0.152       |
| Empresa XYZ| Liquidez Corrente   | 1.8         |
| Empresa XYZ| Lucro Líquido       | 2500000     |
| Empresa XYZ| Patrimônio Líquido  | 16400000    |
| Empresa XYZ| Ativo Circulante    | 3600000     |
| Empresa XYZ| Passivo Circulante  | 2000000     |
```
:::


  
::: {.callout-tip}  
## Por que a absoluta maioria dos arquivos de dados são desorganizados?

- Por que a maioria das pessoas que trabalham na área de negócios 
**não está** familiarizada com os **princípios** da organização 
de dados para análise e utilizam **planilhas eletrônicas** para 
trabalhar com dados.

- Planilhas de dados são frequentemente organizadas pensando em 
**apresentar** os dados ou para tornar a **entrada** de dados mais 
simples, não em um formato adequado para armazenamento e análise.

- Isso significa que, para a maioria das análises reais, cientistas e 
analistas de dados **dispendem muito tempo e esforço** organizando e 
preparando dados elaborados por terceiros.

- A **primeira etapa** é sempre descobrir quais são as **observações** 
e as **variáveis** associadas a cada observação.
:::



::: {.callout-note icon=false}
## Benefícios para Dissertações e Artigos Científicos

Dados organizados viabilizam e facilitam a:

- **Reprodutibilidade**: Formato padronizado que outros pesquisadores 
podem entender e utilizar

- **Visualizações avançadas**: Estrutura ideal para a criação de diversos 
tipos de tabelas e gráficos.

- **Análise econométrica**: Adequação imediata para estudos e 
modelos econométricos em  (regressão linear, painel, logit, probit etc.)
:::




## Planilhas Eletrônicas


::: {.callout-warning}
## @broman2018: Riscos para Armazenamento de Dados

- Planilhas eletrônicas têm **alto risco de erros**: Em 13 auditorias de 
planilhas reais, uma média de **88%** continham erros [@broman2018].

- Problemas comuns incluem: 

  - Conversão automática de formatos (ex: nomes de genes 
    interpretados como datas)
  
  - Armazenamento de datas de forma diferente entre sistemas operacionais
  
  - Cálculos incorporados que podem corromper dados originais

  - A mistura de análise, visualização e armazenamento no mesmo arquivo 
    aumenta o risco de comprometer os dados brutos e os resultados.

- Mas dada a ubiquidade de planilhas nas organizações, caso precise usar 
planilhas para armazenar dados, siga as seguintes boas práticas:
:::



::: {.callout-tip}
## Recomendações práticas para organizar dados em planilhas.

- Artigo de @broman2018

- Crie planilhas **organizadas** (uma linha = uma observação, uma 
coluna = uma variável, uma célula = um valor)

- Seja **consistente** e escolha **bons nomes** para as variáveis: 

    - use `snake_case` ou `CamelCase`
    - `Lucro Líquido (R$)` 😱
    - `lucro_liquido` ou `LucroLiquido` 😃
    - **NUNCA use** acentos, caracteres especiais e espaços vaziso para nomes ou 
      valores.
   

- Escreva **datas** conforme a [Norma ISO 8601](https://pt.wikipedia.org/wiki/ISO_8601){target="_blank}: 

    - `YYYY-MM-DD`, exemplo: `2025-05-07`

- **Sem** células vazias: use hífen (`-`) e no caso de usar R, use `NA` 

- Crie um **dicionário dos dados**

- **NUNCA faça cálculos** na planilha dos dados originais/brutos

- **NUNCA use** unidades de medida (R$), cor ou realce como um dado.

    - `R$ 50.000,00` 😱
    - `50000` 😃
    - `10 %` 😱 
    - `O.1` 😃

- **Faça backups**

- Use **validação** dos dados para evitar erros

- **Salve** os dados em **arquivos de texto simples** (`.csv`): 

    - todas as linguagens (R/Python) e softwares de análises de dados 
      reconhecem facilmente esse formato.
:::


::: {.callout-tip}  
## Pacote tidyr

Na próxima seção, vamos aprender sobre como o pacote tidyr do 
tidyverse pode ser usado para tornar alguns tipos de dados 
desorganizados em dados organizados para análise.
:::




# Introdução ao Pacote tidyr 

![](https://tidyr.tidyverse.org/logo.png){fig-align="center" width="30%"}

::: {.callout-note icon=false}
## O pacote tidyr no ecossistema tidyverse

- O [tidyr](https://tidyr.tidyverse.org){target="_blank"} é um pacote do 
  tidyverse para **organizar dados desorganizados**

- Seu nome vem de "*tidy*" (organizado) + "r" (R)

- Foi criado para facilitar a transformação de dados desorganizados em 
dados organizados (*tidy data*) para análise

- É muito útil para a preparação de dados na fase 3 do CRISP-DM (Preparação dos Dados)

- Permite que dados em formatos comuns de planilhas e relatórios sejam 
  transformados em formatos adequados para análise e visualização
:::




::: {.callout-note icon=false}
## A Principal função do pacote tidyr para nós

- `pivot_longer()`: Converte dados do formato amplo 
(onde valores de uma ou mais variáveis são espalhadas por colunas) em 
um formato longo (onde cada variável está em uma única coluna).

  - Útil quando você precisa de de dados para análise ou visualização
  
  - **Ex**: Transformar colunas de trimestres (Q1, Q2, Q3, Q4) em uma 
    única coluna "trimestre"

- Iremos estudar **somente** a função `pivot_longer()`, porque 
o foco deste módulo é a preparação de dados para análise.

- Mas há diversas outras funções úteis para a organização de dados:
:::




### Quando usar o tidyr?

::: {.callout-note icon=false}
## Situações comuns em Administração

- Quando você tem **planilhas financeiras** com colunas para diferentes 
períodos (meses, trimestres, anos)
  
- Quando você recebe **planilhas Excel** organizadas para visualização 
humana, mas não para análise de dados.
  
- Quando precisa **combinar dados** de diferentes fontes que estão em 
formatos incompatíveis.
  
- Quando precisa **preparar dados** para visualizações específicas com 
ggplot2 (gráficos de linhas, facetas, etc.)
  
- Quando realiza **análises temporais** e precisa converter entre 
formatos de data/hora.
:::




### A Função tidyr::pivot_longer 


::: {.callout-note icon=false}
## Ao final desta seção, você será capaz de:

- **Aplicar** a função pivot_longer() com seus parâmetros essenciais:
  `cols`, `names_to` e `values_to`
  
- **Organizar/Transformar** dados complexos extraindo múltiplas 
informações de colunas
  
- **Integrar** pivot_longer() em pipelines de análise com dplyr
  
- **Implementar** soluções para casos reais de análise de dados 
administrativos
:::


::: {.callout-note icon=false}
## Transformando dados de formato amplo para longo

- A função `pivot_longer()` converte dados do formato **amplo** (wide) 
para o formato **longo** (long)

- É muito útil quando as colunas contêm **valores** em vez de **variáveis**
  
- Geralmente, é o primeiro passo para transformar planilhas de negócios em 
  dados organizados para análise (*tidy data*)
  
- A @fig-3 ilustra o uso desta função
:::


![Aplicando a função pivot_longer()](img/pivot_longer.jpeg){#fig-3}



### Sintaxe da função pivot_longer()

::: {.callout-tip}
## Como usar pivot_longer() na prática

```{r}
#| eval: false

# Formato básico
dados %>%
  pivot_longer(
    cols = "valores_de_uma_nova_coluna",
    names_to = "nome_nova_coluna",
    values_to = "nome_outra_nova_coluna"
  )
```

- **valores_de_uma_nova_coluna**: as <u>colunas</u> que contêm valores de 
uma variável e serão transformadas.

- **nome_nova_coluna**: <u>nome</u> da nova coluna/variável que conterá os 
nomes das colunas originais.

- **nome_outra_nova_coluna**: <u>nome</u> da nova coluna/variável que 
conterá os valores originais.
:::




### Função pivot_longer 

::: {.callout-tip}
## Descrição

| Característica         | pivot_longer()                                    | 
|------------------------|---------------------------------------------------|
| **Transforma**         | Colunas → Linhas                                  | 
| **Formato resultante** | Longo (mais linhas)                               |
| **Quando usar**        | Para análise e visualização                       | 
| **Exemplo típico**     | Transformar colunas de anos em uma variável "ano" | 
:::





### A Função tribble()

::: {.callout-note icon=false}
## Descrição

A função `tribble()` (abreviação de "*transposed tibble*") é uma forma 
elegante de criar pequenas tibbles/data frames para exemplos ou testes:

```{r}
# Criando uma data frame com tribble() - "tibble transposta"
produtos <- tribble(
  ~codigo, ~produto, ~preco, # Nomes das colunas começam com ~
  "A123", "Notebook", 3500, # Cada linha é um registro
  "B456", "Smartphone", 1800, # Os valores são separados por vírgulas
  "C789", "Monitor", 950 # A formatação facilita a leitura
)

# Visualizando a data frame criada
produtos
```

**Vantagens da função tribble():**

- **Layout Visual**: Cada linha do código corresponde a uma linha da data 
  frame, tornando o código mais legível
  
- **Especificação direta**: Os nomes das colunas são definidos com ~ (til)

- **Flexibilidade de tipos**: Cada coluna pode conter diferentes tipos de dados

- **Ideal para exemplos**: Perfeita para criar pequenas data frames para 
demonstrações ou testes.

Esta função faz parte do pacote `tibble`, que é carregado automaticamente 
quando você carrega o `tidyverse`.
:::




### Exemplo Básico de pivot_longer()

::: {.callout-note icon=false}
## Dados de receita trimestral (formato amplo/wide)

```{r}
# Criando a data frame de exemplo
receitas <- tribble(
  ~produto, ~T1, ~T2, ~T3, ~T4,
  "Produto A", 50000, 55000, 60000, 65000,
  "Produto B", 30000, 32000, 35000, 37000,
  "Produto C", 20000, 22000, 25000, 27000
)

# Visualizando a data frame original (formato amplo/wide)
receitas
```

Este formato é para apresentação, não para armazenamento e 
análise.
:::



::: {.callout-note icon=false}
## Transformando para o formato longo

```{r}
#| eval: true

# Transformando para o formato longo usando pivot_longer
receitas_longas <- receitas %>%
  pivot_longer(
    cols = c("T1", "T2", "T3", "T4"), # colunas que serão valores da nova coluna
    names_to = "trimestre", # nome da nova coluna
    values_to = "receita" # nome de outra nova coluna
  )

# Visualizando o resultado (formato longo/long)
receitas_longas
```

Agora os dados estão organizados:

- Cada linha é uma observação (um produto em um trimestre)
- Cada coluna é uma variável (produto, trimestre, receita)
- Cada célula contém um único valor
:::




### Exemplo Intermediário: Várias Colunas

::: {.callout-note icon=false}
## Dados de desempenho financeiro 

```{r}
# Criando a data frame com múltiplas métricas por trimestre
desempenho <- tribble(
  ~empresa, ~receita_T1, ~receita_T2, ~despesa_T1, ~despesa_T2,
  "Empresa A", 150000, 175000, 120000, 130000,
  "Empresa B", 250000, 270000, 200000, 220000,
  "Empresa C", 100000, 115000, 80000, 95000
)

# Visualizando a data frame original
desempenho
```

Este formato é ainda mais desorganizado, pois mistura três variáveis 
(receita, despesa e trimestre) nos nomes das colunas.
:::



::: {.callout-note icon=false}
## Transformando para o formato longo com dois níveis

```{r}
# Transformando para o formato longo usando pivot_longer com nomes separados
desempenho_longo <- desempenho %>%
  pivot_longer(
    cols = -empresa, # todas as colunas exceto "empresa"
    names_to = c("indicador", "trimestre"), # nomes das duas novas colunas
    names_sep = "_", # separador nos nomes das colunas
    values_to = "valor" # nome de nova coluna para receber os valores
  )

# Visualizando o resultado
desempenho_longo
```

**Observação importante:** 

- Os nomes das colunas originais (`receita_T1`, `receita_T2`, etc.) são 
divididos pelo separador "_" em exatamente duas partes. 

- A primeira parte ("receita" ou "despesa") vai para a coluna "indicador" 
e a segunda parte ("T1" ou "T2") vai para a coluna "trimestre". 

- Este é um padrão comum em dados financeiros: quando os nomes de colunas 
seguem um formato consistente com separadores, podemos extrair as informações 
contidas neles para criar novas variáveis.
:::




### Exemplo Avançado 

::: {.callout-note icon=false}
## Indicadores financeiros por trimestre

```{r}
# Exemplo mais gerenciável para slides
receita_trimestral <- tribble(
  ~empresa, ~`2022_T1_Receita`, ~`2022_T2_Receita`, ~`2023_T1_Receita`, ~`2023_T2_Receita`,
  "ABC Ltda", 1200000, 1350000, 1500000, 1620000,
  "XYZ S.A.", 2500000, 2700000, 2900000, 3100000
)

# Visualizando a data frame original
receita_trimestral
```

- Temos informações de ano e trimestre nos nomes das colunas
:::



::: {.callout-note icon=false}
## Organizando dados financeiros complexos

```{r}
# Transformando para o formato longo usando pivot_longer com três níveis
receita_trimestral_organizada <- receita_trimestral %>%
  pivot_longer(
    cols = -empresa, # todas as colunas exceto "empresa"
    names_to = c("ano", "trimestre"), # nomes de duas novas colunas
    names_sep = "_", # separador nos nomes das colunas
    values_to = "receita" # nome de nova coluna para receber os valores da receita
  )

# Visualizando o resultado
receita_trimestral_organizada
```
:::




### Resumo: Função pivot_longer()

::: {.callout-tip}
## O que você precisa lembrar

1. **Finalidade**: Transformar dados do formato amplo (wide) para o 
formato longo (long), organizando-os conforme o princípio tidy data

2. **Sintaxe básica**:

```{r}
#| eval: false
dados %>%
  pivot_longer(
    cols = colunas_a_transformar,
    names_to = "nome_nova_coluna_para_nomes",
    values_to = "nome_nova_coluna_para_valores"
  )
```

3. **Parâmetros principais**:

- `cols`: Quais colunas serão transformadas em pares nome-valor
- `names_to`: Nome da nova coluna que receberá os nomes das colunas originais
- `values_to`: Nome da nova coluna que receberá os valores

<br>
4. **Caso avançado**:

- Quando os nomes de colunas contêm múltiplas informações, use:

    - `names_to = c("variavel1", "variavel2", ...)`
    - `names_sep = "_"` (ou outro separador presente nos nomes)

<br>
5. **Benefícios**:

- Padroniza o formato de dados conforme princípios da ciência de dados
- Facilita análises com dplyr (group_by, summarize, etc.)
- Prepara dados para visualizações eficientes
:::




### Dicas para Trabalhar com tidyr

::: {.callout-tip}
## Recomendações práticas

1. **Identifique as variáveis**: Antes de transformar, identifique 
claramente quais são as observações e variáveis reais nos seus dados

2. **Comece com subconjuntos**: Para dados complexos, comece testando 
com um pequeno subconjunto de dados

3. **Use nomes descritivos**: Escolha bons nomes para as novas colunas 
criadas por `pivot_longer()` 

4. **Combine com dplyr**: As transformações com tidyr geralmente são 
seguidas por operações com dplyr para análise

5. **Verifique os resultados**: Sempre confira se os dados transformados 
mantêm as mesmas informações dos dados originais
:::





### Resumo: Pacote tidyr

::: {.callout-tip}
## O que você precisa lembrar

1. **O que faz**: O pacote tidyr transforma dados entre os formatos 
amplo (wide) e longo (long)

2. **Principal função**:

   - `pivot_longer()`: Converte de amplo (*wide*) para longo (*long*) 
   (colunas para linhas)

3. **Quando usar**:

   - Use `pivot_longer()` quando colunas contiverem valores em vez de 
     variáveis

4. **Importância na análise de dados**:

   - É essencial para a preparação de dados (fase 3 do CRISP-DM)
   
   - Permite transformar dados comuns de negócios em formatos adequados 
     para análise

   - Facilita a aplicação de funções do dplyr e criação de visualizações

5. **Lembre-se sempre**:

   - Dados organizados (tidy) têm uma variável por coluna, uma observação 
     por linha.
:::





# Introdução ao Pacote dplyr

![](https://dplyr.tidyverse.org/logo.png){fig-align="center"}

::: {.callout-note icon=false}
## O pacote dplyr no ecossistema tidyverse

- O [dplyr](https://dplyr.tidyverse.org/index.html){target="_blank"} é um 
dos pacotes principais do [tidyverse](https://www.tidyverse.org){target="_blank"}, 
criado por Hadley Wickham

- Seu nome vem de "*data plier*" (alicate para dados) - uma ferramenta 
para manipular dados

- Foi projetado seguindo a filosofia "*tidy data*" (dados 
organizados) - cada variável é uma coluna, cada observação é uma linha

- É escrito em C++ para performance otimizada

- Permite manipulação de dados de forma consistente, clara e encadeada
:::




::: {.callout-note icon=false}
## O dplyr no Ecossistema R

- O pacote dplyr é parte do **tidyverse**
  
- Enquanto os pacotes **readr** e **readxl** ajudam 
  na importação de dados, o dplyr é especializado na **manipulação** 
  de dados
  
- O dplyr foi otimizado para manipular sobre **dados organizados**, 
longos ou *tidy data*
  
- O dplyr trabalha com uma estrutura de dados de R que já 
  conhecemos: **data frames/tibbles**
  
- As funções do dplyr foram projetadas para serem usadas com o 
  operador pipe (`%>%`), que já vimos brevemente no relatório Junglivet
:::




::: {.callout-tip}
## O dplyr como uma "linha de produção"

Imagine o processo de análise de dados como uma linha de produção:

- Os **dados brutos** são sua "matéria-prima"

- Cada função do dplyr é uma "estação de trabalho" que realiza 
  uma operação específica:
  
  - `filter()` seleciona apenas os materiais que atendem a certos critérios
  - `select()` separa apenas as partes que você precisa
  - `mutate()` transforma ou cria novos componentes
  - `group_by()` + `summarize()` agrupam e calculam estatísticas
  - `arrange()` organiza o resultado final
  
- O operador pipe (`%>%`) é a "esteira" que move os dados de uma estação 
para outra
:::



::: {.callout-note icon=false}
## Operações Comuns em Análise de Dados

- Muitas vezes precisamos **filtrar** somente certas linhas 
(**observações** ) de uma data frame. 

- Muitas vezes precisamos **selecionar** somente certas colunas 
(**variáveis**) de uma data frame.

- Muitas vezes precisamos **agrupar** os dados por uma determinada(s)
variável(s) categórica.

- Muitas vezes precisamos **calcular estatísticas descritivas** para 
esses subconjuntos de dados (função `summarize`). 
:::




### Por que usar o dplyr?

- **Exemplo 1:** Usando R base

```{r}
# pib per capita médio dos países do continente americano
mean(gapminder$gdpPercap[gapminder$continent == "Americas"])
```

- **Exemplo 1:** Usando o pacote dplyr

```{r}
# pib per capita médio dos países do continente americano
gapminder %>%
  filter(continent == "Americas") %>%
  summarize(mean(gdpPercap))
```



- **Exemplo 2:** R base (aninhado)

```{r}
#| eval: true

# Calcular a média de PIB per capita para 
# países asiáticos com população > 50 milhões 
# em 2007
mean(gapminder$gdpPercap[
  gapminder$continent == "Asia" & 
  gapminder$pop > 50000000 & 
  gapminder$year == 2007
])
```

- Difícil de ler e entender
- Propenso a erros
- Difícil de modificar


- **Exemplo 2:** Com dplyr e o operador pipe

```{r}
#| eval: true

# O mesmo cálculo com dplyr
gapminder %>%
  filter(
    continent == "Asia",
    pop > 50000000,
    year == 2007
  ) %>%
  summarize(mean(gdpPercap))
```

- Leitura sequencial, mais natural
- Cada etapa claramente separada
- Fácil de modificar ou expandir




### Comparando Abordagens

::: {.callout-note icon=false}
## Vantagens e Desvantagens

**Base R: Funções aninhadas**

- **Vantagens**: Não requer pacotes adicionais, disponível em qualquer 
   instalação do R
   
- **Desvantagens**: 

  - Código difícil de ler com funções aninhadas
  - Difícil de depurar quando há erros
  - Funções com sintaxes inconsistentes

**dplyr: Gramática da manipulação de dados**

- **Vantagens**:

  - Código mais legível e expressivo
  - Funções com nomes intuitivos e consistentes
  - Ideal para análises sequenciais com pipes
  
- **Desvantagens**:

  - Requer aprender uma nova sintaxe (para usuários experientes)
  - Dependência de pacotes externos
  - Algumas operações podem ser mais lentas que o R base em casos específicos
:::




### Fluxo de trabalho com tidyvese 

::: {.callout-note icon=false}
## Gramática da manipulação de dados

O fluxo típico de uma análise de dados com tidyverse segue 
este padrão:

1. **Importar** dados (com pacotes here, readr, readxl,...)
2. **Organizar** dados para análise (pacote tidyr)
3. **Unir** arquivos/tabelas se necessário (funções para `joins`)
4. **Filtrar** observações (função `filter`)
5. **Selecionar** variáveis (função `select`)
6. **Transformar** dados (função `mutate`)
7. **Agrupar** dados (função `group_by`)
8. **Resumir** informações (função `summarize`)
9. **Ordenar** resultados (função `arrange`)
:::




### Um Pipeline de Análise com dplyr

::: {.callout-note icon=false}
## Informações sobre expectativa de vida por continente

```{r}
#| eval: true

# Um pipeline de análise com dplyr
relatorio_expectativa <- gapminder %>%
  # Filtra apenas os dados de 2007
  filter(year == 2007) %>%
  # Agrupa por continente
  group_by(continent) %>%
  # Calcula estatísticas resumidas
  summarize(
    expectativa_media = mean(lifeExp),
    expectativa_minima = min(lifeExp),
    expectativa_maxima = max(lifeExp),
    num_paises = n()
  ) %>%
  # Ordena do maior para o menor
  arrange(desc(expectativa_media))

# Visualiza o resultado final
relatorio_expectativa
```

Este exemplo demonstra como um conjunto de funções do dplyr pode 
ser combinado para transformar dados brutos **organizados** em um relatório 
informativo com apenas algumas linhas de código.
:::



::: {.callout-note icon=false}
## **Pacote dplyr: Vantagens**

O pacote dplyr fornece uma série de funções muito úteis para 
manipular data frames de uma maneira que: 

- reduz a probabilidade de cometer erros 
- economiza digitação 
- o código é mais legível e compreensível
:::



::: {.callout-note icon=false}
## Objetivos de Aprendizagem

Vamos aprender 5 das funções mais usadas do pacote dplyr, 

::: {style="font-size: 90%;"}
| Função              | Descrição                                           |
|---------------------|-----------------------------------------------------|
| `dplyr::filter()`   | para filtrar linhas (observações)                   | 
| `dplyr::select()`   | para selecionar colunas (variáveis )                |
| `dplyr::mutate()`   | para criar novas variáveis                          |
| `dplyr::group_by()` | para operações "por grupo"                          |
| `dplyr::summarize()`| para calcular estatísticas                          |
| `dplyr::arrange()`  | para ordenar resultados                             |
:::

Além disso, veremos como como usar o operador pipe (`%>%`) para 
combiná-las.
:::




### Boas Práticas com dplyr

::: {.callout-tip}
## Recomendações para código eficiente e legível

1. **Indentação consistente**: 

   - Um nível de identação para cada função
   - Parâmetros adicionais alinhados

2. **Nomeie seu código**: 

   - Use nomes descritivos para variáveis intermediárias e finais
   - Ex: `dados_filtrados`, `relatorio_vendas_por_regiao`

3. **Comente seu código**:

   - Explique o "por quê", não apenas o "o quê"
   - Útil para você mesmo no futuro e para colegas

4. **Dividir análises complexas em etapas**:

   - Para análises muito complexas, divida em objetos intermediários
   - Facilita a depuração e compreensão

5. **Consistência de estilo**:

   - Seja consistente com o estilo de nomeação (snake_case ou CamelCase)
   - Seja consistente com o uso de aspas (simples ou duplas)
:::




### Pacote gapminder - Dados 

::: {.callout-note icon=false}
## Descrição 

- O pacote gapminder da linguagem R contém uma data frame também chamada 
gapminder. 

- A df gapminder fornece informações detalhadas sobre indicadores 
socioeconômicos reais de vários países ao longo do tempo. 

- Este conjunto de dados é muito utilizado no ensino da linguagem R e 
de métodos estatísticos.

- Vamos utilizar a df `gapminder` para ilustrar as funções do 
pacote dplyr.

- Para acessar os dados gapminder, basta instalar e carregar o 
pacote gapminder:

```{r}
# carrega os pacotes
library(tidyverse)
library(gapminder)
```
:::




### Data Frame gapminder

::: {.callout-note icon=false}
## Fase 1 (CRISP-DM): Entendimento dos Dados

Para obter uma visão geral da estrutura da df gapminder, podemos usar 
a função glimpse do pacote dplyr:

```{r}
# visualizando a estrutura dos dados
dplyr::glimpse(gapminder)
```

Podemos também inspecionar as primeiras 6 linhas da data frame com a 
função head:

```{r}
head(gapminder)
```

:::




### Boa Prática 

::: {.callout-note icon=false}
## Dicionário dos dados

A data frame gapminder contida no pacote de mesmo nome, possui 
1704 linhas (observações) e 6 colunas (variáveis).

| Variável    | Classe/Tipo | Descrição                                                      |
|-------------|-------------|----------------------------------------------------------------|
| `country`   | `factor`    | Nome do país (142 níveis/países)                                      |
| `continent` | `factor`    | Continente ao qual o país pertence (5 níveis/continentes)                  |
| `year`      | `integer`   | Ano da observação (1952 a 2007 em incrementos de 5 anos)       |
| `lifeExp`   | `double`    | Expectativa de vida ao nascer, em anos                         |
| `pop`       | `integer`   | População total do país                                        |
| `gdpPercap` | `double`    | PIB per capita em US$, ajustado pela inflação                  |
:::



## Função select() 


### O que é a função select()?

::: {.callout-note icon=false}
## Selecionando variáveis (colunas) de uma data frame

- A função `select()` permite escolher quais **variáveis** 
(colunas) você quer manter ou remover de uma data frame

- Enquanto `select()` trabalha com **colunas** (variáveis), 
`filter()` trabalha com **linhas** (observações), 
  
- É essencial para simplificar seus dados, focando apenas nas variáveis relevantes para sua análise
:::


![](img/select.jpeg){fig-align="center"}




### Sintaxe da função select()

::: {.callout-tip}
## Sintaxe básica

```{r}
#| eval: false

# Estrutura básica
select(df, var1, var2, var3)

# Com operador pipe
df %>% select(var1, var2, var3)
```

- **df**: A data frame da qual você quer selecionar variáveis
- **var1, var2, var3**: Nomes das variáveis que você quer manter
- Todas as variáveis não listadas serão removidas do resultado
:::




### Exemplo: Análise Financeira Simplificada

::: {.callout-note icon=false}
## Cenário: Análise financeira de países

Imagine que você é um analista financeiro internacional e precisa 
preparar um relatório sobre PIB:

```{r}
# Seleciona apenas as variáveis relevantes para análise financeira
dados_financeiros <- gapminder %>%
  select(country, year, gdpPercap)

# Visualiza as primeiras linhas do resultado
head(dados_financeiros)
```

**Interpretação:** Este código seria equivalente a extrair apenas os 
dados financeiros relevantes (país, ano e PIB per capita) de uma 
grande base de dados para uma análise específica de desempenho 
econômico.
:::




### Técnicas de Seleção Avançadas

::: {.callout-note icon=false}
## Diversas formas de selecionar variáveis

```{r}
#| eval: false

# Selecionar variáveis por inclusão
gapminder %>% select(country, year, gdpPercap)

# Selecionar variáveis por exclusão (com sinal de menos)
gapminder %>% select(-continent, -lifeExp)

# Selecionar variáveis em sequência
gapminder %>% select(country:pop)

# Selecionar variáveis que começam com determinado texto
gapminder %>% select(starts_with("c"))

# Selecionar variáveis que terminam com determinado texto
gapminder %>% select(ends_with("p"))

# Selecionar variáveis que contêm determinado texto
gapminder %>% select(contains("exp"))
```
:::



::: {.callout-tip}
## Aplicações práticas em negócios

Estas técnicas são muito úteis quando você trabalha com:

- Grandes conjuntos de dados com dezenas ou centenas de variáveis
- Planilhas de dados financeiros onde precisa focar em determinadas métricas
- Relatórios onde precisa apresentar apenas informações específicas
:::




### Erros Comuns e Como Evitá-los


::: {.callout-caution}
## Os erros mais comuns com select()

| Erro | Errado | Correto |
|------|-------------------|-----------------|
| Nomes de variáveis com aspas | `select(gapminder, "country")` | `select(gapminder, country)` |
| Tentar condições como em filter | `select(gapminder, gdpPercap > 1000)` | Use `filter()` para isso, não `select()` |
| Não salvar o resultado | `gapminder %>% select(country, year)` | `dados_novos <- gapminder %>% select(country, year)` |
| Remover variáveis necessárias | `select(country)` e depois tentar usar `continent` | Verifique se manteve todas as variáveis necessárias |
:::


::: {.callout-tip}
## Dica importante:

Lembre-se: `select()` é para escolher **colunas (variáveis)** e `filter()` é para escolher **linhas (observações)**!
:::




### Exemplo: Salvando o resultado

::: {.callout-note icon=false}
## Seleção por Exclusão

- Se quisermos remover apenas a variável **continent**, podemos usar 
a sintáxe abaixo e salvar o resultado em outro objeto:

```{r}
variaveis_selecionadas <- select(gapminder, -continent)
variaveis_selecionadas
```
:::




### Pacote dplyr e o operador pipe ( `|>` ou `%>%`)

::: {.callout-note icon=false}
## Combinação de Operações com `|>` ou `%>%`

- Nos slides anteriores, usamos a sintáxe 'normal' da linguagem R. 

- Mas o ponto forte do dplyr está na **combinação** de várias funções 
usando o **operador pipe** `%>%`. 

- Vamos analisar a gramática do uso de funções do dplyr combinadas 
com o operador `%>%`. 

- Atalho para inserir o operador pipe: **Ctrl + shift + M**
:::



::: {.callout-note icon=false}
## Significado conceitual do pipe %>%

- O operador pipe pode ser lido como "então" ou "em seguida"

- Fluxo da esquerda para a direita, similar à leitura natural

- Transforma: 

`funcao(dados, arg1, arg2)` 

em 

`dados %>% funcao(arg1, arg2)`

:::



::: {.callout-note icon=false}
## Analogia

Uma linha de montagem onde cada função faz uma operação nos dados

```{r}
#| eval: true
#| code-line-numbers: "1|2|3|4-7"

gapminder %>% # Pegue os dados gapminder, então...
  filter(year == 2007) %>% # Filtre para apenas o ano 2007, então...
  group_by(continent) %>% # Agrupe por continente, então...
  summarize( # Calcule resumos:
    mean(lifeExp), # expectativa de vida média
    sum(pop) # população total 
  )
```
:::




::: {.callout-tip}
## Nomeie os resumos calculados com summarize

```{r}
#| eval: true
#| 
#| code-line-numbers: "4-7"
gapminder %>% # Pegue os dados gapminder, então...
  filter(year == 2007) %>% # Filtre para apenas o ano 2007, então...
  group_by(continent) %>% # Agrupe por continente, então...
  summarize( # Calcule resumos:
    exp_vida_media = mean(lifeExp), # expectativa de vida média
    populacao_total = sum(pop) # população total
  )
```
:::




### Função select() e o Operador Pipe


::: {.callout-tip}
## Selecionando Variáveis com o Pipe

```{r}
variaveis_selecionadas <- gapminder %>%
  dplyr::select(year, country, gdpPercap)
```

Vamos entender o código:

1. Primeiro invocamos a df gapminder e a passamos, usando o operador
pipe `%>%`, para a próxima etapa, que é a função select(). 

2. Neste caso, não especificamos qual df usamos na 
função select(), porque que ela obtém essa informação do pipe 
anterior. 

3. Salvamos o resultado no objeto `variaveis_selecionadas`
:::




### Resumo: Função select() 

::: {.callout-tip}
## O que você precisa lembrar

1. **Para que serve:** Selecionar apenas as colunas (variáveis) que você deseja manter ou remover

2. **Sintaxe básica:** 

```{r}
#| eval: false
dados %>% select(var1, var2, var3)  # Mantém apenas var1, var2 e var3
dados %>% select(-var4, -var5)      # Remove var4 e var5, mantém o resto
```

3. **Técnicas úteis:**
   - Seleção por inclusão: `select(país, ano, vendas)`
   - Seleção po exclusão: `select(-observações, -notas)`
   - Seleção por padrão de texto: `select(starts_with("venda"))`

4. **Lembre-se sempre:**
   - `select()` trabalha com COLUNAS
   - `filter()` trabalha com LINHAS
   - Sempre salve o resultado em um novo objeto!

```{r}
#| eval: false
novo_df <- dados %>% select(...)
```
:::






## Função filter() 


### O que é a função filter()?

::: {.callout-note icon=false}
## Filtrando observações (linhas) de uma data frame

- A função `filter()` permite **filtrar subconjuntos de observações** 
(linhas) que atendem determinadas condições ou critérios.

- É uma das funções mais utilizadas na análise de dados para criar 
  subconjuntos específicos dos dados
  
- Pense nela como um "filtro" que deixa passar apenas as observações 
  que atendem aos critérios que você definir
:::


![Neste caso, duas linhas atendem às condições](img/filter.jpeg){fig-align="center"}




### O que é a função filter()?

::: {.callout-note icon=false}
## Filtrando observações (linhas) de uma data frame

- Imagine que você tem uma planilha de vendas e quer analisar apenas 
as vendas:

  - de um produto específico
  - acima de determinado valor
  - em uma região específica
  - em um período específico

- A função `filter()` permite fazer essa filtragem de forma rápida e precisa
:::




### Sintaxe da função filter()

::: {.callout-tip}
## Sintaxe básica

```{r}
#| eval: false

# Estrutura básica
filter(df, condição)

# Com operador pipe
df %>% filter(condição)
```

- **df**: A data frame a ser filtrada
- **condição**: Expressão lógica que retorna TRUE/FALSE para cada linha
- Somente as linhas que resultam em TRUE são mantidas no resultado
:::




### Operadores para construir condições

::: {.callout-tip}
## Operadores na linguagem dos negócios

| Operador | Exemplo em Linguagem Natural | Código em R |
|----------|--------------------------|----------|
| ==  | Apenas os países europeus | continent == "Europe" |
| != | Todos, exceto os países europeus | continent != "Europe" |
| > | Países com PIB per capita maior que 10.000 | gdpPercap > 10000 |
| < | Países com menos de 1 milhão de habitantes | pop < 1000000 |
| >= | Países a partir do ano 2000 | year >= 2000 |
| &  | Países europeus a partir de 2000 | continent == "Europe" & year >= 2000 |
| `|` | Países da Europa ou da Ásia | continent == "Europe" &#124; continent == "Asia"</code> |

:::


::: {.callout-tip}
## Dicas

- Use `==` para igualdade (lembre-se: dois sinais de igual, não apenas um)
- Use `&` para "E" (quero este critério **E** aquele também)
- Use `|` para "OU" (quero este critério **OU** aquele)
:::




### Exemplo básico

::: {.callout-note icon=false}
## Cenário: Análise de vendas por continente

Imagine que a data frame `gapminder` representa dados de filiais de uma 
empresa multinacional:

```{r}
# Filtra apenas países das Américas
# como se fossem filiais da região Américas

filiais_americas <- gapminder %>%
  filter(continent == "Americas")

# Visualiza as primeiras 6 linhas do resultado
head(filiais_americas)
```

**Interpretação:** Este filtro seria equivalente a selecionar 
apenas dados de filiais localizadas nas Américas para uma análise 
regional de desempenho.
:::




### Pensando como um Analista de Negócios

::: {.callout-note icon=false}
## Perguntas de negócios traduzidas para filter()

| Pergunta de Negócio | Código com filter() |
|---------------------|---------------------|
| Quais países tiveram PIB per capita acima de $20.000 em 2007? | `filter(year == 2007 & gdpPercap > 20000)` |
| Quais países da Ásia tiveram expectativa de vida acima de 75 anos? | `filter(continent == "Asia" & lifeExp > 75)` |
| Quais países tiveram população superior a 100 milhões em 2007? | `filter(year == 2007 & pop > 100000000)` |
| Quais países não são da Europa nem da América? | `filter(continent != "Europe" & continent != "Americas")` |


**Dica:** Comece sempre pensando na pergunta de negócio, depois 
traduza para o código
:::




### Múltiplas condições com filter()

::: {.callout-note icon=false}
## Combinando condições

Há duas maneiras principais de combinar condições:

```{r}
#| echo: true
#| eval: false

# Método 1: Usando o operador & (E lógico) - equivalente ao método 1
europeus_2007_alt <- gapminder %>%
  filter(continent == "Europe" & year == 2007)

# Método 2: Usando o operador | (OU lógico)
europa_ou_asia <- gapminder %>%
  filter(continent == "Europe" | continent == "Asia")
```

Dica importante:

- Com `&` ("E") ambas as condições precisam ser `TRUE` para que
a linha seja mantida

- Com `|` ("OU"), apenas uma das condições precisa ser `TRUE`
:::




### Filtrando com operadores relacionais

::: {.callout-note icon=false}
## Exemplos com diferentes operadores

```{r}
#| eval: true

# Países com alta expectativa de vida (maior que 80 anos)
alta_exp_vida <- gapminder %>%
  filter(lifeExp > 80)

# Países com PIB per capita abaixo de 500 dólares
baixo_pib <- gapminder %>%
  filter(gdpPercap < 500)

# Anos diferentes de 2002
nao_2002 <- gapminder %>%
  filter(year != 2002)
```

Utilize operadores relacionais para:

- Encontrar valores acima/abaixo de limites importantes
- Excluir períodos ou categorias específicas
- Identificar casos extremos ou outliers
:::




### Combinando filter() com outras funções

::: {.callout-note icon=false}
## A importância da ordem das operações

```{r}
#| eval: true

# Países europeus em 2007, mostrando apenas país e expectativa de vida
europeus_lifeExp_2007 <- gapminder %>%
  filter(continent == "Europe" & year == 2007) %>%
  select(country, lifeExp)

# Ordenando o resultado por expectativa de vida (decrescente)
europeus_lifeExp_2007_ordenado <- gapminder %>%
  filter(continent == "Europe" & year == 2007) %>%
  select(country, lifeExp) %>%
  arrange(desc(lifeExp))

head(europeus_lifeExp_2007_ordenado)
```

**Ordem correta** das operações:

1. Comece com **filter()** 
2. Use **select()** depois de filter
3. Se inverter a ordem, a função filter() pode falhar se você removeu 
colunas necessárias

Lembre-se: primeiro **filter()**, depois **select()**!
:::




### Erros Comuns e Como Evitá-los

::: {.callout-caution}
## Os 4 erros mais comuns com filter()

| Erro | Errado | Correto |
|------|-------------------|-----------------|
| Usar = em vez de == | `filter(continent = "Europe")` | `filter(continent == "Europe")` |
| Esquecer as aspas em nomes | `filter(continent == Europe)` | `filter(continent == "Europe")` |
| Não salvar o resultado | `gapminder %>% filter(year == 2007)` | `dados_2007 <- gapminder %>% filter(year == 2007)` |
:::




### Exemplo Completo Comum

::: {.callout-note icon=false}
## Países europeus com alta expectativa de vida em 2007?

```{r}
#| eval: true

# Países europeus com expectativa de vida acima de 78 anos em 2007
resultado_final <- gapminder %>%
  # Filtrar por continente, ano e expectativa de vida
  filter(continent == "Europe" & year == 2007 & lifeExp > 78) %>%
  # Selecionar variáveis de interesse
  select(country, lifeExp, gdpPercap) %>%
  # Ordenar por expectativa de vida (decrescente)
  arrange(desc(lifeExp))

# Mostrar resultados
resultado_final
```

Observe o fluxo de análise:

1. Filtramos os dados com critérios específicos
2. Selecionamos apenas as variáveis de interesse
3. Ordenamos os resultados para facilitar a interpretação
4. Todo o processo forma um "pipeline" de análise limpo e legível
:::




### Resumo: Função filter() 

::: {.callout-tip}
## O que você precisa lembrar

1. **Para que serve:** Selecionar apenas as linhas (observações) 
que atendem a determinadas condições

2. **Sintaxe básica:** 

```{r}
#| eval: false

dados %>% filter(condição1, condição2, ...)
```

3. **Comparações mais usadas:**

   - Igual: == (dois sinais de igual!)
   - Diferente: !=
   - Maior/Menor: >, <, >=, <=

4. **Múltiplas condições:**
   - Todas as condições (E): `filter(condição1 & condição2)`
   - Qualquer condição (OU): `filter(condição1 | condição2)`

5. **Lembre-se sempre de salvar o resultado:**

```{r}
#| eval: false

nova_df <- dados %>% filter(...)
```
:::




## Função mutate() 


::: {.callout-note icon=false}
## O que é a função mutate()?

- A função `mutate()` permite **criar novas variáveis** ou 
  **modificar variáveis existentes**

- Enquanto `filter()` seleciona linhas e `select()` seleciona colunas, 
  `mutate()` **adiciona ou modifica colunas**

- É como ter uma "calculadora" que cria novas informações a partir dos 
  dados existentes

- Ideal para cálculos como: percentuais, totais, médias, categorias, etc.
:::


![Cria novas variáveis a partir das variáveis existentes](img/mutate.jpeg){fig-align="center"}



::: {.callout-tip}
## Sintaxe da função mutate()

```{r style="font-size: 1em;"}
#| eval: false

# Formato básico
dados %>% mutate(nova_coluna = expressão)

# Exemplos práticos
dados %>% mutate(valor_total = preco * quantidade)
dados %>% mutate(valor_com_desconto = preco * 0.9)
```

**O que cada parte significa:**

- **nova_coluna**: Nome da nova variável que você está criando
- **expressão**: Fórmula que calcula os valores da nova variável
- A expressão é aplicada a cada linha individualmente
:::



::: {.callout-note icon=false}
## Aplicação: Análise de Vendas

Imagine que a data frame `gapminder` contém dados de vendas 
globais da sua empresa:

```{r style="font-size: 1em;"}
#| eval: false

# Criando variáveis para análise de vendas
vendas_analise <- gapminder %>%
  filter(year == 2007) %>%  # Filtra dados somente de 2007
  mutate(
    # PIB total representa a receita total da região
    receita_total = gdpPercap * pop,
    # Receita em milhões (para facilitar a leitura)
    receita_milhoes = receita_total / 1000000,
    # Indicador de destaque (regiões com alta receita por pessoa)
    destaque = gdpPercap > 20000
  ) %>%
  # Vamos visualizar apenas algumas colunas e 5 linhas
  select(country, receita_milhoes, gdpPercap, destaque) %>%
  head(5)

vendas_analise
```

**Interpretação administrativa:** Este tipo de transformação é usado 
diariamente nas empresas para converter dados brutos em métricas de 
negócios úteis para tomada de decisão.
:::



::: {.callout-note icon=false}
## Transformações mais comuns: Operações aritméticas básicas

```{r style="font-size: 1em;"}
#| eval: false
# Operações aritméticas básicas com mutate()
gapminder %>%
  filter(country == "Brazil", year >= 2000) %>%
  mutate(
    # Adição: adiciona um valor fixo
    pop_ajustada = pop + 1000000,
    # Multiplicação: multiplica por um fator
    gdp_reais = gdpPercap * 5.2,  # Convertendo para reais
    # Divisão: divide para mudar a escala 
    pop_milhoes = pop / 1000000   # População em milhões
  ) %>%
  select(year, pop, pop_ajustada, pop_milhoes, gdpPercap, gdp_reais)
```

**Dica:** As operações mais utilizadas em análises de negócios são 
multiplicação (para fatores, taxas, conversões) e divisão (para mudar 
escalas e calcular proporções).
:::




### Criando categorias com ifelse()

::: {.callout-note icon=false}
## O que é a função ifelse()?

A função `ifelse()` permite criar novas variáveis categóricas baseadas 
em condições:

**Como funciona:** `ifelse(condição, valor_se_verdadeiro, valor_se_falso)`

```{r style="font-size: 1em;"}
#| eval: false
# Criando categorias com ifelse
paises_categorizados <- gapminder %>%
  filter(year == 2007) %>%
  mutate(
    nivel_desenvolvimento = ifelse(gdpPercap > 10000, 
                                   "Desenvolvimento Alto", 
                                   "Desenvolvimento Baixo")
  ) %>%
  select(country, gdpPercap, nivel_desenvolvimento) %>%
  head(6)

paises_categorizados
```

- É como dizer: "SE o PIB per capita for maior que 10.000, então 
classifique como 'Desenvolvimento Alto', SENÃO classifique como 
'Desenvolvimento Baixo'"
:::



::: {.callout-note icon=false}
## Criando KPIs com mutate() e ifelse() 

```{r style="font-size: 1em;"}
#| eval: false
gapminder %>%
 filter(year == 2007) %>%
 mutate(
   pib_total = gdpPercap * pop,  # PIB total
   pib_percentual_global = (pib_total/sum(pib_total))*100, # % do PIB global
   performance = ifelse(gdpPercap > mean(gdpPercap), 
                       "Acima da média", 
                       "Abaixo da média")
 ) %>% 
 select(country, pib_total, pib_percentual_global, performance)
```

Isso mostra como transformar dados brutos em informações gerenciais.
:::




### Criando Múltiplas Categorias com case_when()

::: {.callout-note icon=false}
## Quando precisamos de mais de duas categorias

`case_when()` é como um "sistema de classificação" para criar 
categorias mais complexas:

```{r style="font-size: 1em;"}
#| eval: false

# Exemplo de múltiplas categorias
paises_classificados <- gapminder %>%
  filter(year == 2007) %>%
  mutate(
    classe_desenvolvimento = case_when(
      gdpPercap < 2000 ~ "Baixo",
      gdpPercap < 10000 ~ "Médio",
      gdpPercap >= 10000 ~ "Alto"
    )
  ) %>%
  select(country, gdpPercap, classe_desenvolvimento) %>%
  head(6)

paises_classificados
```

**Como funciona:**

- Cada linha representa uma condição: `condição ~ "valor a atribuir"`
- As condições são verificadas em ordem (de cima para baixo)
- Quando uma condição é verdadeira, o valor correspondente é atribuído
:::



::: {.callout-tip}
## Quando usar ifelse() vs. case_when()?

| Função | Quando usar | Exemplo |
|--------|-------------|---------|
| `ifelse()` | Para divisões simples em duas categorias | `ifelse(vendas > meta, "Meta atingida", "Meta não atingida")` |
| `case_when()` | Para múltiplas categorias ou condições complexas | Classificar clientes em "Bronze", "Prata", "Ouro" e "Platina" baseado em diferentes critérios |

**Analogia de negócios:**

- `ifelse()` é como uma decisão "sim/não" (aprovação de crédito simples)

- `case_when()` é como um sistema de classificação de clientes com 
várias categorias
:::





### Erros Comuns e Como Evitá-los

::: {.callout-caution}
## Os erros que todos cometem no início

1. **Usar o operador de atribuição errado**

   - ERRADO: `mutate(nova_var <- expressão)` ❌ 
   - CORRETO: `mutate(nova_var = expressão)` ✅

2. **Esquecer de salvar o resultado**

   - ERRADO: `dados %>% mutate(nova_var = x * 2)` ❌ (resultado não salvo)
   - CORRETO: `dados_novos <- dados %>% mutate(nova_var = x * 2)` ✅

3. **Tentar usar variáveis que acabou de criar sem manter os resultados**

ERRADO: 

```{r style="font-size: 1.2em;"}
#| eval: false
# Executando dois comandos separados:
dados %>% mutate(nova_var = x * 2)  # Resultado não salvo em lugar nenhum
dados %>% filter(nova_var > 10)     # ❌ Erro! nova_var não existe em 'dados'
```

CORRETO (Pipeline único):

```{r style="font-size: 1.2em;"}
#| eval: false
dados_novos <- dados %>%
  mutate(nova_var = x * 2) %>%
  filter(nova_var > 10) # ✅ Funciona porque tudo está no mesmo pipeline
```
:::




### Resumo: Função mutate()

::: {.callout-tip}
## O que você precisa lembrar

1. **O que faz:** `mutate()` cria novas variáveis ou modifica existentes
   
2. **Usos comuns no mundo dos negócios:**

   - Calcular totais, médias, porcentagens
   - Converter unidades (dólares para reais, unidades para milhares)
   - Criar categorias e classificações

3. **Como usar na prática:**

```{r style="font-size: 1em;"}
#| eval: false
dados %>% mutate(nova_variavel = expressão)
```

4. **Ferramentas complementares:**

   - `ifelse()` para classificações simples (sim/não)
   - `case_when()` para classificações múltiplas

5. **Lembre-se de salvar o resultado em um novo objeto:**

```{r style="font-size: 1em;"}
#| eval: false
novo_df <- dados %>% mutate(...)
```
:::





## Funções group_by() + summarize() 

::: {.callout-note icon=false}
## O que são as funções group_by() e summarize()?

- A função `group_by()` permite **agrupar dados** por uma ou mais 
variáveis categóricas
  
- A função `summarize()` (ou `summarise()`) permite **calcular 
estatísticas resumidas** para cada grupo

- Estas funções geralmente trabalham juntas como uma ferramenta 
poderosa para análise

- É como criar "subtotais" ou "relatórios consolidados" por 
categorias (ex: vendas por região, despesas por departamento)
:::


![Funções group_by() e summarize()?](img/groupby.jpeg){fig-align="center" width="40%"}



::: {.callout-tip}
## Sintaxe das funções group_by() e summarize()

```{r style="font-size: 1em;"}
#| eval: false

# Estrutura básica
df %>% 
  group_by(variavel_de_agrupamento) %>%
  summarize(nome_do_resumo = funcao(variavel))

# Exemplo prático
df %>%
  group_by(departamento) %>%
  summarize(media_vendas = mean(vendas))
```

- **df**: A data frame que contém os dados
- **variavel_de_agrupamento**: Variável **categórica** pela qual agrupar 
   (ex: região, produto)
- **nome_do_resumo**: Nome que você escolhe para o resultado calculado
- **funcao**: Função estatística (ex: mean, sum, max, min, sd, n)
- **variavel**: Variável para calcular a estatística
:::




::: {.callout-note icon=false}
## Exemplo: Análise Financeira por Continente

Imagine que você é um analista financeiro e precisa preparar 
um relatório executivo comparando regiões:

```{r}
# Cria um relatório de PIB médio por continente
relatorio_continentes <- gapminder %>%
  filter(year == 2007) %>%  # Filtra para dados mais recentes
  group_by(continent) %>%   # Agrupa por continente
  summarize(
    PIB_medio = mean(gdpPercap),         # Média do PIB per capita
    Total_populacao = sum(pop),          # População total
    Paises_analisados = n(),             # Número de países
    PIB_minimo = min(gdpPercap),         # PIB mínimo
    PIB_maximo = max(gdpPercap)          # PIB máximo
  ) %>%
  arrange(desc(PIB_medio))  # Ordena do maior para o menor PIB médio

# Visualiza o resultado
relatorio_continentes
```

**Interpretação** Este tipo de relatório consolidado por 
região é crítico para análises comparativas entre mercados e para 
apresentações executivas. Mostra claramente as estatísticas-chave 
para cada grupo (continente), facilitando comparações e decisões 
estratégicas.
:::



::: {.callout-tip}
## Funções Estatísticas Mais Usadas com summarize()

| Função | O que calcula | Exemplo em R | Uso em Negócios |
|--------|---------------|-------------|-----------------|
| `mean()`| Média | `mean(vendas)` | Valor médio de vendas por região |
| `sum()` | Soma total | `sum(receita)` | Receita total por categoria |
| `min()` | Valor mínimo | `min(preco)` | Menor preço praticado |
| `max()` | Valor máximo | `max(despesa)` | Maior despesa do período |
| `sd()` | Desvio padrão | `sd(producao)` | Variabilidade da produção |
| `n()` | Contagem de linhas | `n()` | Número de transações |
| `n_distinct()`| Contagem de valores únicos | `n_distinct(cliente)` | Número de clientes únicos |
| `median()` | Mediana | `median(vendas)` | Valor típico de vendas |

**Dica para gestores:** Sempre inclua tanto medidas de "tendência central" 
(média, mediana) quanto de "variação" (desvio padrão) para ter uma 
visão mais completa dos dados.
:::




### Agrupando por Múltiplas Variáveis

::: {.callout-note icon=false}
## Análises mais detalhadas

```{r style="font-size: 1em;"}
# Análise de expectativa de vida por continente e ano
tendencias_por_continente <- gapminder %>%
  group_by(continent, year) %>%  # Agrupa por DUAS variáveis
  summarize(
    expectativa_vida_media = mean(lifeExp),
    paises_analisados = n()
  ) %>%
  arrange(continent, year)

# Mostra resultados parciais
tendencias_por_continente %>% 
  filter(continent == "Americas") %>%
  head(3)
```

**Contexto empresarial:** Este tipo de análise é comum em:

- Relatórios de vendas por região e trimestre
- Análise de desempenho por departamento e mês
- Monitoramento de métricas por produto e canal de vendas
:::




### Erros Comuns e Como Evitá-los

::: {.callout-caution}
## Os erros que todos cometem no início

| Erro | Errado | Correto |
|------|-------------------|-----------------|
| Não usar summarize após group_by | `dados %>% group_by(regiao)` | `dados %>% group_by(regiao) %>% summarize(...)` |
| Tentar agrupar antes de filtrar | `group_by(regiao) %>% filter(mean(vendas) > 1000)` | Usar `filter()` ANTES de `group_by()` |
| Esquecer de desagrupar | Continuar usando dados agrupados | Usar `ungroup()` quando terminar com análises agrupadas |

**Dica:** `group_by` por si não produz nenhum resultado.
:::




### Resumo: Funções group_by() e summarize()

::: {.callout-tip}
## O que você precisa lembrar

1. **Para que servem:**

   - `group_by()`: Agrupa dados por categorias (como agrupar linhas em 
     uma planilha)
     
   - `summarize()`: Calcula estatísticas para cada grupo 
      (como criar subtotais)

2. **Sintaxe básica:**

```{r}
#| eval: false

dados %>% 
  group_by(categoria) %>%
  summarize(resumo = funcao(variavel))
```

3. **Funções estatísticas básicas:**

   - Para totais: `sum()`
   - Para médias: `mean()`
   - Para contagens: `n()`
   - Para mínimos/máximos: `min()`, `max()`

4. **Fluxo de trabalho típico:**

   - Primeiro filtre os dados (`filter()`)
   - Depois agrupe (`group_by()`)
   - Em seguida calcule estatísticas (`summarize()`)
   - Por fim, ordene os resultados (`arrange()`)

5. **Lembre-se sempre de salvar o resultado:**

```{r}
#| eval: false

relatorio_final <- dados %>% group_by(...) %>% summarize(...)
```
:::




## Função arrange()

::: {.callout-note icon=false}
## Descrição

- A função `arrange()` ordena as linhas (observações) de uma data frame 
com base nos valores de uma ou mais colunas (variáveis)
   
- Por padrão, organiza em ordem **crescente** (do menor para o maior)

- Use `desc()` para ordenar em ordem decrescente (do maior para o menor)
:::


![Reordena as linhas de uma data frame segundo uma variável, por padrão em ordem crescente, com desc() em ordem decrescente](img/arrange.jpeg){fig-align="center"}



::: {.callout-tip}
## Sintaxe da função arrange()

```{r}
#| eval: false

# Formato básico
df %>% arrange(variavel)         # ordem crescente
df %>% arrange(desc(variavel))   # ordem decrescente

# Ordenar por múltiplas variáveis
dados %>% arrange(var1, var2)       # Ordenar primeiro por var1, depois var2
```

- **df**: A data frame que contém os dados
- **variavel**: Nome da coluna pela qual você quer ordenar as observações
- Use `desc()` para ordem descrescente (do maior para o menor)
- Quando ordenando por múltiplas variáveis, a primeira tem prioridade
:::



::: {.callout-note icon=false}
## Aplicação: Análise de Desempenho

Imagine que você é um analista de mercado e precisa identificar 
rapidamente os países mais promissores para expansão:

```{r}
# Criando um ranking de países por PIB per capita em 2007
ranking_paises <- gapminder %>%
  filter(year == 2007) %>%                # Filtra dados apenas de 2007
  select(country, continent, gdpPercap) %>% # Seleciona colunas relevantes
  arrange(desc(gdpPercap)) %>%            # Ordena do maior para o menor PIB
  head(6)                                # Mostra os 10 primeiros resultados

# Visualiza o resultado
ranking_paises
```

**Interpretação** Este tipo de ordenação é relevante em 
análises de mercado para identificar rapidamente os países mais ricos 
(potenciais mercados premium) ou para encontrar as regiões que precisam 
de mais atenção (ordenando do menor para o maior).
:::




### Erros Comuns e Como Evitá-los

::: {.callout-caution}
## Cuidados ao usar arrange()

| Erro | Problema | Solução |
|------|----------|---------|
| Ordem incorreta | `arrange(dados, desc())` sem especificar a variável | `arrange(dados, desc(variavel))` |
| Tentar ordenar por variável não existente | `arrange(vendas_por_regiao)` quando a coluna não existe | Verificar primeiro os nomes das colunas com `names()` |
| Não salvar o resultado ordenado | Ordenar mas não atribuir a um objeto | `dados_ordenados <- dados %>% arrange(...)` |

**Lembre-se:** A ordenação é temporária se você não salvar o resultado 
em um novo objeto!
:::




### Resumo: Função arrange()

::: {.callout-tip}
## O que você precisa lembrar

1. **Para que serve:** Ordenar as linhas (observações) com base nos 
valores de uma ou mais colunas

2. **Sintaxe básica:** 

```{r style="font-size: 1em;"}
#| eval: false
dados %>% arrange(variavel)         # ordem crescente 
dados %>% arrange(desc(variavel))   # ordem decrescente 
```

3. **Usos comuns em negócios:**

   - Criar rankings de vendedores, produtos ou regiões
   - Identificar os maiores clientes (Top 10)
   - Encontrar problemas (itens com menor desempenho)
   - Preparar dados para relatórios e apresentações

4. **Lembre-se sempre:**

   - Use `desc()` para ordem decrescente
   - Para ordenar por múltiplas colunas: `arrange(var1, var2)`
   - Salve o resultado em um novo objeto!

```{r style="font-size: 1em;"}
#| eval: false
dados_ordenados <- dados %>% arrange(...)
```
:::




## Resumo das Funções dplyr

::: {.callout-tip icon=true}
## Resumo das seis funções principais

| Função        | Propósito                              |
|---------------|----------------------------------------|
| `dplyr::filter()`    | Seleciona linhas baseadas em condições | 
| `dplyr::select()`    | Seleciona colunas específicas          | 
| `dplyr::mutate()`    | Cria ou modifica colunas               |
| `dplyr::group_by()`  | Agrupa dados por categorias            |
| `dplyr::summarize()` | Calcula estatísticas resumidas         | 
| `dplyr::arrange()`   | Ordena linhas                          |

**Lembre-se**: O poder do dplyr está em combinar estas funções com o 
operador pipe `%>%`
:::




## Pacote dplyr: Bibliografia Recomendada

- [R para Ciência de Dados - Cap. 3](http://pt.r4ds.hadley.nz/data-transform.html){target="_blank"}

- [Introdução à Linguagem R - Cap. 5](https://pedropark99.github.io/Introducao_R/Capítulos/04-transformacao.html){target="_blank"}

- [Resumo](https://rstudio.github.io/cheatsheets/translations/portuguese/data-transformation_pt_br.pdf){target="_blank"}





# dplyr: Tipos Básicos de *joins* 


::: {.callout-note icon=false}
## O Problema da Fragmentação de Dados

- Dados financeiros raramente estão concentrados em uma única 
base ou sistema:

  - **Dados de Mercado**: Preços de ativos, volumes, volatilidade em 
    sistemas como Bloomberg ou Economática
  - **Demonstrações Financeiras**: Balanços patrimoniais, DREs e fluxos 
    de caixa em bases como CVM ou Capital IQ
  - **Informações de Governança**: Composição de conselhos, estrutura de 
    propriedade em formulários de referência
  - **Dados Macroeconômicos**: Indicadores como juros, inflação e PIB em 
    bases do Banco Central ou IBGE

- Análises de dados muitas vezes exigem a **integração** dessas múltiplas 
  fontes

- **Exemplo:** Para estudar a relação entre governança e retorno ajustado ao 
risco, precisamos combinar:

  - Histórico de preços das ações (base de mercado)
  - Indicadores contábeis como ROE e alavancagem (demonstrações financeiras)
  - Estrutura de propriedade e composição do conselho (dados de governança)
  - Fatores de risco sistemático (dados macroeconômicos)

- **Joins** (**Uniões**) são operações fundamentais para esta integração 
em pesquisas financeiras empíricas
:::




::: {.callout-note icon=false}
## Joins na Pesquisa Empírica em Finanças

- **Dados Multidimensionais**: Pesquisas financeiras tipicamente 
requerem a integração de:

  - Dados de mercado (preços, retornos, volume)
  - Informações contábeis (balanços, DREs)
  - Indicadores macroeconômicos (PIB, taxas de juros, inflação)
  - Dados de governança corporativa

- **Estudos de Evento**: Análises que combinam séries temporais de 
preços de ativos com datas específicas de eventos corporativos 
(fusões, aquisições, distribuição de dividendos)

- **Análises de Dados em Painel**: Pesquisas que acompanham múltiplas empresas 
ao longo do tempo, exigindo combinação de dados transversais e longitudinais

- **Reprodutibilidade Científica**: Joins documentados garantem que 
outros pesquisadores possam reproduzir exatamente o mesmo conjunto 
de dados da análise
:::




## Desafios Específicos de Dados em Finanças

::: {.callout-note icon=false}
## Problemas Comuns em Bases Financeiras

- **Códigos de Identificação Inconsistentes**:
  - Empresas podem ter múltiplos identificadores (ticker, CNPJ, código CVM)
  - Mesma empresa pode aparecer com nomes diferentes em bases distintas
  - Subsidiárias e controladoras podem ter tratamentos diferentes

- **Periodicidades Divergentes**:
  - Dados de mercado (geralmente diários ou intradiários)
  - Dados contábeis (trimestrais ou anuais)
  - Dados macroeconômicos (mensais, trimestrais)

- **Sobrevivência das Empresas**:
  - Empresas que entram/saem da bolsa (IPOs, delisting)
  - Processos de fusão e aquisição alterando a estrutura dos dados
  - Viés de sobrevivência em estudos longitudinais

- **Tratamento Especial para Eventos Financeiros**:
  - Splits, bonificações e outros eventos corporativos
  - Reorganizações societárias
  - Mudanças em práticas contábeis (IFRS)
:::




## Aplicações Práticas de Joins na Pesquisa em Finanças

::: {.callout-note icon=false}
## Exemplos de Estudos que podem Aplicar Joins

- **Estudos de Retornos Anormais**:

  ```r
  # Combinar dados de mercado com anúncios de eventos
  estudo_evento <- dados_retornos %>%
    left_join(anuncios_dividendos, by = c("codigo_empresa", "data"))
   ```

- **Estudos sobre Governança e Valor**:

  ```r
  # Integrar dados de governança corporativa com desempenho contábil
  analise_governanca <- empresas_dados_contabeis %>%
    left_join(indices_governanca, by = "codigo_cvm") %>%
    left_join(composicao_conselhos, by = c("codigo_cvm", "ano_fiscal"))
  ```

- **Modelos de Precificação de Ativos**:

  ```r
  # Combinar fatores de risco com características das empresas
  modelo_multifatorial <- retornos_ativos %>%
    left_join(fatores_mercado, by = "data") %>%
    left_join(caracteristicas_empresas, by = c("codigo_empresa", "ano", "trimestre"))
  ```

- **Mercado de Crédito e Ratings**:

  ```r
  # Analisar impacto de mudanças de rating no custo de capital
  analise_credito <- custos_captacao %>%
    inner_join(historico_ratings, by = c("codigo_empresa", "data_emissao"))
  ```
:::




## CRISP-DM e Joins

::: {.callout-tip icon=true}
## Joins na Fase 3 (Preparação dos Dados) do CRISP-DM

- Joins são operações fundamentais na **Fase 3 (Preparação dos Dados)** 
  de CRISP-DM, permitindo:

- **Integrar dados fragmentados** que estão distribuídos em múltiplas tabelas
  relacionadas entre si

- **Consolidar informações** de diferentes fontes ou sistemas para análise
  (vendas + produtos + clientes)

- **Enriquecer dados principais** com informações contextuais adicionais
  (ex: adicionar categoria de produto aos dados de vendas)

- **Completar o ciclo de preparação** iniciado com:

  - Importação de dados (`read_csv()`, `read_xlsx()`)
  - Organização de dados (`pivot_longer()`) para análise
  - Limpeza de dados (`rename()``, `as.___()`)
  - Filtragem (`filter()`) e seleção (`select()`) de dados relevantes
  - Transformação de dados (`mutate()`) para criar novas variáveis
  - Manipulação de dados ( `group_by()`, `summarize()` e `arrange()`)
  - **Joins**: integrando múltiplas fontes em um arquivo de dados coeso

- Dados bem integrados facilitam as **Fases 4 e 5** (Modelagem e Avaliação) 
  por fornecerem uma visão completa do problema
:::




## Joins no dplyr

::: {.callout-note icon=false}
## O que são joins?

- **Joins** são operações que combinam duas tabelas de dados 

- Em termos simples, joins são como "colar" duas tabelas lado a lado, 
  combinando linhas que têm valores em comum, como um "código de cliente" 
  ou "código de produto"

- No pacote dplyr, temos funções específicas para cada tipo de join:

  - `left_join()`: Mantém todas as linhas da tabela da esquerda
  - `inner_join()`: Mantém apenas correspondências entre as tabelas
  - `full_join()`: Mantém todas as linhas de ambas as tabelas
  - `right_join()`: Mantém todas as linhas da tabela da direita

- São essenciais quando precisamos combinar informações que estão separadas
:::




## Criando Tabelas de Exemplo

::: {.callout-note icon=false}
## Tabela produtos

```{r}
# Cria a tabela de produtos
produtos <- tribble(
  ~codigo_produto, ~nome_produto,      ~preco_unitario, ~categoria,
  "P001",         "Notebook Pro",      4500,           "Eletrônicos",
  "P002",         "Smartphone X",      2800,           "Eletrônicos",
  "P003",         "Monitor 24pol",     1200,           "Informática",
  "P004",         "Mouse Gamer",       250,            "Informática",
  "P005",         "Cadeira Ergonômica", 950,           "Mobiliário"
)

# exibe a tabela
produtos
```
:::



::: {.callout-note icon=false}
## Tabela vendas

```{r}
# Cria a tabela de vendas
vendas <- tribble(
  ~id_venda, ~codigo_produto, ~id_cliente, ~data_venda,  ~quantidade,
  1,         "P001",          "C001",      "2025-04-15", 1,
  2,         "P002",          "C002",      "2025-04-16", 2,
  3,         "P003",          "C001",      "2025-04-18", 2,
  4,         "P002",          "C003",      "2025-04-20", 1,
  5,         "P006",          "C002",      "2025-04-22", 3,
  6,         "P004",          "C004",      "2025-04-23", 4
)

# exibe a tabela
vendas
```
:::



::: {.callout-note icon=false}
## Tabela Clientes

```{r style="font-size: 1em;"}
# Crian a tabela de clientes 
clientes <- tribble(
  ~id_cliente, ~nome_cliente,     ~cidade,
  "C001",      "Empresa Alpha",   "São Paulo",
  "C002",      "Empresa Beta",    "Rio de Janeiro",
  "C003",      "João Silva",      "Belo Horizonte",
  "C005",      "Maria Oliveira",  "Recife"
)

# exibe a tabela
clientes
```
:::


::: {.callout-note icon=false}
## Dados dos Exemlos 

```{r style="font-size: 1em;"}
produtos
vendas
clientes
```


**Observe que há dados "imperfeitos"**: 

- Produto "P006" está nas vendas, mas não na tabela de produtos
- Cliente "C004" está nas vendas, mas não na tabela de clientes
- Cliente "C005" está na tabela de clientes, mas não tem vendas
:::




## Chaves em Joins

::: {.callout-note icon=false}
## Como tabelas se relacionam

- **Chaves** são as colunas usadas para combinar as tabelas

- Na prática:

  - A tabela de clientes tem um "codigo_cliente" único para cada cliente
  
  - A tabela de vendas usa esse mesmo "codigo_cliente" para indicar qual 
    cliente fez cada compra
    
  - O "codigo_cliente" é a "chave" que permite combinar as informações 
    das duas tabelas

- Nas funções de join do dplyr, as chaves são especificadas pelo 
argumento `by`
:::




## Tipos de Chaves em Bancos de Dados Relacionais


::: {.callout-note icon=false}
## Chaves Primárias e Estrangeiras

- **Chave primária**: Identificador único para cada registro em uma tabela

  - Ex: `codigo_cliente` na tabela de clientes identifica unicamente cada cliente
  - Não pode conter valores duplicados ou nulos
  
- **Chave estrangeira**: Coluna que referencia a chave primária de outra tabela

  - Ex: `codigo_cliente` na tabela de vendas é uma chave estrangeira
  - Estabelece relações entre tabelas e mantém a integridade referencial

- **Analogia**: Pense em chaves como um sistema de CPF

  - A chave primária é como o CPF único de cada pessoa
  - A chave estrangeira é como mencionar o CPF de alguém em um documento
  - Os joins são como reunir documentos diferentes sobre a mesma pessoa usando seu CPF
:::





## Diagrama de Relações com Chaves


::: {.callout-note icon=false}
## Visualizando a relação entre tabelas

```{.markdown}
Tabela CLIENTES                 Tabela VENDAS
+--------------+            +---------------+
| codigo_cliente| <--------- |codigo_cliente |  
| nome_cliente  |            | id_venda      |
| cidade        |            | data_venda    |
+--------------+            +---------------+
   Chave Primária             Chave Estrangeira
```

- **Integridade referencial**: Garante que relações entre tabelas permaneçam válidas
  - Impede a criação de vendas para clientes inexistentes
  - Fundamental para a confiabilidade dos dados em sistemas empresariais
:::





## Exemplos Comuns de Chaves

::: {.callout-note icon=false}
## Chaves em sistemas empresariais

Exemplos comuns de chaves em sistemas de informação empresariais:

- **"codigo_produto"** para relacionar produtos e vendas
- **"codigo_funcionario"** para relacionar funcionários e departamentos
- **"numero_pedido"** para relacionar pedidos e itens de pedido
- **"codigo_fiscal"** para relacionar notas fiscais e itens fiscais
- **"matricula_aluno"** em sistemas educacionais
- **"numero_prontuario"** em sistemas de saúde

A identificação correta das chaves é fundamental para o sucesso de joins e para garantir a integridade das análises de dados.
:::





## Desafios com Chaves em Joins

::: {.callout-note icon=false}
## Problemas comuns ao trabalhar com chaves

- **Chaves duplicadas**: 

  - Podem gerar múltiplas linhas no resultado (multiplicação de dados)
  - Exemplo: Um cliente vinculado a várias vendas resulta em múltiplas linhas

- **Chaves ausentes**: 

  - Resultam em valores NA quando usando left, right ou full joins
  - Exemplo: Vendas sem cliente cadastrado ou produtos sem vendas

- **Inconsistência de tipos**: 

  - Problemas quando a mesma chave tem tipos diferentes em tabelas distintas
  - Exemplo: código armazenado como texto em uma tabela e número em outra

- **Diferenças de nomenclatura**:

  - Quando a mesma informação tem nomes diferentes em sistemas distintos
  - Requer especificação explícita: `by = c("codigo_produto" = "codigo")`
:::



## Sintaxe Básica de Joins no dplyr

::: {.callout-tip}
## Como usar joins no dplyr (simplificado)

```{r}
#| eval: false

# Formato básico (simples)
resultado <- x %>% 
  tipo_join(y, by = "coluna_comum")

# Exemplo com nossas tabelas
vendas_com_produtos <- vendas %>%
  left_join(produtos, by = "codigo_produto")
```

**O que cada parte significa:**

- `vendas`: A primeira tabela (tabela da esquerda)
- `produtos`: A segunda tabela (tabela da direita)
- `by = "codigo_produto"`: A coluna comum que existe em ambas as tabelas
- `left_join`: O tipo de join que queremos usar
- `vendas_com_produtos`: O resultado da combinação que salvaremos
:::




## Visão Geral dos Joins 

::: {.callout-tip}
## Em resumo:

| Tipo de Join  | Função no dplyr    | Quando usar                                  |
|---------------|--------------------|-------------------------------------------------|
| Left join     | `left_join()`      | Quando você precisa manter todos os registros da tabela principal (à esquerda) |
| Inner join    | `inner_join()`     | Quando você precisa apenas dos registros que existem em ambas as tabelas |
| Full join     | `full_join()`      | Quando você precisa de todos os dados, independentemente de correspondências |
| Right join    | `right_join()`     | Quando você precisa manter todos os registros da tabela secundária (à direita) |
:::




## Left Join 

::: {.callout-tip}
## Função left_join()

```{r}
#| eval: false
resultado <- x %>% 
  left_join(y, by = "chave")
```
:::


![](img/left-join.gif){fig-align="center"}



::: {.callout-note icon=false}
## Características do Left Join

- Mantém **todos** os registros da tabela da esquerda (primeira tabela)

- Para registros sem correspondência na tabela da direita, preenche com NA

- **Quando usar**:

  - Quando a primeira tabela é sua tabela principal
  - Quando você precisa preservar todos os registros da primeira tabela
  - Quando você quer adicionar informações extras à sua tabela principal

- **Exemplo**: Manter todas as vendas e adicionar dados dos produtos
:::





## Exemplo: Left Join em Pesquisa

::: {.callout-note icon=false}
## Left Join: Análise de Empresas e seus Indicadores Contábeis

```{r}
# Tabela de empresas listadas
empresas_listadas <- tribble(
  ~codigo_cvm, ~empresa,            ~setor,              ~segmento_listagem,
  "11592",     "Petrobras",         "Petróleo e Gás",    "Nível 2",
  "19615",     "Vale",              "Mineração",         "Novo Mercado",
  "14311",     "Itaú Unibanco",     "Financeiro",        "Nível 1",
  "18112",     "Natura",            "Bens de Consumo",   "Novo Mercado",
  "22691",     "Magazine Luiza",    "Varejo",            "Novo Mercado"
)

# visualiza o resultado
empresas_listadas 
```


```{r}
# Tabela de indicadores contábeis
indicadores_contabeis <- tribble(
  ~codigo_cvm, ~ano_fiscal, ~roa,    ~roe,    ~ebitda_margem,  ~divida_liquida,
  "11592",     2023,         0.089,   0.235,   0.392,           315780000,
  "19615",     2023,         0.112,   0.268,   0.468,           185230000,
  "14311",     2023,         0.064,   0.195,   0.412,           NULL,
  "22691",     2023,         0.052,   0.148,   0.185,           12450000
)
# visualiza o resultado
indicadores_contabeis 
```


```{r}
# Left join: todas as empresas, mesmo sem indicadores contábeis disponíveis
analise_empresas <- empresas_listadas %>%
  left_join(indicadores_contabeis, by = "codigo_cvm")

# Visualizando o resultado
analise_empresas
```

**Observe que**:

- A empresa "Natura" (código CVM "18112") **aparece** no resultado

- Como não há dados contábeis disponíveis para esta empresa, as colunas de indicadores aparecem com NA

- O left_join é muito utilizado em pesquisas quando queremos manter todas as empresas da amostra, mesmo aquelas com dados incompletos - decisão metodológica comum em estudos com amostras pequenas
:::





## Inner Join {.smaller}


::: {.callout-tip}
## Função inner_join()

```{r}
#| eval: false
resultado <- x %>% 
  inner_join(y, by = "chave")
```
:::


![](img/inner-join.gif){fig-align="center"}



::: {.callout-note icon=false}
## Características do Inner Join

- Mantém **apenas** os registros que possuem correspondência em **ambas** 
as tabelas

- Descarta linhas que não têm correspondência

- **Quando usar**:

  - Quando você precisa garantir que todos os registros tenham informações 
    completas
    
  - Quando registros sem correspondência não são relevantes para sua análise

- **Exemplo**: Relatório de vendas que precisa mostrar dados do produto
:::





## Exemplo: Inner Join em Pesquisa 


::: {.callout-note icon=false}
## Inner Join: Analisando Eventos de Rating e Performance de Bonds

```{r}
# Tabela de títulos de dívida corporativa (bonds)
titulos_divida <- tribble(
  ~isin,          ~emissor,        ~valor_emissao, ~yield_to_maturity, ~vencimento,
  "BRPETRDBS036", "Petrobras",     1000000000,     0.0785,             "2030-03-15",
  "BRVALEDBF009", "Vale",           750000000,     0.0652,             "2032-10-08",
  "BRITAUDB0025", "Itaú Unibanco",  500000000,     0.0723,             "2028-05-22",
  "BRBTGPDB0017", "BTG Pactual",    650000000,     0.0798,             "2029-08-30",
  "BRCVCODB0032", "Cielo",          350000000,     0.0815,             "2027-11-12"
)
# visualiza o resultado
titulos_divida
```


```{r}
# Tabela de mudanças de rating
mudancas_rating <- tribble(
  ~isin,          ~data_evento,  ~agencia,   ~rating_anterior, ~novo_rating, ~perspectiva,
  "BRPETRDBS036", "2023-05-10",  "Moody's",  "Ba2",            "Ba1",        "Positiva",
  "BRVALEDBF009", "2023-06-22",  "S&P",      "BBB",            "BBB+",       "Estável",
  "BRVALEDBF009", "2023-08-15",  "Fitch",    "BBB",            "BBB+",       "Estável",
  "BRITAUDB0025", "2023-07-08",  "Moody's",  "Ba1",            "Baa3",       "Estável",
  "BRECOPDB0016", "2023-09-14",  "S&P",      "BB-",            "BB",         "Positiva"
)
# visualiza o resultado
mudancas_rating
```


```{r}
# Inner join: apenas títulos de dívida que tiveram mudanças de rating
analise_rating_impacto <- titulos_divida %>%
  inner_join(mudancas_rating, by = "isin")

# Visualizando o resultado
analise_rating_impacto
```

**Observe que**:

- O título da "Cielo" (ISIN "BRCVCODB0032") **não aparece** no resultado 
  pois não teve mudança de rating no período analisado

- A mudança de rating do título "BRECOPDB0016" também **não aparece** no resultado
  pois este título não está na nossa base de títulos monitorados

- O inner_join é apropriado para estudos de evento onde queremos analisar apenas 
  os casos onde ocorreu o evento específico (neste caso, mudança de rating)
:::





## Full Join 

::: {.callout-tip}
## Função full_join()

```{r}
#| eval: false
resultado <- x %>% 
  full_join(y, by = "chave")
```
:::


![](img/full-join.gif){fig-align="center"}



::: {.callout-note icon=false}
## Características do Full Join

- Mantém **todos** os registros de **ambas** as tabelas

- Para registros sem correspondência em qualquer tabela, preenche com NA

- **Quando usar**:

  - Quando você precisa de uma visão completa de todos os dados
  - Quando quer identificar inconsistências entre tabelas
  - Quando é importante não perder nenhum registro de nenhuma tabela

- **Exemplo**: Relatório completo de produtos e vendas
:::





## Exemplo: Full Join

::: {.callout-note icon=false}
## Full Join entre Vendas e Produtos

```{r}
# Full join: todas as vendas e todos os produtos
# Passo 1: Pegamos a tabela 'vendas'
# Passo 2: Combinamos com produtos mantendo TUDO de ambas as tabelas
completo_vendas_produtos <- vendas %>%
  full_join(produtos, by = "codigo_produto")

# Visualizando o resultado
completo_vendas_produtos
```

**Observe que**:

- A venda do produto "P006" que não existe na tabela de produtos aparece 
  com NAs
  
- O produto "P005" que não tem vendas também aparece com NAs

- O full_join é útil para ver "tudo junto" e identificar inconsistências
:::




## Right Join


::: {.callout-tip}
## Função right_join()

```{r}
#| eval: false
resultado <- x %>% 
  right_join(y, by = "chave")
```
:::


![](img/right-join.gif){fig-align="center"}



::: {.callout-note icon=false}
## Características do Right Join

- Mantém **todos** os registros da tabela da direita (segunda tabela)

- Para registros sem correspondência na tabela da esquerda, preenche com NA

- **Quando usar**:

  - Quando a segunda tabela é sua tabela principal
  
  - Quando você precisa garantir que todos os registros da segunda tabela 
    estejam presentes
    
  - Na prática, muitas vezes é mais fácil usar left_join invertendo a 
    ordem das tabelas

- **Exemplo**: Ver todos os produtos, mesmo os que não foram vendidos
:::





## Exemplo: Right Join

::: {.callout-note icon=false}
## Right Join entre Vendas e Produtos

```{r}
# Right join: todos os produtos, mesmo sem vendas
# Passo 1: Pegamos a tabela 'vendas'
# Passo 2: Combinamos com TODOS os produtos, mesmo os sem vendas
produtos_vendas_right <- vendas %>%
  right_join(produtos, by = "codigo_produto")

# Visualizando o resultado
produtos_vendas_right
```

**Observe que**:

- Agora o produto "P005" (Cadeira Ergonômica) **aparece** no resultado
- Como esse produto não tem vendas, as colunas de vendas aparecem com NA
- O right_join é útil para identificar produtos sem movimento
:::




## Exemplo: Combinando Múltiplas Tabelas


::: {.callout-note icon=false}
## Estudo integrado de Governança, Retorno e Risco Sistêmico 

```{r}
# Tabela de empresas e características de governança
governanca <- tribble(
  ~codigo_negociacao, ~empresa,         ~indice_governanca, ~tipo_controlador, ~comite_auditoria,
  "PETR4",            "Petrobras",      6.8,                "Estatal",         TRUE,
  "VALE3",            "Vale",           8.2,                "Pulverizado",     TRUE,
  "ITUB4",            "Itaú Unibanco",  7.9,                "Familiar",        TRUE,
  "BBDC4",            "Bradesco",       7.6,                "Familiar",        TRUE,
  "MGLU3",            "Magazine Luiza", 7.1,                "Familiar",        FALSE
)
# visualiza o resultado
governanca
```


```{r}
# Tabela de retornos anuais ajustados
retornos <- tribble(
  ~codigo_negociacao, ~ano,  ~retorno_anual, ~volatilidade, ~beta,
  "PETR4",            2023,   0.125,          0.285,        1.32,
  "VALE3",            2023,   0.084,          0.215,        1.18,
  "ITUB4",            2023,   0.152,          0.195,        0.87,
  "BBDC4",            2023,   0.138,          0.205,        0.92,
  "ABEV3",            2023,   0.062,          0.165,        0.72
)
# visualiza o resultado
retornos
```


```{r}
# Tabela de indicadores contábeis
indicadores <- tribble(
  ~codigo_negociacao, ~ano,  ~roa,    ~alavancagem, ~tamanho_ativo,
  "PETR4",            2023,   0.089,   0.325,        395120000,
  "VALE3",            2023,   0.112,   0.285,        312450000,
  "ITUB4",            2023,   0.064,   0.852,        2185620000,
  "BBDC4",            2023,   0.058,   0.815,        1924380000,
  "MGLU3",            2023,   0.052,   0.368,         28540000
)
# visualiza o resultado
indicadores
```


```{r}
# Pipeline de análise integrada
analise_integrada <- governanca %>%
  # Primeiro, adicionamos dados de retorno e risco
  left_join(retornos, by = "codigo_negociacao") %>%
  # Depois, adicionamos indicadores contábeis
  left_join(indicadores, by = c("codigo_negociacao", "ano")) %>%
  # Selecionamos apenas as variáveis relevantes para o estudo
  select(
    empresa, codigo_negociacao, ano, indice_governanca, tipo_controlador,
    retorno_anual, volatilidade, beta, 
    roa, alavancagem, tamanho_ativo
  )

# Visualizando o resultado
analise_integrada
```

**Observe como**:

- Este pipeline combina três conjuntos de dados distintos (governança, mercado e contábil)
- Empresas como "Magazine Luiza" (MGLU3) aparecem sem dados de retorno (NA)
- "ABEV3" aparece nos dados de retorno, mas não nas outras tabelas

**Implicações metodológicas**:

- O uso de left_join manteve todas as empresas com dados de governança, revelando lacunas nos dados
- A definição desta amostra de estudo (firmas com dados de governança) é uma escolha metodológica explícita
- Este tipo de construção de amostra é muito útil em estudos empíricos que analisam relações entre diferentes conjuntos de observações e variáveis.
:::





## Exemplo: Análise de Demonstrações Financeiras


::: {.callout-note icon=false}
## Cenário: Pesquisa em Desempenho Financeiro Setorial

```{r}
# Tabela com informações básicas das empresas
empresas <- tribble(
  ~codigo_cvm, ~nome_empresa,      ~setor,              ~tamanho,  ~governanca,
  "11592",    "Petrobras S.A.",    "Petróleo e Gás",    "Grande",  "Nível 2",
  "19615",    "Vale S.A.",         "Mineração",         "Grande",  "Novo Mercado",
  "14311",    "Itaú Unibanco S.A.", "Financeiro",       "Grande",  "Nível 1",
  "18112",    "Natura Cosméticos", "Bens de Consumo",   "Médio",   "Novo Mercado",
  "22691",    "Magazine Luiza",    "Varejo",            "Médio",   "Novo Mercado"
)

# visualiza o resultado
empresas
```


```{r}
# Tabela de indicadores financeiros trimestrais
indicadores_financeiros <- tribble(
  ~codigo_cvm, ~ano, ~trimestre, ~roa,  ~alavancagem, ~liquidez_corrente, ~margem_ebitda,
  "11592",     2024,  1,          0.032,  0.58,         1.45,              0.28,
  "11592",     2024,  2,          0.041,  0.56,         1.52,              0.31,
  "19615",     2024,  1,          0.045,  0.32,         2.10,              0.34,
  "19615",     2024,  2,          0.048,  0.31,         2.15,              0.36,
  "14311",     2024,  1,          0.018,  0.82,         1.28,              0.42,
  "14311",     2024,  2,          0.019,  0.81,         1.31,              0.41,
  "22691",     2024,  1,          0.028,  0.62,         1.18,              0.12,
  "22691",     2024,  2,          0.025,  0.68,         1.12,              0.10
)
# visualiza o resultado
indicadores_financeiros
```


```{r}
# Combinando dados para análise de desempenho por setor
analise_setorial <- empresas %>%
  left_join(indicadores_financeiros, by = "codigo_cvm") %>%
  select(nome_empresa, setor, ano, trimestre, roa, alavancagem, margem_ebitda)

# Visualizando o resultado
analise_setorial
```

**Aplicação em Pesquisa**:

- Este tipo de join permite analisar desempenho financeiro controlando 
por características específicas das empresas

- Útil para estudos que investigam:
  - Impacto de governança corporativa nos indicadores contábeis
  - Diferenças de desempenho entre setores
  - Efeito do tamanho da empresa na performance financeira

- **Nota**: Observem que "Natura Cosméticos" (código 18112) não aparece 
nos resultados porque não há dados financeiros correspondentes - 
situação comum em pesquisas empíricas
:::





## Exemplo: Análise de Retornos Anormais

::: {.callout-note icon=false}
## Cenário: Estudo de Evento sobre Anúncios de Dividendos

```{r style="font-size: 1em;"}
# Tabela de preços diários de ações
precos_acoes <- tribble(
  ~ticker,   ~data,          ~preco_fechamento, ~retorno_diario, ~volume,
  "PETR4",   "2024-04-01",   36.75,             0.0125,          15200000,
  "PETR4",   "2024-04-02",   37.30,             0.0150,          18500000,
  "PETR4",   "2024-04-03",   37.05,            -0.0067,          14800000,
  "PETR4",   "2024-04-04",   37.82,             0.0208,          21300000,
  "PETR4",   "2024-04-05",   37.60,            -0.0058,          16900000,
  "VALE3",   "2024-04-01",   68.45,             0.0087,          22400000,
  "VALE3",   "2024-04-02",   68.92,             0.0069,          19800000,
  "VALE3",   "2024-04-03",   70.15,             0.0178,          25600000,
  "VALE3",   "2024-04-04",   71.20,             0.0150,          28300000,
  "VALE3",   "2024-04-05",   70.85,            -0.0049,          23100000
)

# visualiza o resultado
precos_acoes
```


```{r}
# Tabela de anúncios de eventos corporativos
eventos_corporativos <- tribble(
  ~ticker,   ~data_anuncio,   ~tipo_evento,        ~valor,
  "PETR4",   "2024-04-03",    "Dividendo Extra",   2.85,
  "VALE3",   "2024-04-04",    "JCP",               1.75
)
# visualiza o resultado
eventos_corporativos
```


```{r}
# Realizando análise de retornos nos dias de evento
estudo_evento <- precos_acoes %>%
  inner_join(eventos_corporativos, 
             by = c("ticker", "data" = "data_anuncio")) %>%
  select(ticker, data, tipo_evento, valor, retorno_diario, volume)

# Visualizando o resultado
estudo_evento
```

**Aplicação em Pesquisa**:

- Este tipo de join é relevante para estudos de evento que analisam o 
impacto de anúncios corporativos sobre o preço das ações

- Aplicações em pesquisas financeiras incluem:
  - Reação do mercado a anúncios de distribuição de proventos
  - Avaliação da eficiência informacional em mercados emergentes
  - Impacto de divulgações contábeis e eventos não-recorrentes

- O `inner_join` utilizado garante que apenas os dias com eventos são 
considerados para a análise de retornos anormais
:::





## Fontes Comuns de Dados em Pesquisa Financeira


::: {.callout-note icon=false}
## Bases que Frequentemente Requerem Joins

- **Bases Estruturadas para Pesquisa Acadêmica**:
  - **Economática**: Dados contábeis e de mercado de empresas brasileiras
  - **Bloomberg**: Dados financeiros globais de alta frequência

- **Fontes Públicas no Brasil**:
  - **B3**: Dados de negociação, índices e eventos corporativos
  - **CVM**: Demonstrações financeiras padronizadas (DFPs) e formulários de 
    referência
  - **Banco Central**: Indicadores macroeconômicos e financeiros
  - **IBGE**: Dados econômicos setoriais e regionais

- **Desafios na Integração**:
  - Identificadores divergentes entre bases (códigos CVM vs. tickers vs. CNPJ)
  - Periodicidades diferentes (diária, mensal, trimestral, anual)
  - Diferenças metodológicas na compilação dos dados
  - Tratamento de eventos corporativos (fusões, aquisições, cisões)

- **Estratégias para Joins Eficientes**:
  - Criar tabelas de correspondência entre diferentes identificadores
  - Padronizar datas para permitir joins temporais precisos
  - Documentar critérios de exclusão e tratamento de valores ausentes
:::




## Dicas para Uso Eficiente de Joins

::: {.callout-tip}
## Dicas práticas para iniciantes

1. **Conheça seus dados antes de combinar**:

   - Verifique se as tabelas têm as "chaves" correspondentes
   - Entenda o que significam valores ausentes (NAs)

2. **Filtre antes de combinar**:

   - Se você só precisa de alguns dados, filtre-os antes de fazer joins
   - Isso torna a análise mais rápida e clara

3. **Verifique o resultado**:

   - O número de linhas faz sentido?
   - Há valores NA inesperados?
   - Os totais parecem corretos?

4. **Na dúvida, use left_join**:

   - É o mais comum e seguro para iniciantes
   - Mantém todos os registros da tabela principal
:::





## O Desafio dos Sistemas Reais

::: {.callout-note icon=false}
## Situação Comum em Ambientes Empresariais

No mundo ideal, todos os sistemas usariam os mesmos nomes para as 
mesmas informações...

Mas na prática:

- O sistema de Vendas pode usar `codigo_produto`
- O Cadastro de Produtos pode usar `codigo`
- O ERP pode usar `cod_prod`
- O sistema legado pode usar `id_produto`

**Resultado**: Tentar unir estas tabelas com a sintaxe básica falha:

```{r}
#| eval: false

# Esta tentativa falha:
vendas %>% 
  left_join(produtos, by = "codigo_produto") 
  
# ERRO: 'codigo_produto' não encontrado em 'produtos'
```

Como resolver este problema comum?
:::




## A Solução

::: {.callout-note icon=false}
## Sintaxe para Colunas com Nomes Diferentes

O dplyr permite especificar explicitamente quais colunas devem ser 
correspondidas:

```{r style="font-size: 1em;"}
#| eval: false

# Sintaxe para colunas com nomes diferentes
tabela1 %>%
  left_join(tabela2, by = c("nome_na_tabela1" = "nome_na_tabela2"))
```

**Como interpretar:**

- `"nome_na_tabela1"`: Nome da coluna na primeira tabela (esquerda)
- `"nome_na_tabela2"`: Nome da coluna na segunda tabela (direita)
- O operador `=` estabelece a correspondência entre as colunas

**Analogia**: Você está criando um "dicionário de tradução" entre 
os sistemas:

- "Quando eu digo `codigo_produto`, você entende `codigo`"
:::




::: {.callout-note icon=false}
## Cenário: Relatório de Vendas Integrado

```{r}
# Sistema de Cadastro de Produtos (departamento de Compras)
produtos_cadastro <- tribble(
  ~codigo,       ~descricao,        ~valor_unitario, ~categoria,
  "P001",        "Notebook Pro",     4500,           "Eletrônicos",
  "P002",        "Smartphone X",     2800,           "Eletrônicos",
  "P003",        "Monitor 24pol",    1200,           "Informática"
)
# visualiza o resultado
produtos_cadastro
```


```{r}
# Sistema de Vendas (departamento Comercial)
vendas_sistema <- tribble(
  ~id_venda, ~cod_produto, ~data_venda,  ~qtd,
  1,         "P001",       "2025-04-15", 1,
  2,         "P002",       "2025-04-16", 2,
  3,         "P003",       "2025-04-18", 2
)
# visualiza o resultado
vendas_sistema
```


```{r}
# Integrando os sistemas com diferentes nomenclaturas
relatorio_vendas <- vendas_sistema %>%
  left_join(produtos_cadastro, by = c("cod_produto" = "codigo")) %>%
  select(id_venda, data_venda, cod_produto, descricao, qtd, valor_unitario) %>%
  mutate(valor_total = qtd * valor_unitario) %>%
  arrange(data_venda)

# Resultado: um relatório integrado
relatorio_vendas
```

**Observação**: Esta situação é extremamente comum.
:::





## Resumo: Joins

::: {.callout-tip}
## Pontos-chave para lembrar

1. **Joins unem tabelas que estão separadas**

   - Combinam dados de clientes, produtos, vendas, etc.
   - Permitem análises mais completas e informativas

2. **Os tipos mais importantes são**:

   - `left_join()`: Mantém todos os registros da tabela principal (o mais 
      usado)
   - `inner_join()`: Mantém apenas registros com correspondência em ambas 
      tabelas
   - `full_join()`: Mantém todos os registros de ambas as tabelas

3. **Na prática, left_join é o mais comum**:

   - Mantém todos os registros da tabela principal
   - Adiciona informações complementares quando disponíveis
   - Evita a perda de registros importantes

4. **Comece simples e avance gradualmente**:

   - Primeiro faça joins entre duas tabelas
   - Depois adicione mais tabelas conforme necessário
   - Verifique os resultados a cada passo
:::



::: {.callout-tip}
## Guia Rápido de Joins no dplyr

| Tipo de Join | Função | Resultado | Quando Usar | Analogia de Negócios |
|--------------|--------|-----------|-------------|----------------------|
| **Inner Join** | `inner_join()` | Apenas registros com correspondência | Análises que exigem dados completos | Relatório com apenas vendas confirmadas |
| **Left Join** | `left_join()` | Todos os registros da tabela esquerda | Manter a tabela principal intacta | Relatório de todas as vendas (com ou sem produto cadastrado) |
| **Right Join** | `right_join()` | Todos os registros da tabela direita | Quando a 2ª tabela é a principal | Catálogo com todos os produtos (vendidos ou não) |
| **Full Join** | `full_join()` | Todos os registros de ambas as tabelas | Análises completas e auditorias | Verificação de inconsistências no sistema |

**Dica para lembrar**: Pense no "lado" que você quer preservar:

- **Left** = Tudo do **lado esquerdo** (1ª tabela)
- **Inner** = Só o que está nos **dois lados**
- **Full** = **Tudo** de **ambos os lados**
- **Right** = Tudo do **lado direito** (2ª tabela)
:::




## Sintaxe Comparativa


::: {.callout-note icon=false}
## Estrutura comum dos diferentes tipos de joins

```{r}
#| eval: false
# LEFT JOIN: todos os registros da tabela1

tabela1 %>% 
  left_join(tabela2, by = "coluna_comum")

# INNER JOIN: apenas registros com correspondência

tabela1 %>% 
  inner_join(tabela2, by = "coluna_comum")

# FULL JOIN: todos os registros de ambas as tabelas

tabela1 %>% 
  full_join(tabela2, by = "coluna_comum")

# RIGHT JOIN: todos os registros da tabela2

tabela1 %>% 
  right_join(tabela2, by = "coluna_comum")
```

**Observe que:**

1. **A estrutura básica é idêntica** para todos os joins:

   - Comece com a primeira tabela
   - Use o operador pipe `%>%`
   - Aplique a função de join
   - Adicione a segunda tabela e a coluna comum

2. **Só muda o nome da função**, que indica qual tipo de join realizar:
   - `inner_join`, `left_join`, `right_join` ou `full_join`

3. **Quando as colunas têm nomes diferentes**, use esta sintaxe:

```{r style="font-size: 1em;"}
#| eval: false
# Quando colunas têm nomes diferentes nas tabelas
vendas %>% 
  left_join(produtos, by = c("codigo_produto" = "codigo"))
#            ^ coluna na tabela vendas   ^ coluna na tabela produtos
```
:::




## Onde Aplicar Joins em Pesquisa Financeira


::: {.callout-note icon=false}
## Aplicações práticas em Pesquisa e Análise Financeira

- **Finanças Corporativas**:

  - Combinar dados de estrutura de capital com métricas de desempenho 
    para análise de trade-offs
  - Unir séries históricas de dividendos com indicadores de estrutura 
    de propriedade
  - Integrar dados de fusões e aquisições com características específicas 
    das empresas
  - Analisar relações entre estrutura de governança corporativa e custo 
    de capital

- **Mercado de Capitais**:

  - Relacionar retornos anormais a eventos corporativos específicos 
    (estudos de evento)
  - Combinar fatores de risco sistemático com características específicas 
    das empresas
  - Unir dados de negociação de alta frequência com anúncios macroeconômicos
  - Integrar preços de ativos com métricas de liquidez e volatilidade implícita

- **Finanças Comportamentais**:

  - Integrar dados de transações de investidores individuais com 
    características socioeconômicas
  - Combinar sentiment analysis de notícias financeiras com movimentos 
    de preços
  - Unir dados de pesquisas de percepção de risco com comportamento real 
    de investimento
  - Relacionar características psicométricas com decisões de portfólio

- **Econometria Financeira**:

  - Construir painéis de dados balanceados para estimação de modelos 
    longitudinais
  - Combinar séries temporais financeiras com variáveis instrumentais 
    para análises causais
  - Integrar dados de diferentes frequências (diários, mensais, trimestrais) 
     para modelos misto-frequência
  - Unir dados micro e macroeconômicos para análises multiníveis
:::




## Joins: Bibliografia Recomendada

- [R para Ciência de Dados - Cap. 19](http://pt.r4ds.hadley.nz/joins.html){target="_blank"}

- [Introdução à Linguagem R - Cap. 6](https://pedropark99.github.io/Introducao_R/Capítulos/06-dados-relacionais.html#introduzindo-joins){target="_blank"}





# Dados Organizados: Potencializando Análises de Dados


::: {.callout-tip}
## Dados Longos = Dados Organizados

Com os dados organizados (formato longo), podemos facilmente, 
por exemplo:

- Calcular indicadores de desempenho por categoria e período
- Calcular indicadores de desempenho por produto e período
- Analisar tendências mensais para decisões de estoque e marketing
- etc.
:::




## Aplicações 

::: {.callout-note icon=false}
## Dados organizados permitem:

- **Finanças e Controladoria**: Análise de tendências financeiras entre 
períodos, detecção de anomalias em despesas, comparação de desempenho entre 
unidades de negócio

- **Marketing**: Avaliação de ROI por canal e campanha, análise de 
comportamento do consumidor, segmentação de clientes baseada em 
múltiplas variáveis

- **Operações e Cadeia de Suprimentos**: Otimização de estoques baseada em 
tendências sazonais, previsão de demanda, monitoramento da cadeia de 
suprimentos

- **Recursos Humanos**: Análise de desempenho ao longo do tempo, identificação 
de fatores de turnover, planejamento de capacitação

- **Estratégia de Negócios**: Consolidação de KPIs de diversas áreas para 
tomada de decisão, identificação de correlações entre variáveis de negócio

- **Na prática**: Administradores frequentemente recebem dados em formatos 
inadequados para análise (relatórios estáticos, planilhas "bonitas"). 
A capacidade de reorganizar esses dados rapidamente para análise 
representa uma vantagem competitiva significativa.
:::





## Um Pipeline Completo com dplyr


```{r}
# inicia com a df (gapminder) e salva o resultado final
relatorio_expectativa <- gapminder %>%
  # Filtra apenas os dados de 2007
  filter(year == 2007) %>%
  # Agrupa por continente
  group_by(continent) %>%
  # Calcula estatísticas por continente
  summarize(
    expectativa_media = mean(lifeExp),
    expectativa_minima = min(lifeExp),
    expectativa_maxima = max(lifeExp),
  ) %>%
  # Ordena do maior para o menor
  arrange(desc(expectativa_media))

# Visualiza o resultado final
relatorio_expectativa
```





## Tabelas Profissionais 

::: {.callout-note icon=false}
## Limitações das Data Frames Brutas em Relatórios Profissionais

- As data frames produzidas pelos pipelines do dplyr são excelentes 
para **análise**, mas não são adequadas para **apresentação** em 
relatórios profissionais.

- A linguagem R oferece várias soluções para esta limitação:

    - O pacote **kableExtra** (que veremos a seguir) para relatórios HTML e PDF
    - O pacote **gt** para tabelas altamente personalizáveis

- Estes pacotes permitem transformar dados analíticos em tabelas com 
qualidade profissional, incluindo:

    - título, nomes das colunas e notas formatadas
    - destaque visual para informações importantes  
    - personalização de cores, bordas e estilos de texto
    - entre outras.

:::





## O Pacote kableExtra

::: {.callout-note icon=false}
## Transformando tabelas básicas em apresentações profissionais

- O pacote `kableExtra` estende as funcionalidades da função básica 
`kable` do R, permitindo a criação de tabelas com qualidade de publicação.

- Foi desenvolvido para trabalhar com tabelas em documentos HTML e 
PDF (LaTeX).

- Permite formatar tabelas para relatórios profissionais, artigos 
acadêmicos e apresentações.

- É extremamente útil na Fase 6 do CRISP-DM (Implantação), quando
precisamos comunicar resultados de forma clara e atrativa.
:::





## Sintaxe Básica do kableExtra

::: {.callout-tip}
## Fluxo básico com kableExtra 

```{r}
#| eval: false

#  inicie com uma data frame
tabela_formatada <- dados %>%
  # Transforme a data frame em tabela básica
  kable(
    caption = "Título da Tabela",
    col.names = c("Nome1", "Nome2"), # Renomear colunas
    digits = 2,                      # Casas decimais
    format.args = list(decimal.mark = ",", big.mark = ".") # Define vírgula como separador decimal e ponto como separador de milhares
  ) %>%
  # Adicionar estilos
  kable_styling(
    bootstrap_options = c("striped", "hover"),
    full_width = FALSE,
    position = "center"
  )
```

- **kable()**: Converte a data frame em tabela básica
- **kable_styling()**: Aplica estilos visuais à tabela
- Outros elementos podem ser adicionados em sequência com o pipe (`%>%`)
:::



::: {.callout-tip}
## Pipeline para relatórios profissionais

Em projetos de análise de dados completos, o fluxo geralmente é:

1. **Preparar dados** com  `tidyr` e `dplyr`
2. **Analisar dados** com `dplyr` (filter, select, group_by, etc.)
3. **Visualizar resultados** com `ggplot2` (gráficos) e `kableExtra` (tabelas)

Um pipeline completo pode é similar com:

```{r}
#| eval: false

# Pipeline completo de análise até apresentação
dados_brutos %>%
  # Fase de limpeza e preparação
  filter(...) %>%
  select(...) %>%
  mutate(...) %>%
  
  # Fase de análise e agregação
  group_by(...) %>%
  summarize(...) %>%
  
  # Fase de apresentação em tabela
  kable(...) %>%
  kable_styling(...) %>%
  column_spec(...)
```

Este fluxo integrado representa as fases 3, 4 e 6 do CRISP-DM.
:::




## Resumo

::: {.callout-tip}
## Pacote kableExtra

1. **Para que serve**: Transformar tabelas de dados simples em 
tabelas profissionais para relatórios, apresentações e publicações.

2. **Sintaxe básica**:

```{r style="font-size: 1em;"}
#| eval: false
dados %>%
  kable(...) %>%
  kable_styling(...) %>%
  ... outras personalizações ...
```

3. **Funções principais**:

   - `kable()`: Converte data frame em tabela base
   - `kable_styling()`: Aplica estilos gerais à tabela
   - `column_spec()` e `row_spec()`: Personalizações específicas
   - `footnote()`: Adiciona notas de rodapé

4. **Integrações estratégicas**:

   - Ideal no final de pipelines dplyr para apresentar resultados
   - Complementar aos gráficos do ggplot2 em relatórios

5. **Benefícios em Administração**:

   - Eleva a qualidade visual de relatórios gerenciais
   - Facilita a comunicação de insights de dados para gestores
   - Permite destacar KPIs e métricas críticas para tomada de decisão
:::





## Tabela com o Pacote KableExtra


```{r}
#| label: tbl-1
#| tbl-cap: "Expectativa de Vida (em anos) por Continente (2007)"
#| echo: true

# inicia com a df contendo o resultado do pipeline
relatorio_expectativa %>%
  # Converte a df em uma tabela kable (tabela básica HTML/LaTeX)
  kable(
    # Renomeia as colunas para português
    col.names = c(
      "Continente", "Expectativa Média", "Expectativa Mínima", "Expectativa Máxima"
    ),
    # Formata os números com 1 casa decimal
    digits = 1,
    # vírgula como separador decimal
    format.args = list(decimal.mark = ",")
  ) %>%
  # Adiciona estilo à tabela para melhorar o visual
  kable_classic(
    # tamanho da fonte
    font_size = 25,
    # Impede que a tabela ocupe toda a largura disponível
    full_width = FALSE,
    # # Centraliza a tabela
    position = "center"
  ) %>%
  # Aplica formatação específica à coluna da expectativa média
  column_spec(
    # Aplica a formatação à segunda coluna (Expectativa Média)
    2,
    # Coloca o texto em negrito para melhor destaque
    bold = TRUE,
    # Define a cor dos números como branco
    color = "white",
    # Aplica um gradiente de cores ao fundo das células
    background = spec_color(
      # A expectativa_media determinar a intensidade das cores
      relatorio_expectativa$expectativa_media,
      # início do gradiente com intensidade alta
      begin = 0.9,
      # fim do gradiente com intensidade baixa
      end = 0.1,
      # paleta de cores "viridis" (azul-verde-amarelo)
      option = "viridis",
      # 1 = valores mais altos recebem cores mais intensas
      direction = 1
    )
  )
```




## Exemplo Típico em Administração (Wide)

::: {.callout-note icon=false}
## Dados de Vendas Mensais por Categoria e Produto

```{r}
# formato típico de planilhas gerenciais
dados_vendas_wide <- tribble(
  ~produto, ~categoria, ~Jan, ~Fev, ~Mar, ~Abr, ~Mai, ~Jun,
  "Notebook Pro", "Eletrônicos", 45000, 38000, 42000, 47000, 52000, 49000,
  "Smartphone X", "Eletrônicos", 38000, 41000, 40000, 39000, 45000, 50000,
  "Monitor 24pol", "Informática", 22000, 19000, 23000, 25000, 24000, 26000,
  "Mouse Gamer", "Informática", 12000, 14000, 13500, 15000, 16000, 17500,
  "Mesa Office", "Mobiliário", 28000, 25000, 24000, 26500, 27000, 29000,
  "Cadeira Ergo", "Mobiliário", 35000, 32000, 38000, 36000, 39000, 42000
)

# Visualizando os dados no formato amplo (wide)
dados_vendas_wide
```
:::




## Transformando para Analise de Dados

::: {.callout-note icon=false}
## Aplicando pivot_longer para organizar os dados

```{r}
# Transformando os dados para o formato longo (tidy)
dados_vendas_longo <- dados_vendas_wide %>%
  pivot_longer(
    cols = Jan:Jun, # colunas que serão transformadas em valores de mes
    names_to = "mes", # nome da nova coluna
    values_to = "valor_vendas" # nome de outra nova coluna para as vendas
  )

# Visualizando o resultado
dados_vendas_longo
```

**Agora os dados estão organizados para análise**:

- Cada linha representa uma combinação única de produto, categoria e mês
- As vendas mensais estão em uma única coluna (valor_vendas)
- A informação do mês está em uma coluna própria (mes)
:::




## Análise 1 - Nível Básico

::: {.callout-note icon=false}
## Análise da Receita Bruta Mensa de Vendas

```{r}
# pipeline de análise
receita_bruta_mes <- dados_vendas_longo %>%
  group_by(mes) %>%
  summarize(vendas_total = sum(valor_vendas)) %>%
  arrange(desc(vendas_total))

# visualiza o resultado
receita_bruta_mes
```
:::




## Análise 2 - Nível Básico

::: {.callout-note icon=false}
## Análise das Vendas Mensais de um Produto Específico

```{r}
# pipeline de análise
vendas_mensais_notebookpro <- dados_vendas_longo %>%
  filter(produto == "Notebook Pro") %>%
  select(produto, mes, valor_vendas) %>%
  arrange(mes)

# visualiza o resultado
vendas_mensais_notebookpro
```
:::




## Análise 3 - Nível Básico

::: {.callout-note icon=false}
## Análise das Vendas Totais por Categoria e Mês

```{r}
# pipeline de análise
vendas_totais_categoria_mes <- dados_vendas_longo %>%
  group_by(categoria, mes) %>%
  summarize(vendas_totais = sum(valor_vendas)) %>%
  arrange(desc(vendas_totais))

# visualiza o resultado
vendas_totais_categoria_mes
```
:::




## Análise 4 - Nível Intermediário

::: {.callout-note icon=false}
## Análise do Desempenho mensal por produto

```{r}
# pipeline
desempenho_mensal_produto <- dados_vendas_longo %>%
  group_by(produto) %>%
  summarize(
    vendas_total = sum(valor_vendas),
    vendas_media = mean(valor_vendas),
    vendas_min = min(valor_vendas),
    vendas_max = max(valor_vendas)
  ) %>%
  arrange(desc(vendas_total))

# visualiza o resultado
desempenho_mensal_produto
```
:::




## Análise 4 - Tabela para Apresentação


```{r}
#| label: tbl-4
#| tbl-cap: "Desempenho mensal de Vendas por produto"
#| echo: true

# Formata a tabela de desempenho por produto com kableExtra
desempenho_mensal_produto %>%
  kable(
    # Renomeia as colunas para melhor apresentação
    col.names = c(
      "Produto", 
      "Vendas Totais (R$)", 
      "Média Mensal (R$)", 
      "Venda Mínima (R$)", 
      "Venda Máxima (R$)"
    ),
    # Formata números com 2 casas decimais
    digits = 2,
    # Define vírgula como separador decimal e ponto como separador de milhares
    format.args = list(decimal.mark = ",", big.mark = ".", nsmall = 2)
  ) %>%
  # Aplica um estilo clássico e limpo
  kable_classic_2(
    # Ajusta o tamanho da fonte
    font_size = 18,
    # Define largura para se ajustar melhor ao slide
    full_width = TRUE,
    # Centraliza a tabela
    position = "center"
  ) %>%
  # Destaca as colunas de valores em negrito
  column_spec(2:5, bold = TRUE) %>% 
  # Destaca as 3 primeiras linha da tabela
  row_spec(1:3, bold = T, color = "white", background = "#011f4b")
```




## Análise 5 - Nível Intermediário

::: {.callout-note icon=false}
## Identificando meses de pico de vendas para cada categoria

```{r}
# Pipeline para identificar mês de melhor desempenho por categoria
meses_pico_categoria <- dados_vendas_longo %>%
  # Agrupa por categoria e mês
  group_by(categoria, mes) %>%
  # Calcula as vendas totais
  summarize(vendas_totais = sum(valor_vendas)) %>%
  # Filtra para o mês de maior venda
  filter(vendas_totais == max(vendas_totais)) %>%
  # Ordena o resultado pelas vendas totais
  arrange(desc(vendas_totais))

# visualiza o resultado 
meses_pico_categoria
```
:::





## Análise 6 - Nível Intermediário

::: {.callout-note icon=false}
## Identificando meses de pior venda para cada categoria

```{r}
# Pipeline para identificar mês de pior desempenho por categoria
meses_pior_categoria <- dados_vendas_longo %>%
  # Agrupa por categoria e mês
  group_by(categoria, mes) %>%
  # Calcula as vendas totais
  summarize(vendas_totais = sum(valor_vendas)) %>%
  # Filtra para o mês de menor venda
  filter(vendas_totais == min(vendas_totais)) %>%
  # Ordena o resultado pelas vendas totais
  arrange(desc(vendas_totais))

# visualiza o resultado 
meses_pior_categoria
```
:::





### Funções which.max() e which.min()

::: {.callout-note icon=false}
## Localizando posições de valores máximos e mínimos

As funções `which.max()` e `which.min()` são extremamente úteis em 
análise de dados:

- `which.max(x)`: Retorna a **posição** (índice) do valor máximo no vetor `x`
- `which.min(x)`: Retorna a **posição** (índice) do valor mínimo no vetor `x`

**Exemplo simples:**

```{r}
# Vetor de valores
vendas_mensais <- c(120, 150, 140, 160, 110, 130)

# Qual a posição do valor máximo?
posicao_max <- which.max(vendas_mensais)
posicao_max

# Qual o valor máximo?
vendas_mensais[posicao_max]

# Supondo que temos nomes para os meses
nomes_meses <- c("Jan", "Fev", "Mar", "Abr", "Mai", "Jun")

# Em qual mês ocorreu a venda máxima?
mes_maior_venda <- nomes_meses[which.max(vendas_mensais)]
mes_maior_venda
```

Estas funções são perfeitas para encontrar **quando** ocorreram eventos 
importantes nos seus dados (máximos, mínimos, picos) em vez de apenas 
quais foram os valores.
:::




## Análise 7 - Nível Avançado

::: {.callout-note icon=false}
## Identificando os Meses de Maior e Menor Venda por Produto

```{r}
# Pipeline de análise para identificar os meses de pico e vale por produto
resumo_comparativo_produto <- dados_vendas_longo %>%
  # Agrupa os dados por produto para analisar cada um separadamente
  group_by(produto) %>%
  # Para cada produto, calculamos:
  summarize(
    # 1. Qual o mês da maior venda:
    # - which.max(valor_vendas) encontra a POSIÇÃO da maior venda
    # - mes[which.max(valor_vendas)] seleciona o nome do mês de maior venda
    melhor_mes = mes[which.max(valor_vendas)],

    # 2. Qual foi o valor da maior venda
    maior_venda = max(valor_vendas),

    # 3. Qual o mês da menor venda (mesma lógica do melhor mês)
    pior_mes = mes[which.min(valor_vendas)],

    # 4. Qual foi o valor da menor venda
    menor_venda = min(valor_vendas)
  )

# Visualiza o resultado
resumo_comparativo_produto
```

**Explicação do código:**

1. Primeiro agrupamos por produto para realizar a análise para 
   cada item
   
2. A função `which.max(valor_vendas)` retorna a posição (índice) do 
  valor máximo
  
3. Ao usar `mes[which.max(valor_vendas)]`, extraímos o nome do mês na 
   posição com valor máximo
   
4. Este tipo de análise é essencial para identificar padrões sazonais 
de produtos

Este relatório permite identificar rapidamente quais meses foram melhores 
e piores para cada produto - informação valiosa para planejamento de 
estoque e promoções.

Assim, esta análise permite otimizar o planejamento de estoque e 
ações promocionais sazonais.
:::





## Análise 7 - Tabela para Apresentação


```{r}
#| label: tbl-7
#| tbl-cap: "Meses de Maior e Menor Venda por Produto"
#| echo: false
#| eval: true
#| html-table-processing: none

# Formata a tabela comparativa com kableExtra
resumo_comparativo_produto %>%
  kable(
    # Renomeia as colunas para melhor apresentação
    col.names = c(
      "Produto", 
      "Melhor Mês", 
      "Maior Venda (R$)", 
      "Pior Mês", 
      "Menor Venda (R$)"
    ),
    # Formata números com 2 casas decimais
    digits = 2,
    # Define vírgula como separador decimal e ponto como separador de milhares
    format.args = list(decimal.mark = ",", big.mark = ".", nsmall = 2)
  ) %>%
  # Aplica um estilo clássico e limpo
  kable_paper(
    # Ajusta o tamanho da fonte
    font_size = 22,
    # Define largura para se ajustar melhor ao slide
    full_width = FALSE,
    # Centraliza a tabela
    position = "center"
  ) %>%
  # Destaca as colunas de valores monetários em negrito
  column_spec(c(3, 5), bold = TRUE) %>% 
  # Destaca a quarta linha da tabela
  row_spec(4, bold = T, color = "white", background = "#D7261E")
```




## Dados em Seu Ambiente de Trabalho

::: {.callout-tip}
## Reflexão

Considere os dados com os quais você já trabalha ou espera trabalhar 
em sua carreira:

1. **Que tipos** de dados desorganizados você encontra ou espera encontrar?

   - Relatórios gerenciais? 
   - Planilhas financeiras?
   - Arquivos de sistemas ERP/CRM?

2. **Como** esses dados poderiam ser melhor organizados para análise?

   - Quais são as verdadeiras "observações" nesses dados?
   - Quais são as verdadeiras "variáveis"?

3. **Quais insights de negócio** você poderia extrair se esses dados 
estivessem organizados adequadamente?

   - Padrões temporais?
   - Comparações entre unidades/produtos/regiões?
   - Correlações entre diferentes métricas?

4. **Como você aplicaria** o conhecimento desta aula em um exemplo 
concreto do seu interesse profissional?

- **Dica para sua carreira**: Manter um repositório pessoal de códigos R 
para transformações comuns que você encontra no seu trabalho pode 
economizar horas de trabalho repetitivo no futuro.
:::
































